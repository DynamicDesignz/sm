#!/usr/bin/env bash

NIY()
{
  fail "This feature has not yet been implemented."
}

extensions_install()
{
  local _extension
  local _extensions=("$@")

  for _extension in "${_extensions[@]}"
  do
    case "${_extension#\/}" in
      ext|srv|pkg|core|mod) continue ;;
    esac

    [[ -z "${_extension}" ]] && continue

    extension_src_path="${extensions_src_path}/${_extension}"

    # TODO: Install extension dependencies?

    if [[ -s "${extension_src_path}/VERSION" && -x "${extension_src_path}/bin/help" ]]
    then
      copy_directories_to "${bdsm_path}/extensions" "${extension_src_path}"
    else
      error "${extension_src_path}/${extension} is not a proper extension.\nIt is missing one or more of the VERSION or bin/help."
    fi
  done
}

extension_reload()
{
  local _path="${extension_modules_path}/bash"

  source_files "${_path}/dsl" "${_path}/initialize"
}

extension_reinitialize()
{
  local _path="${extension_modules_path}/bash"

  source_files "${_path}/initialize"
}

extension_version()
{
  local _extension="${1:-}" ; shift

  variable_is_nonempty ||
    fail "Can not retrieve extension version as no extension was given."

  true ${extension_path:="${extensions_path}/${_extension}"}

  file_exists "${extension_path}/VERSION" &&
    read -r extension_version < "${extension_path}/VERSION"

  log "${extension}-${extension_version:-head}"
}

extension_action()
{
  (
  unset extension action
  result=0
  export extension="${1:-}" ; shift
  export action="${1:-}" ; shift
  export extension_args="${extension_args:-$@}"

  [[ -n "${extension}" ]] ||
    fail "'extension' is not set! Something has gone terribly wrong."

  [[ -n "${action}" ]] ||
    fail "'action' is not set! Something has gone terribly wrong."

  extension_path="$extensions_path/$extension"
  extension_config_path="$extensions_path/$extension/config"
  extension_templates_path="$extensions_path/$extension/templates"
  extension_modules_path="$extensions_path/$extension/modules"
  extension_bin_path="$extensions_path/$extension/bin"
  extension_log_path="$log_path/$extension"

  paths=$(env | awk -F= -v ORS=' ' '/_path/{print $1}')
  flags=$(env | awk -F= -v ORS=' ' '/_flag/{print $1}')

  enter "${extension_path}" ||
    fail "Could not enter the extension directory!\n    (${extension_path})"

  bdsm_exports

  action_file="${extension_path}/bin/${action}"

  file_exists "${action_file}" ||
    fail "Action binary/file ${action} missing for extension ${extension}\n    (${action_file})"

  action_file_type="$(file "$action_file")"

  case "${action_file_type}" in

    *sh[[:space:]]script*|*POSIX[[:space:]]shell*|*Bourne-Again*)
      action_type="bash"
      ;;

    *ASCII*)
      # Launch with helper dsl, if possible.
      extension="${action_file//.}"

      case "${extension}" in
        bash|sh)
          action_type="bash"
          #rb) action_type="ruby"   ;;
          ;;
        *)
          read -r shebang < "${action_file}"

          case "${shebang}" in
            *ruby|*rbx|*jruby|*macruby)
              binary="${shebang##*(#|!)}"
              binary="${binary##* }"
              action_type="ruby"
              ;;
            *)
              if [[ -x "${action_file}" ]] ; then
                action_type="binary"
              else
                action_type="not executable"
              fi
              ;;
          esac
          ;;
      esac
      result=$?
      ;;

    cannot[[:space:]]open)
      action_type="dne"
      ;;

    *)
      if file_is_executable "${action_file}" ; then
        action_type="binary"
      else
        action_type="noexec"
      fi
      ;;
  esac

  # Now based on the determined action_type we launch the extension.
  case "${action_type}" in
    bash)
      (
      enable_backtrace
      modules core

      [[ "${action}" = "help" ]] && modules help

      source_files \
        "${extension_modules_path}/bash/dsl" \
        "${extension_modules_path}/bash/initialize" \
        "${extension_modules_path}/bash/cli"

      source "${action_file}"
      ) || result=$?
      ;;

    ruby)
      requires=()
      for script in dsl initialize
      do
        requires+=( "-r${modules_path}/ruby/core/${script}.rb" )
      done

      "${binary:-ruby}" -I"${modules_path}/ruby" -I"${extension_modules_path}/ruby" \
        ${requires[@]} "${action_file}"
      ;;
    # python|lua|javascript)
      #   ADD "${modules_path}/${action_type}/" to the lib path so the script can require "bdsm"
      #  "${action_file}"
      #  ;;
    dne|noexec)
      fail "Processing ${action} failed, file type is unknown, file does not exist or file is not executable."
      ;;
    binary|*)
      "${action_file}" "${extension_action}" "${extension_args[@]}"
      ;;
  esac
  # exit $result
  ) || result=$?
}

extension_license()
{
  local _extension="${1:-${extension}}"

  variable_is_nonempty _extension ||
    fail "Can not display extension license as an extension was not given."

  cat -v "${extensions_path}/${_extension}/LICENSE"
}

extensions_installed()
{
  extensions_in "${extensions_path}"
}

extensions_available()
{
  extensions_in "${extensions_src_path}"
}

extensions_in_development()
{
  true "${extensions_development_path:="${extensions_src_path}"}"

  list_extensions_in "${extensions_development_path}"
}

extensions_in()
{
  local _path="${1:-}"

  directory_exists "${_path}" || return 0

  _files=($(find "${_path}" -mindepth 2 -maxdepth 2 -name 'VERSION' -type f))

  extensions=()

  for _file in "${_files[@]}" ; do
    extension_source_path="${_file/%\/VERSION}"
    extension_name="${extension_source_path//*\/}"

    case ${extension_name} in
      (core|ext|mod|pkg|svc|[[=.=]]*)
        true # Ignore core extensions, they are updated with BDSM itself.
        ;;
      (*)
        extensions[${#extensions[@]}]="${extension_name//*\//}"
        ;;
    esac
  done

  extensions="${extensions[@]}"

  printf "${extensions}"
}

extension_actions()
{
  local _extension="${1:-}" _path="$extensions_path/${_extension}/bin"

  [[ -n "${_extension}" ]] ||
    fail "Cannot list actions for extension as no extension was given."

  directory_exists "${_path}" || return 0

  local _files=($(find "${_path}" -mindepth 1 -maxdepth 1 -type f))
  local _file _actions=()

  for _file in "${_files[@]}" ; do
    [[ -x "${_file}" ]] && _actions+=("${_file//*\/}")
  done

  _actions="${_actions[@]}" # Convert from array to string.

  printf "${_actions}"
}

extension_is_installed()
{
  local _name="${1:-}"

  [[ -n "${_name}" ]] ||
    fail "Can not check for an installed extension as no extension name was given."

  local _extensions=(extensions_in "${extensions_path}")

  case " ${_extensions[@]} " in
    (*[[:space:]]${_name}[[:space:]]*)
      return 0
      ;;
    (*)
      return 1
      ;;
  esac
}

