#!/usr/bin/env bash

service_start()
{
  if command_exists "${extension}_start" ; then
    "${extension}_start"
  else
    file_is_executable "${init_scripts_path}/${extension}" ||
      fail "${init_scripts_path}/${extension} is missing or not executable."

    "${init_scripts_path}/${extension}" start
  fi
}

service_stop()
{
  if command_exists "${extension}_stop" ; then
    "${extension}_stop"
  else
    file_is_executable "${init_scripts_path}/${extension}" ||
      fail "${init_scripts_path}/${extension} is missing or not executable."

    "${init_scripts_path}/${extension}" stop
  fi
}

service_restart()
{
  if command_exists "${extension}_restart" ; then
    "${extension}_restart"
  else
    file_is_executable "${init_scripts_path}/${extension}" ||
      fail "${init_scripts_path}/${extension} is missing or not executable."

    "${init_scripts_path}/${extension}" restart
  fi
}

service_status()
{
  if command_exists "${extension}_status" ; then
    "${extension}_status"
  else
    file_is_executable "${init_scripts_path}/${extension}" ||
      fail "${init_scripts_path}/${extension} is missing or not executable."

    "${init_scripts_path}/${extension}" status
  fi
}

service_logtail()
{
  if command_exists "${extension}_logtail" ; then
    "${extension}_logtail"
  else
    file_is_executable "${init_scripts_path}/${extension}" ||
      fail "${init_scripts_path}/${extension} is missing or not executable."

    "${init_scripts_path}/${extension}" logtail
  fi
}

service_info()
{
  if command_exists "${extension}_info" ; then
    "${extension}_info"
  else
    file_is_executable "${init_scripts_path}/${extension}" ||
      fail "${init_scripts_path}/${extension} is missing or not executable."

    "${init_scripts_path}/${extension}" info
  fi
}

service_configcheck()
{
  if command_exists "${extension}_configcheck" ; then
    "${extension}_configcheck"
  else
    file_is_executable "${init_scripts_path}/${extension}" ||
      fail "${init_scripts_path}/${extension} is missing or not executable."

    "${init_scripts_path}/${extension}" configcheck
  fi
}

service_usage() {
  # TODO: Update this for service specific items.
  printf "
  Usage:

  $0 [options]

  options:

  --prefix   - specify prefix path
  --src)     - specify source directory
  --data)    - specify data directory
  --user)    - specify user to install as
  --version) - specify version to install
  --licence) - view licence
  --help)    - view this usage information

  "
  return 0
}

service_cli()
{
  # TODO: Update this for service specific items.
  local _ignored_args=()

  number_of_args=${#extension_args[@]}

  for (( index=0 ; index < $number_of_args ; index++ ))
  do
    token="${extension_args[$index]}"

    case "$token" in
      --prefix)
        prefix_path="${extension_args[$((++index))]}"
        ;;
      --src)
        src_path="${extension_args[$((++index))]}"
        ;;
      --data)
        data_path="${extension_args[$((++index))]}"
        ;;
      --user)
        service_user="${extension_args[$((++index))]}"
        ;;
      --version)
        service_version="${extension_args[$((++index))]}"
        ;;
      --base_url)
        service_base_url="${extension_args[$((++index))]}"
        ;;
      --file)
        service_file="${extension_args[$((++index))]}"
        ;;
      --directory)
        service_directory="${extension_args[$((++index))]}"
        ;;
      --archive_format)
        archive_format="${extension_args[$((++index))]}"
        ;;
      --activate|activate)
        # TODO: Throw error if parameter is not specified.
        if (( ${#extension_args[@]} > 0 ))
        then
          service_activate "${extension}" "${extension_args[$((++index))]}"
        else
          error "Cannot activate ${extension}, no version was given."
        fi
        ;;
      --deactivate|deactivate)
        service_deactivate "${extension}"
        ;;
      --md5)
        service_md5="${extension_args[$((++index))]}"
        ;;
      --licence)
        display_extension_license
        exit 0
        ;;
      --help)
        service_usage
        exit 0
        ;;
      --trace)
        set -o xtrace
        ;;
      *)
        _ignored_args+=("${token}")
        ;;
    esac

    (( ${#_ignored_args[@]} > 0 )) && extension_args=( "${_ignored_args[@]}" )

  done
}

