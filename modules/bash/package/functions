#!/usr/bin/env bash

# Example Usage:
#
# package_definition \
#   name "bash"
#   version "4.2"
#   url "ftp.gnu.org/gnu/bash/"
#
package_definition()
{
  while [[ $# -gt 0 ]] ; do
    key="$1" ; shift
    if [[ -n "${1:-}" ]] ; then
      value="$1" ; shift
    else
      fail "${extension} : ${action} : package_definition() : Missing value for key '${key}'"
    fi

    case "$key" in
      name)
        package_name="${value}"
        ;;
      version)
        package_version="${value}"
        ;;
      file)
        package_file="${value}"
        ;;
      dir)
        package_dir="${value}"
        ;;
      url)
        package_url="${value}"
        ;;
      base_url)
        package_base_url="${value}"
        ;;
      patches_url)
        package_patches_url="${value}"
        ;;
      md5_url)
        package_md5_url="${value}"
        ;;
      bin_path)
        bin_path="${value}"
        ;;
      prefix_path)
        prefix_path="${value}"
        ;;
      source_path)
        source_path="${value}"
        ;;
      target_path)
        target_path="${value}"
        ;;
      archive_format)
        archive_format="${value}"
        ;;
      # TODO: Simplify into
      #(+([[[:alnum:]]|])_path|name|version|url|md5_url)
      #  eval "${key}=${value}"
      #  ;;
      *)
        fail "Unknown key for package_definition() : '${key}' (value: ${value})"
      ;;
    esac
  done
}

# TODO: much more error checking and conditional branching.
package_install()
{
  ensure_nonempty \
    "package_name" \
    "package_version" \
    "archive_format"

  true "${package_dir:="${package_name}-${package_version}"}"

  ensure_paths_exist "${source_path}"

  enter "${source_path}"

  if command_exists "${package_name}_download" ; then
    "${package_name}_download"
  else
    log "Downloading ${package_name} ${package_version}"
    package_fetch
  fi

  if command_exists "${package_name}_extract" ; then
    "${package_name}_extract"
  else
    log "Extracting ${package_name} ${package_version}"
    package_extract
  fi

  enter "${package_dir}"

  if command_exists "${package_name}_patch" ; then
    "${package_name}_patch"
  else
    log "Patching ${package_name} ${package_version}"
    package_patch
  fi

  if command_exists "${package_name}_configure" ; then
    "${package_name}_configure"
  else
    log "Configuring ${package_name} ${package_version}"
    package_configure
  fi

  if command_exists "${package_name}_build" ; then
    "${package_name}_build"
  else
    log "Building ${package_name} ${package_version}"
    package_build
  fi

  if command_exists "${package_name}_install" ; then
    "${package_name}_install"
  else
    log "Installing ${package_name} ${package_version}"
    if package_make_install ; then
      log "Installed ${package_name} ${package_version}."
    else
      fail "Failed to install ${package_name} ${package_version} to ${prefix_path}."
    fi
  fi

  package_activate_if_first
}

package_patch()
{
  true # noop for now
}

package_uninstall()
{
  ensure_nonempty \
    "package_name" \
    "package_version" \
    "archive_format"

  true "${package_dir:="${package_name}-${package_version}"}"

  if ! make_uninstall_package ; then
    log "Uninstalled ${package_name} from ${prefix_path}."
  else
    fail "Failed to uninstall ${package_name} from ${prefix_path}."
  fi
}

package_fetch_md5()
{
  ensure_nonempty package_name package_version archive_format

  local download_url

  true "${package_file:="${package_name}-${package_version}.${archive_format}"}"
  true "${packge_md5_url:="${package_base_url}/${package_file}.md5"}"

  package_md5=$(hash_file "$extension_config_path/md5" "${package_file}")

  if [[ -z "${package_md5}" && -n "${package_md5_url}" ]] ; then
    curl -L "${packge_md5_url}" -o "${package_file}.md5" ||
      fail "Fetching md5 from '${package_md5_url}' failed."

    package_md5=$(cat "${package_file}.md5")
  fi

}

file_matches_md5()
{
  local file="$1" md5="$2" file_md5

  [[ -s "${file}" ]] || return 1

  if [[ "$MACHTYPE" = *linux* ]] ; then
    command="md5sum"
  elif [[ "$MACHTYPE" = *darwin* ]] ; then
    command="/sbin/md5 -q"
  fi

  file_md5="$($command "$file")"

  [[ "${file_md5// *}" = "$md5" ]]
}

package_fetch()
{
  ensure_nonempty package_name package_version archive_format

  true "${package_file:="${package_name}-${package_version}.${archive_format}"}"
  true "${package_url:="${package_base_url}/${package_file}"}"

  package_fetch_md5

  if ! file_matches_md5 "${package_file}" "${package_md5}" ; then
    remove_files "${package_file}"

    if ! curl -L "${package_url}" -o "${package_file}" ; then
      fail "Downloading ${package_name} from '${package_url}' to '${package_file}' failed "
    fi
  fi
}

package_extract()
{
  true "${package_file:="${package_name}-${package_version}.${archive_format}"}"

  case "${archive_format}" in
    tar.gz|tgz) # gzip
      tar zxf "${package_file}"
      ;;
    xz) # LZMA
      tar Jxf "${package_file}"
      ;;
    tar.bz2) # bzip
      tar jxf "${package_file}"
      ;;
    zip)
      unzip "${package_file}" -C ${source_path}
      ;;
    *)
      fail "Unknown archive format for ${package_file}"
      ;;
  esac
}

package_configure()
{
  local command

  if [[ -n ${configure_command:-} ]] ; then
    command="${configure_command}"
  else
    command="./configure ${configure_flags[@]:-"--prefix=${install_path:-$prefix_path}"}"
    if [[ ! -x ./configure ]] ; then
      log "./configure not found, skipping configuration step." && return 0
    fi
  fi

  if ${command} > configure.log 2>&1; then
    log "Configuration of ${package_name} ${package_version} successful."
  else
    fail "Configuration of ${package_name} ${package_version} failed, seek help..."
  fi
}

package_build()
{ # TODO: make this robust, -j4 for example.
  local command

  if [[ -n ${make_command:-} ]] ; then
    command="${make_command}"
  else
    command="make ${make_flags[@]:-}"
  fi

  if ! ${command} > make.log 2>&1 ; then
    fail "Compilation if ${package_name} ${package_version} failed! "
  fi
}

package_make_install()
{ # TODO: make this robust
  local command

  if [[ -n ${make_command:-} ]] ; then
    command="${make_command}"
  else
    command="make ${make_install_flags[@]:-install}"
  fi

  if ${command} > make.install.log 2>&1  ; then
    log "Installation of ${package_name} ${package_version} was successful! "
  else
    fail "make install of ${package_name} ${package_version} failed! "
  fi
}


make_uninstall_package()
{ # TODO: make this robust
  local command

  if [[ -n ${make_command:-} ]] ; then
    command="${make_command}"
  else
    command="make ${make_install_flags[@]:-uninstall}"
  fi

  if ! ${command} > make.uninstall.log 2>&1 ; then
    fail "make uninstall ${package_name} ${package_version} failed! "
  fi
}

cleanup_install_files()
{
  log "#cleaning install files for ${package} ${package_version}...\n"

  enter "${src_path}"

  local files=($(
    find "$src_path/" -mindepth 1 -maxdepth 1 \
      -iname "${package}*${package_version}*"
  ))

  remove_files "${files[@]}"
}

package_activate()
{
  true ${package_name:="${1:-}"} ${package_version:="${2:-}"}

  package_deactivate "${package_name}"

  link "${install_base_path}/${package_name}/${package_version}" \
    to "${install_base_path}/${package_name}/active"

  package_ldconfig

  package_conf_d
}

package_deactivate()
{
  true ${package_name:="${1:-}"}

  ensure_nonempty package_name

  symlink_exists "${install_base_path}/${package_name}/active" &&
    remove_files "${install_base_path}/${package_name}/active"

  file_exists "/etc/ld.so.conf.d/${package_name}.conf" &&
    remove_files "/etc/ld.so.conf.d/${package_name}.conf"

  file_exists "/etc/conf.d/${package_name}.sh" &&
    remove_files "/etc/conf.d/${package_name}.sh"
}

package_activate_if_first()
{
  ensure_nonempty package_name package_version

  symlink_exists "${install_base_path}/${package_name}/active" ||
    package_activate "${package_name}" "${package_version}"
}

package_ldconfig()
{
  directory_exists "${install_base_path}/${package_name}/lib" ||
    return 0 # no lib/ directory for activated package, no need to update ldconfig

  ensure_set package_name

  # TODO: Figure out if solaris and freebsd have an analog to this?
  if running_as_root && os_is_linux ; then
    [[ -d "${install_base_path}/${package_name}/lib" ]] ; then
    ensure_paths_exist "/etc/ld.so.conf.d"
    printf "%s" "${install_base_path}/${package_name}/active/lib" \
      > "/etc/ld.so.conf.d/${package_name}.conf"
    chmod 0644 "/etc/ld.so.conf.d/${package_name}.conf"
    ldconfig
  fi
}

package_conf_d()
{
  directory_exists "${install_base_path}/${package_name}/active/bin" ||
    return 0 # No bin/ directory for activated package, no need to update PATH

  ensure_set package_name

  if running_as_root ; then
    ensure_paths_exist "/etc/conf.d"
    printf "%s" "PATH=\"\$PATH\":${install_base_path}/${package_name}/active/bin" \
      > "/etc/conf.d/${package_name}.sh"
    chmod 0644 "/etc/conf.d/${package_name}.sh"
  fi
}

