#!/usr/bin/env bash

# Example Usage:
#
# define_package \
#   name "bash"
#   version "4.2"
#   url "ftp.gnu.org/gnu/bash/"
#
define_package()
{
  while [[ $# -gt 0 ]] ; do
    key="$1" ; shift
    if [[ -n "${1:-}" ]] ; then
      value="$1" ; shift
    else
      fail "${extension} : ${action} : define_package() : Missing value for key '${key}'"
    fi

    case "$key" in
      name)
        package_name="${value}"
        ;;
      version)
        package_version="${value}"
        ;;
      file)
        package_file="${value}"
        ;;
      dir)
        package_dir="${value}"
        ;;
      url)
        package_url="${value}"
        ;;
      base_url)
        package_base_url="${value}"
        ;;
      patches_url)
        package_patches_url="${value}"
        ;;
      md5_url)
        package_md5_url="${value}"
        ;;
      bin_path)
        bin_path="${value}"
        ;;
      prefix_path)
        prefix_path="${value}"
        ;;
      source_path)
        source_path="${value}"
        ;;
      archive_format)
        archive_format="${value}"
        ;;
      # TODO: Simplify into
      #(+([[[:alnum:]]|])_path|name|version|url|md5_url)
      #  eval "${key}=${value}"
      #  ;;
      *)
        fail "Unknown key for define_package() : '${key}' (value: ${value})"
      ;;
    esac
  done
}

# TODO: much more error checking and conditional branching.
install_package()
{
  ensure_nonempty \
    "package_name" \
    "package_version" \
    "archive_format"

  true "${package_dir:="${package_name}-${package_version}"}"

  ensure_paths_exist "${source_path}"

  enter "${source_path}"

  fetch_package

  extract_package

  enter "${package_dir}"

  # If the extension has defined a patch_package function, call it.
  if command -v patch_package 2>/dev/null ; then
    patch_package
  fi

  configure_package

  make_package

  if make_install_package ; then
    log "Installed ${package_name} ${package_version}."
  else
    fail "Failed to install ${package_name} ${package_version} to ${prefix_path}."
  fi
}

uninstall_package()
{
  ensure_nonempty \
    "package_name" \
    "package_version" \
    "archive_format"

  true "${package_dir:="${package_name}-${package_version}"}"

  if ! make_uninstall_package ; then
    log "Uninstalled ${package_name} from ${prefix_path}."
  else
    fail "Failed to uninstall ${package_name} from ${prefix_path}."
  fi
}

fetch_package_md5()
{
  ensure_nonempty package_name package_version archive_format

  local download_url

  true "${package_file:="${package_name}-${package_version}.${archive_format}"}"
  true "${packge_md5_url:="${package_base_url}/${package_file}.md5"}"

  if ! curl -L "${packge_md5_url}" -o "${package_file}.md5" ; then
    package_md5=$(cat "${package_file}.md5")
  else
    fail "Fetching md5 from '${package_md5_url}' failed."
  fi
}

fetch_package()
{
  ensure_nonempty package_name package_version archive_format

  true "${package_file:="${package_name}-${package_version}.${archive_format}"}"
  true "${package_url:="${package_base_url}/${package_file}"}"

  if ! curl -L "${package_url}" -o "${package_file}" ; then
    fail "Downloading ${package_name} from '${package_url}' to '${package_file}' failed "
  fi
}

extract_package()
{
  true "${package_file:="${package_name}-${package_version}.${archive_format}"}"

  case "${archive_format}" in
    tar.gz|tgz) # gzip
      tar zxf "${package_file}"
      ;;
    xz) # LZMA
      tar Jxf "${package_file}"
      ;;
    tar.bz2) # bzip
      tar jxf "${package_file}"
      ;;
    zip)
      unzip "${package_file}" -C ${source_path}
      ;;
    *)
      fail "Unknown archive format for ${package_file}"
      ;;
  esac
}

configure_package()
{
  if ./configure --prefix="${prefix_path}" ${configure_flags[@]:-} ; then
    log "Configuration of ${package} successful."
  else
    fail "Configuration of ${package} failed, seek help..."
  fi
}

make_package()
{ # TODO: make this robust, -j4 for example.
  if ! make ; then
    fail "Compilation failed! "
  fi
}

make_install_package()
{ # TODO: make this robust
  if ! make install  ; then
    fail "make install failed! "
  fi
}


make_uninstall_package()
{ # TODO: make this robust
  if ! make uninstall ; then
    fail "make uninstall failed! "
  fi
}

cleanup_install_files()
{
  log "#cleaning install files for ${package} ${package_version}...\n"

  enter "${src_path}"

  local files=($(
    find "$src_path/" -mindepth 1 -maxdepth 1 \
      -iname "${package}*${package_version}*"
  ))

  remove_files "${files[@]}"
}

