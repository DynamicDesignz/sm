#!/usr/bin/env bash

#
# # Filesystem Module
#

#
# ## source\_files
#
# Safely source files only if they exists and are nonempty.
#
# ### Input Parameters
#
# One or more files.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Nonempty files given will be sourced into the calling environment.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no files are given to sources.
#
# ### Usage Examples
#
#     user$ source_files "$HOME/.dotfiles/scripts/functions"
#
# ### Code Walkthrough
source_files()
{
  # Declare the file and files variables, set the files variable to an array
  # containing all of the parameters passed in.
  local _file _files=("$@")

  # If the files array is nonempty
  if (( ${#_files[@]} > 0 ))
  then
    # then for each file in the files array
    for _file in "${_files[@]}"
    do
      # Expand the HOME path if the file contains '~'
      _file=${_file/\~\//$HOME\/} # Expand ~/ to full value of $HOME

      # If the file is nonempty
      if file_is_nonempty "${_file}"
      then
        # Then source the file
        if source "${_file}"
        then
          # Successfully sourced the file, go to the next element in the list.
          continue
        else
          # Failed sourcing the file.
          # This indicates either a programming or a system error.
          # Fail yielding a message with a backtrace which can be used
          # to debug the issue.
          fail "There was an error sourcing the file '${_file}'."
        fi
      fi
    done
  else
    # No files were passed given.
    # This indicates a programming error, fail giving developers an error
    # message with a backtrace which they can use to debug their code.
    fail "Cannot source files as no files were given."
  fi
}

#
# ## nonempty\_files
#
# Outputs a subset of the named files that are nonempty.
#
# ### Input Parameters
#
# One or more files.
#
# ### Stream Outputs
#
# Each nonempty filename parameter will be printed to STDOUT of the calling
# environment.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no file names are given as arguments.
#
# ### Usage Examples
#
#     user$ nonempty_files a $HOME/.bdmsrc c
#     /Users/wayneeseguin/.bdsmrc
#
nonempty_files()
{
  # Declare the file and files variables, set the files variable to an array
  # containing all of the parameters passed in.
  local _file _files=("$@")

  # If the files array is nonempty
  if (( ${#_files[@]} > 0 ))
  then
    # Expand the HOME path if the file contains '~'
    _file=${_file/\~\//$HOME\/} # Expand ~/ to full value of $HOME

    # then for each file in the files array
    for _file in "${_files[@]}"
    do
      # If the file is nonempty
      if file_is_nonempty "${_file}"
      then
        # print the file to STDOUT including a carriage return for explicit
        # list separation (in case any of the files contain a path).
        printf "${_file}\n"
      fi
    done
  else
    # No files were given.
    # This indicates a programming error, fail giving developers an error
    # message with a backtrace which they can use to debug their code.
    fail "Cannot return nonempty files as no files were given."
  fi
}

#
# ## ensure\_paths\_exist
#
# Iterates over the list of given paths, creates the directory if it
# does not exist.
#
# ### Input Parameters
#
# A list of paths to create if missing.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Paths that were given but do not exist will be created.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no paths were given to.
#
# ### Usage Examples
#
#     user$ ls -a
#     . ..
#     user$ ensure_paths_exist a b c
#     user$ ls -a
#     . .. a b c
#
ensure_paths_exist()
{
  # Declare the path and paths variables, set the files variable to an array
  # containing all of the parameters passed in.
  local _path _paths=("$@")

  # If the paths array is nonempty
  if (( ${#_paths[@]} > 0 ))
  then
    # then for each path in the paths array
    for _path in "${_paths[@]}"
    do
      # if the path exists as a directory
      if directory_exists "${_path}"
      then
        # The path already exists, move along to the next path.
        continue
      else
        # if the path already exists as a file
        if file_exists "${_path}"
        then
          # then issue a warning
          # Question: Should this be a fail scenario?
          warn "Could not ensure path '${_path}' exists"\
            " as a directory as it is a file."
        else
          # Create the full path in the filesystem, including intermediate
          # directories if they do not already exist.
          if mkdir -p "${_path}"
          then
            # the path was created successfully, continue on to processing the
            # next path
            continue
          else
            # Failed to create the path on the filesystem.
            # This indicates a system error, fail giving sysadmins an error
            # message with a backtrace which they can use to debug the issue.
            fail "Could not create the path '${_path}' "\
              "as the 'mkdir' command failed with error code '$?'"
          fi
        fi
      fi
    done
  else
    # No files were given.
    # This indicates a programming error, fail giving developers an error
    # message with a backtrace which they can use to debug their code.
    fail "Cannot ensure paths exist as no paths were given."
  fi
}

#
# ## remove\_files
#
# Removes the given files, if they exist.
#
# ### Input Parameters
#
# One or more file names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The named files will no longer exist on the system, if they existed to begin
# with.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no files were named.
# Fails if a named file is a directory.
# Fails if a named file exists but is not a file.
#
# ### Usage Examples
#
#     user$ touch a b c
#     user$ ls -a
#     . .. a b c
#     user$ remove_files a b c
#     user$ ls
#     . ..
#
remove_files()
{
  # Declare the file and files variables, set the files variable to an array
  # containing all of the parameters passed in.
  local _file _files=("$@")

  # If the files array is nonempty
  if (( ${#_files[@]} > 0 ))
  then
    # then for each file in the files array
    for _file in "${_files[@]}"
    do
      # if the file exists as a regular file or a symlink
      if [[ -f "${_file}" || -L "${_file}" ]]
      then
        # then remove it from the filesystem
        rm -f "${_file}"

      # otherwise if the file is a directory
      elif [[ -d "${_file}" ]]
      then
        # Failed to remove the file as the file is actually a directory.
        # This indicates a programming error, fail giving developers an error
        # message with a backtrace which they can use to debug the issue.
        fail "Cannot remove the file ${_file} as it is a directory."

      elif [[ -e "${_file}" ]]
      then
        # This indicates a system error, fail giving sysadmins an error
        # message with a backtrace which they can use to debug the issue.
        fail "Failed to remove the file from the filesystem "\
          "as the file exists as an unknown/unhandled filesystem entity type:"\
          "$(file "${_file}")."
      else
        # The file already does not exist so return true, 0, for success.
        return 0
      fi
    done
  else
    # No files were given to remove.
    # This indicates a programming error, fail giving developers an error
    # message with a backtrace which they can use to debug their code.
    fail "Cannot remove files as no files were given to remove."
  fi
}

#
# ## remove
#
# Removes the given filesystem entries, if they exist.
#
# ### Input Parameters
#
# One or more file, directory or symlink names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The named files will no longer exist on the system, if they existed to begin
# with.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no files were named.
#
# ### Usage Examples
#
#     user$ touch a
#     user$ mkdir b
#     user$ ln -s b c
#     user$ ls -a
#     . .. a b c
#     user$ remove a b c
#     user$ ls
#     . ..
#
remove()
{
  # Declare the entry and entries variables, set the entries variable to an
  # array containing all of the parameters passed in.
  local _entity _entities=("$@")

  # If the entities array is nonempty
  if (( ${#_entities[@]} > 0 ))
  then
    # for each entity in the entires array
    for _entity in "${_entities[@]}"
    do
      # if the entitiy exists on the filesystem
      if [[ -e "${_entity}" ]]
      then
        # then forcedly remove it from the filesystem
        if rm -rf "${_entity}"
        then
          # Successfully removed the filesytem entity, continue processing the
          # next entity in the list
          continue
        else
          # Failed to remove the entity from the filesystem.
          # This indicates a system error, fail giving sysadmins an error
          # message with a backtrace which they can use to debug the issue.
          fail "Could not remove the entity '${_entity}'"\
            "as the 'rm' command failed with error code '$?'"
        fi
      else
        # The entity already does not exist on the filesystem, continue
        # processing the entities
        continue
      fi
    done
  else
    # No files were given.
    # This indicates a programming error, fail giving developers an error
    # message with a backtrace which they can use to debug their code.
    fail "Cannot remove entities as no filesystem entities were given "\
      "as parameters."
  fi
}

#
# ## remove\_paths
#
# Function Description
#
# ### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ### Return Codes
#
# 0 if ...
# 1 if ...
#
# ### Failure Scenarios
#
# Fails if ...
#
# ### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
remove_paths()
{
  # Declare the path and paths variables, set the files variable to an array
  # containing all of the parameters passed in.
  local _path _paths=("$@")

  # If the paths array is nonempty
  if (( ${#_paths[@]} > 0 ))
  then
    # then for each path in the paths array
    for _path in "${_paths[@]}"
    do
      # If the path is a symlink
      if [[ -L "${_path}" ]]
      then
        # remove it from the filesystem
        if rm -f "${_path}"
        then
          # Successfully removed the filesytem path, continue processing the
          # next path in the list
          continue
        else
          # Failed to remove the entity from the filesystem.
          # This indicates a system error, fail giving sysadmins an error
          # message with a backtrace which they can use to debug the issue.
          fail "Could not remove the entity '${_entity}'"\
            "as the 'rm' command failed with error code '$?'"
        fi
      # if the path is a directory
      elif [[ -d "${_path}" ]]
      then
        # remove it, recursively, from the filesystem
        if rm -rf "${_path}"
        then
          # Successfully removed the filesytem path, continue processing the
          # next path in the list
          continue
        else
          # Failed to remove the entity from the filesystem.
          # This indicates a system error, fail giving sysadmins an error
          # message with a backtrace which they can use to debug the issue.
          fail "Could not remove the entity '${_entity}'"\
            "as the 'rm' command failed with error code '$?'"
        fi
      # If the path is not a symlink or a directory and it still exists on the
      # filesystem
      elif [[ -e "${_path}" ]]
      then
        # Then path is an unhandled filesystem type and we have failed to
        # remove it.
        # This likely indicates a system error, fail giving sysadmins an error
        # message with a backtrace which they can use to debug the issue.
        fail "Cannot remove the path '${_path}' as it is a file."

      else
        # The filesystem path already does not exist, continue processing the
        # next path in the list
        continue
      fi
    done
  else
    # No paths were given.
    # This indicates a programming error, fail giving developers an error
    # message with a backtrace which they can use to debug their code.
    fail "Cannot remove paths as no paths were given."
  fi
}

#
# ## ensure\_files\_exist
#
# Iterates over the list of given files, creates the directory if it
# does not exist.
#
# ### Input Parameters
#
# A list of files to create if missing.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# files that were given but do not exist will be created.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no files were given to.
#
# ### Usage Examples
#
#     user$ ls -a
#     . ..
#     user$ ensure_files_exist a b c
#     user$ ls -a
#     . .. a b c
#
ensure_files_exist()
{
  # Declare the file, files and path variables, set the files variable to an
  # array containing all of the parameters passed in.
  local _file _files=("$@") _path

  # If the files array is nonempty
  if (( ${#_files[@]} > 0 ))
  then
    # then for each file in the files array
    for _file in "${_files[@]}"
    do
      if file_exists "${_file}"
      then
        # The file exists, continue on to processing the next file
        continue
      else
        # Strip the filename off of the end yielding the path
        _path="${_file%\/*}"

        # Ensure that the path exists
        ensure_paths_exist "${_path}"

        # Now touch the file to create it.
        if touch "${_file}"
        then
        # The file exists, continue on to processing the next file
          continue
        else
          # Failed touching the file.
          # This indicates either a programming or a system error.
          # Fail yielding a message with a backtrace which can be used
          # to debug the issue.
          fail "There was an error creating the file '${_file}' on the"\
            "filesystem, the touch command returned error code '$?'"
        fi
      fi
    done
  else
    # No files were passed given.
    # This indicates a programming error, fail giving developers an error
    # message with a backtrace which they can use to debug their code.
    fail "Cannot ensure files exist as no files were given."
  fi
}

#
# ## ensure\_files\_are\_executable
#
# Sets the executable bits on a file if it is not executable.
#
# ### Input Parameters
#
# One or more file name/paths
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Files that were given and not executable will have their execute bits set.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no files were given as parameters.
# Fails if one of the files given was a directory.
# Fails if one of the files given does not exist.
# Fails if one of the files paths does not exist.
#
# ### Usage Examples
#
#     user$ ensure_files_are_executable /etc/rc.d/postgresql
#
# TODO: change this to be a  fail function if one is not
#       make this into make_files_executable or some such
ensure_files_are_executable()
{
  # Declare the file, files and path variables, set the files variable to an
  # array containing all of the parameters passed in.
  local _file _files=("$@") _path

  # If the files array is nonempty
  if (( ${#_files[@]} > 0 ))
  then
    # then for each file in the files array
    for _file in "${_files[@]}"
    do
      # if the file exists on the filesystem but is a directory
      if directory_exists "${_file}"
      then
        # This indicates either a programming or a system error.
        # Fail yielding a message with a backtrace which can be used
        # to debug the issue.
        fail "Cannot make the file '${_file}' executable "\
          "as it is unexpectedly a directory."
      # Otherwise if
      elif ! file_exists "${_file}"
      then
        fail "Cannot make the file '${_file}' executable as the file does not exist."
      else
        _path="${_file%\/*}"

        if ! [[ -n "${_path}" && ! -d "${_file}" ]]
        then
          fail "Cannot make the file '${_file} executable as '${_path}' does not even exist."
        fi
        chmod +x "${_file}"
      fi
    done
  else
    # No files were passed given.
    # This indicates a programming error, fail giving developers an error
    # message with a backtrace which they can use to debug their code.
    fail "Cannot ensure files are executable as no files were given."
  fi
}

#
# ## link
#
# Create a symlink from source to target.
#
# ### Input Parameters
#
# First parameter is the source
# Second parameter is the target
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Symlink is created if no failure conditions are triggered.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if target exists and is a file.
# Fails if target exists and is a directory.
#
# ### Usage Examples
#
# The following usages are equivalent
#
#     user$ link from /home/user/.vim/vimrc to /home/user/.vimrc
#     user$ link /home/user/.vim/vimrc to /home/user/.vimrc
#     user$ link /home/user/.vim/vimrc /home/user/.vimrc
#
link()
{
  local token _source _target _force_flag=0

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      --force)
        _force_flag=1
        ;;
      *)
        if [[ -z "${_source}" ]]
        then
          _source="$token"

        elif [[ -z "${_target}" ]]
        then
          _target="$token"
        fi
        ;;
    esac
  done

  if (( _force_flag == 1 ))
  then
    remove "${_target}"
  fi

  # TODO: What should we do if files already exist?
  if [[ -f "${_target}" ]]
  then
    error "Cannot link ${_source} to ${_target} exists and is a file!"

  elif [[ -d "${_target}" ]]
  then
    error "Cannot link ${_source} to ${_target} exists and is a directory"

  else
    ensure_paths_exist "${_target%\/*}"
    ln -fs "${_source}" "${_target}"
  fi
}

#
# ## move\_directory
#
# Moves a directory from one location to another.
# (This is also used to rename a directory.)
#
# ### Input Parameters
#
# The first parameter is the source directory name
# The second parameter is the target directory name
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, a directory is renamed (moved).
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if the source directory is not specified.
# Fails if the target directory is not specified.
#
# ### Usage Examples
#
#     user$ move_directory "freetds-0.91rc"* to "freetds-0.91"
#
move_directory()
{
  local _source _target _mode _owner

  while (( $# > 0 )) ; do
    token="$1" ; shift
    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;

      from)
        _source="${1}"
        shift
        ;;

      mode)
         _mode="${1}"
         shift
        ;;

      owner)
         _owner="${1}"
         shift
        ;;

      *)
        if [[ -z "${_source}" ]]
        then
          _source="$token"

        elif [[ -z "${_target}" ]]
        then
          _target="$token"
          # When we have a target we are done.
          break
        fi
        ;;
    esac
  done

  if [[ -z "${_source}" ]]
  then
    fail "Cannot move file as the source and target must be specified. "
  fi

  if [[ -z "${_target}" ]]
  then
    fail "Cannot move file as the source and target must be specified. "
  fi

  mv "${_source}" "${_target}"

  if [[ -n "${_mode:-}" ]]
  then
    chmod -R "${_mode}" "${_target}"
  fi

  if [[ -n "${_owner:-}" ]]
  then
    chown -R "${_owner}" "${_target}"
  fi
}

#
# ## move\_file
#
# Moves a file from one location to another.
# (This is also used to rename a file.)
#
# ### Input Parameters
#
# The first parameter is the source file name
# The second parameter is the target file name
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, a file is renamed (moved).
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if the source file is not specified.
# Fails if the target file is not specified.
#
# ### Usage Examples
#
#     user$ move_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
#
# ### Code Walkthrough
move_file()
{
  # Declare the source, target, mode, owner and token local variables.
  local _source _target _mode _owner token

  # While the parameter list is not empty
  while (( $# > 0 ))
  do
    # Set the token variable to the first parameter
    token="$1"
    # and remove the token parameter from the list of parameters
    shift
    # Now we examine the token and switch based on what is found.
    case "${token}" in
      # the token is 'to',
      to)
        _target="${1}"
        # and remove the target paramter from the parameters.
        shift
        ;;
      # the token is 'from',
      from)
        _source="${1}"
        # and remove the from paramter from the parameters.
        shift
        ;;
      # the token is 'mode',
      mode)
        # Set the mode variable to the first parameter
        _mode="${1}"
        # and remove the mode paramter from the parameters.
        shift
        ;;
      # the token is 'owner',
      owner)
        # Set the owner variable to the first parameter
        _owner="${1}"
        # and remove the owner paramter from the parameters.
        shift
        ;;

      # If we do not know
      *)
        # If the source variable is empty
        if [[ -z "${_source}" ]]
        then
          # then assign the unknown token to the source variable
          _source="$token"

        # otherwise if the target variable is empty
        elif [[ -z "${_target}" ]]
        then
          # then assign the Unknown token to the target variable.
          _target="$token"
        else
          # At this point we have both a source and a target, so we do not know
          # what to do with further unknown parameters. This indicates a
          # programming error, fail giving developers an error message and
          # a backtrace which they can use to debug their code.
          fail "The source '${_source}' and target '${_target}' have been set"\n
            "and the current token token is unknown'${token}'."
        fi
        ;;
    esac
  done

  # If the source variable is not empty
  if variable_is_nonempty _source
  then
    # and if the target variable is not empty
    if variable_is_nonempty _target
    then
      # then move the source to the target
      if mv "${_source}" "${_target}"
      then
        # The move was successful, now we process mode and owner if specified.

        # If the mode variable is set, change the target's filesystem mode
        if variable_is_nonempty _mode
        then
          # If the file mode change is not successful
          if ! chmod "${_mode}" "${_target}"
          then
            # Then print out a warning to the user and continue processing
            # this is typically a non-fatal error which can be rectified
            # afterwards.
            warn "There was an error ($?) changing the "\
              "target's '${_target}' mode to '${_mode}'"
          fi
        fi

        # If the owner variable is set, change the target's owner
        if variable_is_nonempty _owner
        then
          # If the ownership change is not successful
          if ! chown "${_owner}" "${_target}"
          then
            # Then print out a warning to the user and continue processing
            # this is typically a non-fatal error which can be rectified
            # afterwards.
            warn "There was an error ($?) changing the "\
              "target's '${_target}' owner to '${_owner}'"
          fi
        fi
      else
        # There was an error moving the file, inform the user with a failure
        # message and provide a backtrace as this could very well indicate a
        # larger issue overall and debugging will be necessary.
        fail "There was an error ($?) moving the source '${_source}'" \
          "to the target '${_target}'"
      fi
    else
      # The target was not specified, this is a programming error
      # send a fail message which will send a backtrace allowing the developer
      # to quickly debug and pass in the proper parameters.
      fail "Cannot move file as both the source and target must be specified."
    fi
  else
      # The source was not specified, this is a programming error
      # send a fail message which will send a backtrace allowing the developer
      # to quickly debug and pass in the proper parameters.
      fail "Cannot move file as both the source and target must be specified."
  fi
}

#
# ## copy\_file
#
# Copys a file from one location to another.
# (This is also used to rename a file.)
#
# ### Input Parameters
#
# The first parameter is the source file name
# The second parameter is the target file name
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, a file is renamed (copyd).
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if the source file is not specified.
# Fails if the target file is not specified.
#
# ### Usage Examples
#
#     user$ copy_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
#
copy_file()
{
  local _source _target

  while (( $# > 0 )) ; do
    token="$1"
    shift
    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      mode)
         _mode="${1}"
         shift
        ;;
      owner)
         _owner="${1}"
         shift
        ;;
      *)
        if [[ -z "${_source:-}" ]]
        then
          _source="$token"
          shift

        elif [[ -z "${_target:-}" ]]
        then
          _target="$token"
          break
        fi
        ;;
    esac
  done

  cp "${_source}" "${_target}"

  if [[ -n "${_mode:-}" ]]
  then
    chmod "${_mode}" "${_target}"
  fi

  if [[ -n "${_owner:-}" ]]
  then
    chown "${_owner}" "${_target}"
  fi

}

#
# ## copy\_files\_to
#
# depreciated, please use copy_files with the 'to' specifier instead
#
copy_files_to()
{
  local _path="${1:-}" _file

  if [[ -z "${_path}" ]]
  then
    fail "Path was not given as the first parameter."
  else
    shift
  fi

  local _files=("$@")

  if (( ${#_files[@]} == 0 ))
  then
    fail "No files were given in order to copy them into ${_path}."
  fi

  log "copy_files_to is depreciated, please use copy_files with the 'to' specifier instead"

  ensure_paths_exist "${_path}"

  for _file in "${_files[@]}"
  do
    if file_is_missing "${_file}"
    then
      error "Cannot copy file ${_file} to ${_path} as the file does not exist."
    else
      cp "${_file}" "${_path}/${_file}"
    fi

  done
}

#
# ## copy\_files
#
# Copys a given list of files into the named path.
#
# ### Input Parameters
#
# The first parameter is the path to copy the files into.
# Remaining parameters are the file name/path list.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, all named files are copied into the target path.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no files are given.
#
# ### Usage Examples
#
#     user$ copy_files "$HOME/.bashrc" "$HOME/.bash_profile" \
#             to "$HOME/backup"
#
copy_files()
{
  local _source _target _file _force_flag=0 _files=()

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        _files+=( "${token}" )
        ;;
    esac
  done

  if [[ -z "${_target}" ]]
  then
    fail "Cannot copy files as no target path was given (eg. copy_files ... to {path})."
  fi

  if (( ${#_files[@]} == 0 ))
  then
    fail "Cannot copy files as no files were given to copy."
  fi

  ensure_paths_exist "${_target}"

  for _file in "${_files[@]}"
  do
    if file_is_missing "${_file}"
    then
      error "Cannot copy file ${_file} to ${_target} as the file does not exist."
    else
      if (( _force_flag == 1 ))
      then
        cp -f "${_file}" "${_target}/${_file//*\/}"
      else
        cp "${_file}" "${_target}/${_file//*\/}"
      fi
    fi
  done
}

#
# ## copy\_directories\_to
#
# Copys a given list of directories into the named path.
#
# ### Input Parameters
#
# The first parameter is the path to copy the directorys into.
# Remaining parameters are the directory name/path list.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, all named directories are copied into the target path.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no directories are given.
#
# ### Usage Examples
#
#     user$ copy_directories_to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
#
copy_directories_to()
{
  local _path="${1:-}" _directory

  if [[ -z "${_path}" ]]
  then
    fail "Path was not given as the first parameter."
  else
    shift
  fi

  local _directories=("$@")

  if (( ${#_directories[@]} == 0 ))
  then
    fail "No directories were given in order to copy them into ${_path}."
  fi

  ensure_paths_exist "${_path}"

  for _directory in "${_directories[@]}"
  do
    if directory_exists "${_directory}"
    then
      cp -Rf "${_directory}" "${_path}/"
    else
      error "Cannot copy directory ${_directory} to ${_path} as the directory '${_directory}' does not exist (in '$PWD')."
    fi
  done
}

#
# ## copy\_directories to
#
# Copys a given list of directories into the named path.
#
# ### Input Parameters
#
# The first parameter is the path to copy the directorys into.
# Remaining parameters are the directory name/path list.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, all named directories are copied into the target path.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no directories are given.
#
# ### Usage Examples
#
#     user$ copy_directories to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
#
copy_directories()
{
  local _source _target _directory _force_flag=0 _directories=()

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        _directories+=( "${token}" )
        ;;
    esac
  done

  if [[ -z "${_target}" ]]
  then
    fail "Cannot copy directories as no target path was given (eg. copy_directories ... to {path})."
  fi

  if (( ${#_directories[@]} == 0 ))
  then
    fail "Cannot copy directories as no directories were given to copy."
  fi

  ensure_paths_exist "${_target}"

  for _directory in "${_directories[@]}"
  do
    if directory_exists "${_directory}"
    then
      cp -Rf "${_directory}" "${_target}/"
    else
      error "Cannot copy directory ${_directory} to ${_target} as the directory '${_directory}' does not exist (in '$PWD')."
    fi
  done
}


#
# ## copy\_directory
#
# Copys a directory from one location to another.
# (This is also used to rename a directory.)
#
# ### Input Parameters
#
# The first parameter is the source directory name
# The second parameter is the target directory name
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, a directory is renamed (copyd).
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if the source directory is not specified.
# Fails if the target directory is not specified.
#
# ### Usage Examples
#
#     user$ copy_directory "freetds-0.91rc"* to "freetds-0.91"
#
copy_directory()
{
  local _source _target

  while (( $# > 0 ))
  do
    token="$1"
    shift
    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      *)
        if [[ -z "${_source}" ]]
        then
          _source="$token"
          shift

        elif [[ -z "${_target}" ]]
        then
          _target="$token"
          break
        fi
        ;;
    esac
  done

  cp -Rf "${_source}" "${_target}"
}

#
# ## move\_files\_to
#
# Moves a given list of files into the named path.
#
# ### Input Parameters
#
# The first parameter is the path to move the files into.
# Remaining parameters are the file name/path list.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, all named files are copied into the target path.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no files are given.
#
# ### Usage Examples
#
#     user$ move_files_to "$HOME/backup" "$HOME/.bashrc" "$HOME/.bash_profile"
#
move_files_to()
{
  local _path="${1:-}" _file

  if [[ -n "${_path}" ]]
  then
    fail "Path was not given as the first parameter."
  else
    shift
  fi

  log "DEPRECIATED, use 'move_files ... to _path' instead"

  local _files=("$@")

  if (( ${#_files[@]} > 0 ))
  then
    fail "No files given in order to chmod ${_permissions} them."
  fi

  ensure_paths_exist "${_path}"

  for _file in "${_files[@]}"
  do
    if file_exists "${_file}"
    then
      mv "${_file}" "${_path}/${_file}"
    else
      error "Cannot move file ${_file} to ${_path} as the file does not exist."
    fi
  done
}

#
# ## move\_files
#
# Moves a given list of files into the named path.
#
# ### Input Parameters
#
# Parameters are file name/path for one or more files
# Target directory is specified as 'to {{path}}'
# Optional source directory is specified as 'from {{path}}'
# Optional force flag '--force' may be specified
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, all named files are copied into the target path.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no files are given.
#
# ### Usage Examples
#
#     user$
#
# Alternatively,
#
#     user$ move_files ".bashrc" ".bash_profile" from "$HOME" to "$HOME/backup"
#
move_files()
{
  local _source _target _file _force_flag=0 _files=()

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        _files+=( "${token}" )
        ;;
    esac
  done

  if [[ -n "${_target}" ]]
  then
    if (( ${#_files[@]} > 0 ))
    then
      if [[ -d "${_target}" ]]
      then
        for _file in "${_files[@]}"
        do
          if [[ -n "${_source}" ]]
          then
            _file="${_source}/${_file}"
          fi

          if file_exists "${_file}"
          then
            if (( _force_flag == 1 ))
            then
              mv -f "${_file}" "${_target}/${_file//*\/}"
            else
              mv "${_file}" "${_target}/${_file//*\/}"
            fi
          else
            error "Cannot move file ${_file} to ${_path} as the file does not exist."
          fi
        done
      else
        error "Cannot move files to '${_target}' as the directory does not exist"
      fi
    else
      fail "Cannot move files as no files were given to move."
    fi
  else
    fail "Cannot move files as no target path was given (eg. move_files ... to {path})."
  fi
}

#
# ## chown\_files
#
# Change ownership of a list of files.
#
# ### Input Parameters
#
# First parameter is the new owner[:group] of the files.
# Remaining parameters are the file names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of files was given.
#
# ### Usage Examples
#
#     user$ chown_files $USER "$HOME/.bashrc" "$HOME/.bash_profile"
#
chown_files()
{
  local _identity="${1:-}" _file

  if [[ -z "${_identity}" ]]
  then
    fail "user[:group] not given as the first parameter."
  else
    shift
  fi

  local _files=("$@")

  if (( ${#_files[@]} == 0 ))
  then
    fail "No paths given to chmod ${_permissions}."
  fi

  for _file in "${_files[@]}"
  do
    if file_exists "${_file}"
    then
      chown -R ${_identity} "${_file}"
    else
      error "Cannot chown file ${_file} to ${_identity} as the file does not exist."
    fi
  done
}

#
# ## chown\_paths
#
# Change ownership of a list of paths.
#
# ### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ### Usage Examples
#
#     user$ chown_paths $USER "$HOME" "/usr/local"
#
chown_paths()
{
  local _identity="${1:-}" _path

  if [[ -z "${_identity}" ]]
  then
    fail "user[:group] not given as the first parameter."
  else
    shift
  fi

  local _paths=("$@")

  if (( ${#_paths[@]} == 0 ))
  then
    fail "No paths given to chmod ${_permissions}."
  fi

  for _path in "${_paths[@]}"
  do
    if directory_exists "${_path}"
    then
      chown ${_identity} "${_path}"
    else
      error "Cannot chown path ${_path} to ${_identity} as the directory does not exist."
    fi
  done
}

#
# ## chown\_paths\_recursively
#
# Change ownership of a list of paths, recursively.
#
# ### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ### Usage Examples
#
#     user$ chown_paths_recursively $USER "$HOME" "/usr/local"
#
chown_paths_recursively()
{
  local _identity="${1:-}" _path

  if [[ -z "${_identity}" ]]
  then
    fail "user[:group] not given as the first parameter!!"
  else
    shift
  fi

  local _paths=("$@")

  if (( ${#_paths[@]} == 0 ))
  then
    fail "No paths given to chmod ${_permissions}."
  fi

  for _path in "${_paths[@]}"
  do
    if directory_exists "${_path}"
    then
      chown -R ${_identity} "${_path}"
    else
      error "Cannot recursively chown ${_path} to ${_identity} as the directory does not exist."
    fi
  done
}

#
# ## chmod\_files
#
# Change ownership of a list of files.
#
# ### Input Parameters
#
# First parameter is the new owner[:group] of the files.
# Remaining parameters are the file names/files.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of files was given.
#
# ### Usage Examples
#
#     user$ chmod_files $USER "$HOME" "/usr/local"
#
chmod_files()
{
  local _permissions="${1:-}" _file _message

  if [[ -n "${_permissions}" ]]
  then
    shift
    local _files=("$@")

    if (( ${#_files[@]} > 0 ))
    then
      for _file in "${_files[@]}"
      do
        if file_exists "${_file}"
        then
          chmod ${_permissions} "${_file}"
        else
          _message=(
          "Cannot chmod file ${_file} to ${_permissions}"
          " as the file does not exist."
          )
          error "${_message[*]}"
        fi
      done
    else
      fail "No files given to chmod ${_permissions}."
    fi
  else
    fail "Permissions not given as the first parameter!!"
  fi
}

#
# ## chmod\_paths
#
# Change ownership of a list of paths.
#
# ### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ### Usage Examples
#
#     user$ chmod_paths $USER "$HOME" "/usr/local"
#
chmod_paths()
{
  local _permissions="$1" _path _message

  if [[ -n "${_permissions}" ]]
  then
    shift
    local _paths=("$@")
    if (( ${#_paths[@]} > 0 ))
    then
      for _path in "${_paths[@]}"
      do
        if directory_exists "${_path}"
        then
          chmod ${_permissions} "${_path}"
        else
          _message=(
          "Cannot chmod directory ${_path} to ${_permissions}"
          " as the directory does not exist.")
          error "${_message[*]}"
        fi
      done
    else
      _message=(
      "Cannot chmod_paths as no paths were given in "
      "order to change permissions to ${_permissions}."
      )
      fail "${_message[*]}"
    fi
  else
    _message=(
    "Cannot chmod_paths as the permissions were "
    "not given as the first parameter!!"
    )
    fail "${_message[*]}"
  fi
}

#
# ## chmod\_paths\_recursively
#
# Change ownership of a list of paths, recursively.
#
# ### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ### Usage Examples
#
#     user$ chmod_paths_recursively $USER "$HOME" "/usr/local"
#
chmod_paths_recursively()
{
  local _permissions="${1:-}" _path _message

  if [[ -n "${_permissions}" ]]
  then
    shift
    local _paths=("$@")

    if (( ${#_paths[@]} > 0 ))
    then
      for _path in "${_paths[@]}"
      do
        if directory_exists "${_path}"
        then
          chmod -R ${_permissions} "${_path}"
        else
          _message=(
          "Cannot chmod directory ${_path} to ${_permissions} "
          "as the directory does not exist."
          )
          error "${_message[*]}"
        fi
      done
    else
      fail "No paths given to chmod ${_permissions}."
    fi
  else
    fail "Permissions not given as the first parameter!!"
  fi
}

#
# ## enter
#
# Changes the current working directory ($PWD) to the given directory with
# sanity checks.
#
# ### Input Parameters
#
# First parameter is the directory to change into.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current working directory (PWD) will become the given directory if
# successful.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no directory was given.
# Fails if the given directory does not exist.
#
# ### Usage Examples
#
#     user$ enter "/usr/local/src"
#
enter()
{
  local _path="$1"

  if [[ -n "${_path}" ]]
  then
    if [[ -d "${_path}" ]]
    then
      if ! builtin cd "${_path}"
      then
        error "There was an error ($?) while entering the directory '${_path}'."
      fi
    else
      error "Cannot enter the directory '${_path}' as it does not exist."
    fi
  else
    fail "Cannot enter a directory as no directory was given."
  fi
}

#
# ## hash\_file
#
# Set and get key/value pairs from a given has file.
#
# ### Input Parameters
#
# The first parameter is the file name/path for the hash file.
# The second parameter is the key name.
# The third (optional) parameter is the value to assign to the given key.
#
# ### Stream Outputs
#
# The value of the key retrieved is printed if no value parameter was given.
#
# ### Environmental effects
#
# If a value parameter was given the key=value pair is written to the named
# hash file.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no file name/path was provided.
# Fails if no key name was given.
# Fails if the file path does not exist.
#
# ### Usage Examples
#
#     user$ hash_file /usr/local/bdsm/extensions/core/config/defaults website_url
#     https://bdsm.beginrescueend.com/
#
hash_file()
{
  local _file="${1:-}" _message

  if [[ -z "${_file}" ]]
  then
    fail "File path/name not given.\n => Usage: $0 <filename> <key> [value]"
  else
    shift
  fi

  local _key="${1:-}"

  if [[ -z "${_key}" ]]
  then
    fail "Key not given.\n => Usage: $0 <filename> <key> [value]"
  else
    shift
  fi

  local _path=$(dirname "${_file}")
  if [[ -d "${_path}" ]]
  then
    ensure_files_exist "$_file"
  else
    _message=(
    "Cannot access the database file '${_file}' "
    "as the directory '${_file%\/*}' does not exist."
    )
    error "{$_message[*]}"
  fi

  value="$*"
  case "$value" in
    unset|delete)
      sed -i.tmp "s#^${_key}=.*\$##" "${_file}"
      ;;
    *)
      if [[ -z "${value}" ]]
      then # get
        awk -F= '/^'"${_key}"'=/{print $2}' "$_file"
      else # set
        if ! awk -F= "/^'"${_key}"'=/{print $2}" "${_file}" >/dev/null 2>&1
        then
          echo "${_key}=$value" >> "${_file}"
        else # overwrite
          sed -i.tmp "s#^${_key}=.*\$#${_key}=$value#" "${_file}"
        fi
      fi
      ;;
  esac
}

#
# ## file\_is\_executable
#
# Check if a file name/path is executable.
#
# ### Input Parameters
#
# First parameter is a file name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named file is executable.
# 1 if the named file is not executable or does not exist.
#
# ### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ### Usage Examples
#
#     user$ file_is_executable /bin/bash
#     user$ echo $?
#     0
#
#     user$ file_is_executable /bin/asdfasdf
#     user$ echo $?
#     1
#
file_is_executable()
{
  local _file="${1:-}"

  if [[ -n "${_file}" ]]
  then
    if [[ -x "${_file}" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot check if a file is executable as no file path/name was given"
  fi
}

#
# ## file\_exists
#
# Check if a file name/path exists.
#
# ### Input Parameters
#
# First parameter is a file name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named file exists.
# 1 if the named file does not exist or does not exist.
#
# ### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ### Usage Examples
#
#     user$ file_exists /bin/bash
#     user$ echo $?
#     0
#
#     user$ file_exists /bin/asdfasdf
#     user$ echo $?
#     1
#
file_exists()
{
  local _file="${1:-}"
  if [[ -n "${_file}" ]]
  then
    if [[ -f "${_file}" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot check to see if a file exists as no file name/path was given"
  fi
}

#
# ## file\_does\_not\_exist
#
# Check if a file name/path exists.
#
# ### Input Parameters
#
# First parameter is a file name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named file does not exist.
# 1 if the named file exists.
#
# ### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ### Usage Examples
#
#     user$ file_does_not_exist /bin/bash
#     user$ echo $?
#     1
#
#     user$ file_does_not_exist /bin/asdfasdf
#     user$ echo $?
#     0
#
file_does_not_exist()
{
  local _file="${1:-}"
  if [[ -n "${_file}" ]]
  then
    if [[ -f "${_file}" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot check to see if a file exists as no file name/path was given"
  fi
}

#
# ## file\_is\_nonempty
#
# Check if a file name/path is nonempty.
#
# ### Input Parameters
#
# First parameter is a file name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named file is nonempty.
# 1 if the named file is empty or does not exist.
#
# ### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ### Usage Examples
#
#     user$ file_is_nonempty /bin/bash
#     user$ echo $?
#     0
#
#     user$ file_is_nonempty /bin/asdfasdf
#     user$ echo $?
#     1
#
file_is_nonempty()
{
  local _file="${1:-}"

  if [[ -n "${_file}" ]]
  then
    if [[ -d "${_file}" ]]
    then
      error "When checking whether the file '${_file}' is nonempty, a directory was found in its place."
    else
      if [[ -s "${_file}" ]]
      then
        return 0
      else
        return 1
      fi
    fi
  else
    fail "Cannot check if file is nonempty as no file path/name was given"
  fi
}

#
# ## file\_is\_empty
#
# Check if a file name/path is empty.
#
# ### Input Parameters
#
# First parameter is a file name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named file is empty.
# 1 if the named file is not empty or does not exist.
#
# ### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ### Usage Examples
#
#     user$ file_is_empty /bin/bash
#     user$ echo $?
#     1
#
#     user$ file_is_empty /bin/asdfasdf
#     user$ echo $?
#     0
#
file_is_empty()
{
  local _file="${1:-}"

  if [[ -n "${_file}" ]]
  then
    if [[ -f "${_file}" && ! -s "${_file}" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot check if a file is empty as no file path/name was given"
  fi
}

#
# ## file\_is\_missing
#
# Check if a file name/path is missing.
#
# ### Input Parameters
#
# First parameter is a file name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named file is missing.
# 1 if the named file is not missing or does not exist.
#
# ### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ### Usage Examples
#
#     user$ file_is_missing /bin/bash
#     user$ echo $?
#     1
#
#     user$ file_is_missing /bin/asdfasdf
#     user$ echo $?
#     0
#
file_is_missing()
{
  local _file="${1:-}"

  if [[ -n "${_file}" ]]
  then
    if [[ ! -f "${_file}" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot check if file is missing as no file path/name was given"
  fi
}

#
# ## file\_is\_empty\_or\_missing()
#
# Check if a file name/path is empty or missing.
#
# ### Input Parameters
#
# First parameter is a file name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named file is empty or missing.
# 1 if the named file exists or is nonempty.
#
# ### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ### Usage Examples
#
#     user$ file_is_missing /bin/bash
#     user$ echo $?
#     1
#
#     user$ file_is_missing /bin/asdfasdf
#     user$ echo $?
#     0
#
file_is_empty_or_missing()
{
  local _file="${1:-}"

  if [[ -n "${_file}" ]]
  then
    if [[ ! -f "${_file}" || ! -s "${_file}" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot check if file is empty or missing as no file path/name was given"
  fi
}

#
# ## file\_contains()
#
# Checks if a named file contains a given string/unix regexp pattern.
#
# ### Input Parameters
#
# First parameter is the file name/path.
# Second parameter is the pattern to match.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the given file contains the given pattern.
# 1 if the given file does not contain the given pattern.
#
# ### Failure Scenarios
#
# Fails if the file path/name was not given
# Fails if the pattern is not given.
# Fails if the file path/name given either does not exist or is not a file.
#
# ### Usage Examples
#
#     user$ cat "$HOME/test"
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
#
#     modules filesystem
#
#     if file_contains "$HOME/.bdsmrc" ".*w00t.*"
#     then
#       echo "w00t! "
#     else
#       echo "no w00t :("
#     fi
#
#
file_contains()
{
  local _file="${1:-}" _message

  if [[ -n "${_file}" ]]
  then
    shift
    local _pattern="${1:-}"
    if [[ -n "${_pattern}" ]]
    then
      if [[ -f "${_file}" ]]
      then
        if grep "${_pattern}" "${_file}" >/dev/null 2>&1
        then
          return 0
        else
          return 1
        fi
      else
        _message=(
        "First parameter must be a file, '${_file}'"
        " does not appear to be a file."
        )
        fail "${_message[*]}"
      fi
    else
      fail "String pattern for search was not given!"
    fi
  else
    fail "File path/name was not given!"
  fi
}

#
# ## symlink\_exists()
#
# Check if a symlink name/path exists.
#
# ### Input Parameters
#
# First parameter is a symlink name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named symlink exists.
# 1 if the named symlink does not exist or does not exist.
#
# ### Failure Scenarios
#
# Fails if no symlink name/path was given.
#
# ### Usage Examples
#
#     user$ symlink_exists /usr/local/bin/bdsm
#     user$ echo $?
#     0
#
#     user$ symlink_exists /bin/asdfasdf
#     user$ echo $?
#     1
#
symlink_exists()
{
  local _file="${1:-}"

  if [[ -n "${_file}" ]]
  then
    if [[ -L "${_file}" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot check if symlink exists as no path/name was given"
  fi
}

#
# ## directory\_exists()
#
# Check if a directory name/path exists.
#
# ### Input Parameters
#
# First parameter is a directory name/path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named directory exists.
# 1 if the named directory does not exist or does not exist.
#
# ### Failure Scenarios
#
# Fails if no directory name/path was given.
#
# ### Usage Examples
#
#     user$ directory_exists /usr/local/bin/bdsm
#     user$ echo $?
#     0
#
#     user$ directory_exists /bin/asdfasdf
#     user$ echo $?
#     1
#
directory_exists()
{
  local _directory="${1:-}"

  if [[ -n "${_directory}" ]]
  then
    if [[ -d "$_directory" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot check if directory exists as no name/path was given"
  fi
}

#
# ## directories\_in()
#
# Function Description
#
# ### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ### Return Codes
#
# 0 if ...
# 1 if ...
#
# ### Failure Scenarios
#
# Fails if ...
#
# ### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
directories_in()
{
  local _path="${1:-}"

  if [[ -n "${path}" ]]
  then
    if [[ -d "${_path}" ]]
    then
      if find "${_path}" -mindepth 1 -maxdepth 1 -type d
      then
        return 0
      else
        return 1
      fi
    else
      fail "'${_path}' is not a directory!"
    fi
  else
    fail "Directory name/path was not given!"
  fi
}

#
# ## directories\_in\_matching()
#
#
directories_in_matching()
{
  local _path="${1:-}" _pattern="${2:-}"

  if [[ -n "${path}" ]]
  then
    if [[ -d "${_path}" ]]
    then
      if [[ -n "${_pattern}" ]]
      then
        if find "${_path}" -mindepth 1 -maxdepth 1 -type d
        then
          return 0
        else
          return 1
        fi
      else
        fail "'${_path}' is not a directory!"
      fi
    else
      fail "'${_path}' is not a directory!"
    fi
  else
    fail "Directory name/path was not given!"
  fi
}

#
# ## directories\_under()
#
#
directories_under()
{
  local _path="${1:-}"

  if [[ -n "${path}" ]]
  then
    if [[ -d "${_path}" ]]
    then
      if find "${_path}" -mindepth 1 -type d
      then
        return 0
      else
        return 1
      fi
    else
      fail "'${_path}' is not a directory!"
    fi
  else
    fail "Directory name/path was not given!"
  fi
}

#
# ## directories\_under\_matching()
#
#
directories_under_matching()
{
  local _path="${1:-}"

  if [[ -n "${path}" ]]
  then
    shift
    local _pattern="${1:-}"
    if [[ -d "${_path}" ]]
    then
      if [[ -n "${_pattern}" ]]
      then
        if find "${_path}" -mindepth 1 -iname "${_pattern}" -type d
        then
          return 0
        else
          return 1
        fi
      else
        fail "'${_path}' is not a directory!"
      fi
    else
      fail "'${_path}' is not a directory!"
    fi
  else
    fail "Directory name/path was not given!"
  fi
}

#
# ## files\_in()
#
# Function Description
#
# ### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ### Return Codes
#
# 0 if ...
# 1 if ...
#
# ### Failure Scenarios
#
# Fails if ...
#
# ### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
files_in()
{
  local _path="${1:-}"

  if [[ -n "${path}" ]]
  then
    if [[ -d "${_path}" ]]
    then
      if find "${_path}" -mindepth 1 -maxdepth 1 -type f
      then
        return 0
      else
        return 1
      fi
    else
      fail "'${_path}' is not a directory!"
    fi
  else
    fail "Directory name/path was not given!"
  fi
}

#
# ## files\_under()
#
# Function Description
#
# ### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ### Return Codes
#
# 0 if ...
# 1 if ...
#
# ### Failure Scenarios
#
# Fails if ...
#
# ### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
files_under()
{
  local _path="${1:-}"

  if [[ -n "${path}" ]]
  then
    if [[ -d "${_path}" ]]
    then
      if find "${_path}" -mindepth 1 -type f
      then
        return 0
      else
        return 1
      fi
    else
      fail "'${_path}' is not a directory!"
    fi
  else
    fail "Directory name/path was not given!"
  fi
}

#
# ## files\_in\_path\_matching()
#
# Find all files in given path matching a given name glob pattern.
#
# ### Input Parameters
#
# First parameter is the path to search in
# Second parameter is the pattern to match in
#
# ### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ### Return Codes
#
# 0 if ...
# 1 if ...
#
# ### Failure Scenarios
#
# Fails if ...
#
# ### Usage Examples
#
#     user$ files_in_path_matching ...
#
files_in_path_matching()
{
  local _path="${1:-}"

  if [[ -n "${path}" ]]
  then
    shift
    _pattern="${1:-}"
    if [[ -d "${_path}" ]]
    then
      shift
      if [[ -n "${_pattern}" ]]
      then
        if find "${_path}" -mindepth 1 -iname "${_pattern}" -type f
        then
          return 0
        else
          return 1
        fi
      else
        fail "Cannot find files as a filename or pattern was not given."
      fi
    else
      fail "'${_path}' is not a directory!"
    fi
  else
    fail "Directory name/path was not given!"
  fi
}

#
# ## replace\_content()
#
# Replaces a given (sed compatable) pattern with given replacement text in a
# file.
#
# ### Input Parameters
#
# First parameter is the pattern
# [optional 'with']
# Second parameter is the replacement content
# [optional 'in']
# Third parameter is the file name/path
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The pattern will be matched against the file name/path content and the
# replacement text will be put in place.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no pattern was given
# Fails if replacement content was not given
# Fails if filename was not given
# Fails if the file does not exist
#
# ### Usage Examples
#
# # Replace contents in a file with a given (sed) regex pattern.
#
#     replace_content "^PREFIX =.*" with "${install_path}" in Makefile
#
replace_content()
{
  local _token _pattern _content _file _message

  while (( $# > 0 ))
  do
    _token="$1"
    shift

    case "${_token}" in
      (with)
        _content="${1:-}"
        shift
        ;;
      (in)
        _file="${1}"
        shift
        ;;
      (*)
        if [[ -z "${_pattern}" ]]
        then
          _pattern="${_token}"
        else
          fail "Unknown token '${_token}' passed as a parameter.'"
        fi
        ;;
    esac
  done

  if [[ -n "${_pattern:-}" ]]
  then
    if [[ -n "${_content:-}" ]]
    then
      if [[ -n "${_file:-}" ]]
      then
        if [[ -f "${_file:-}" ]]
        then
          if sed -i -e "s#${_pattern//\#/\\#}#${_content//\#/\\#}#g" "${_file}"
          then
            return 0
          else
            return 1
          fi
        else
          fail "Can not replace file content as the file does not exist."
        fi
      else
        _message=(
        "Can not file content as the filename was not given,"
        " specify by 'in \"/path/to/filename\"'"
        )
        fail "${_message[*]}"
      fi
    else
      _message=(
      "Cannot replace content as the replacement content was not given, "
      "specify by 'with \"replacement text\"'."
      )
      fail "${_message[*]}"
    fi
  else
    fail "Cannot replace content as not even a pattern was given."
  fi
}

#
# ## file\_matches\_md5()
#
# Checks to see if the given file matches the given md5 sum.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the file matches the md5sum
# 1 if the file does not match the md5sum
# 1 if the file is empty or missing
#
# ### Failure Scenarios
#
# Fails if no file name/path was given.
# Fails if no md5 string was given.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ file_matches_md5
#
# ### Notes
#
file_matches_md5()
{
  local _file="$1" _md5="$2" _file_md5

  if [[ -n "${_file}" ]]
  then
    if [[ -n "${_md5}" ]]
    then
      if [[ -s "${_file}" ]]
      then
        _file_md5="$(file_md5 "${_file}")"

        if [[ "${_file_md5// *}" = "$_md5" ]]
        then
          return 0
        else
          return 1
        fi
      else
        return 1
      fi
    else
      fail "Cannot determine if file matches md5 as no md5 was given."
    fi
  else
    fail "Cannot determine if file matches md5 as no file was given."
  fi
}

#
# ## extract\_archive()
#
#
#
extract_archive()
{
  local _archive="${1:-}"

  if [[ -n "${_archive}" ]]
  then
    shift
    local _path="${1:-}"

    case "${_archive}" in
      *.tar.gz|*.tgz) # gzip
        if ! tar zxf "${_archive}"
        then
          error "There was an error while extracting the archive '${_archive}'"
        fi
        ;;
      *tar.xz) # LZMA
        # TODO: if 'xz' command exists, use that, otherwise use tar J
        if ! tar Jxf "${_archive}"
        then
          error "There was an error while extracting the archive '${_archive}'"
        fi
        ;;
      *.tar.bz2) # bzip
        if ! tar jxf "${_archive}"
        then
          error "There was an error while extracting the archive '${_archive}'"
        fi
        ;;
      *.zip)
        if ! unzip "${_archive}" -d "${_path:-}"
        then
          error "There was an error while extracting the archive '${_archive}'"
        fi
        ;;
      *)
        error "Unknown archive format for ${_archive}"
        ;;
    esac
  else
    fail "Cannot extract an archive to target location as no archive was given."
  fi

}

#
# ## file\_md5()
#
#
#
file_md5()
{
  local _file="${1:-}" _command _md5

  if [[ -n "${_file}" ]]
  then
    if os_is_darwin
    then
      _command="/sbin/md5 -q"

    else
      if command_exists "md5sum"
      then
        _command="md5sum"

      elif command_exists md5
      then
        _command="md5"

      else
        error "Could not find a suitable md5 command in the path."
      fi
    fi

    if _md5="$(${_command} "$_file" 2>/dev/null)"
    then
      printf "${_md5// *}"

    else # Should this be error ?
      warn "There was an unknown error computing the md5"
      return 1
    fi
  else
    fail "Cannot calculate md5 of a file as no file name/path was given."
  fi
}

