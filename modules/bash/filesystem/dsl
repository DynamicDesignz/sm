#!/usr/bin/env bash

# Safely source files and notify the user if they do not exist.
# Recommended to put in /etc/bash.bashrc or ~/.bashrc and be sure
# it is sourced from ~/.bash_profile
source_files()
{
  local _file
  local _files=("$@")

  [[ ${#_files[@]} -gt 0 ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => No files given to source! "

  for _file in "${_files[@]}" ; do
    _file=${_file/\~\//$HOME\/} # Expand ~/ to full value of $HOME

    file_is_nonempty "${_file}" && source "${_file}"
  done
}

# safely source the first file found
nonempty_files()
{
  local _file
  local _files=("$@")

  for _file in "${_files[@]}" ; do
    file_is_nonempty "${_file}" && printf "${_file}\n"
  done
}

ensure_paths_exist()
{
  local _path
  local _paths=("$@")

  for _path in "${_paths[@]}" ; do
    directory_exists "${_path}" || mkdir -p "${_path}"
  done
}

remove_files()
{
  local _file
  local _files=("$@")

  for _file in "${_files[@]}" ; do
    if [[ -f "${_file}" || -L "${_file}" ]] ; then
      rm -f "${_file}"
    elif [[ -d "${_file}" ]] ; then
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot remove ${_file}, it is a directory! "

    elif [[ -e "${_file}" ]] ; then
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Unknown filesystem entity type located at ${_file}, cannot remove."
    else
      true # already gone
    fi
  done
}

remove_paths()
{
  local _path
  local _paths=("$@")

  for _path in "${_paths[@]}" ; do

    if [[ -f "${_path}" ]] ; then
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot remove the path '${_path}' as it is a file! "
    elif [[ -L "${_path}" ]] ; then
      rm -f "${_path}"
    elif [[ -d "${_path}" ]] ; then
      rm -rf "${_path}"
    elif [[ -e "${_path}" ]] ; then
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Unknown filesystem entity type at ${_path}, cannot remove."
    else
      true # already gone
    fi

  done
}

ensure_files_exist()
{
  local _file
  local _files=("$@")

  [[ ${#_files[@]} -gt 0 ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot ensure files exist, no files were given."

  for _file in "${_files[@]}" ; do
    [[ -e "${_file}" ]] || touch "${_file}"
  done
}

# TODO: change this to be a fail function if one is not
#       make this into make_files_executable or some such
ensure_files_are_executable()
{
  local _file="$1"

  [[ -d "${_file}" ]] &&
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot make ${_file} executable, it is a directory."

  [[ -f "${_file}" ]] &&
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot make ${_file} executable, the file does not exist."

  chmod +x "${_file}"
}

#
# Link files
#
# The following usages are equivalent
#
# link from /home/user/.vim/vimrc to /home/user/.vimrc
# link /home/user/.vim/vimrc to /home/user/.vimrc
# link /home/user/.vim/vimrc /home/user/.vimrc
#
link()
{
  local token _source _target _force_flag=0

  while [[ $# -gt 0 ]] ; do
    token="$1" ; shift

    case "${token}" in
      to)
        _target="${1}" ; shift
        ;;
      from)
        _source="${1}" ; shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$token"
        elif [[ -z "${_target}" ]] ; then
          _target="$token"
        fi
        ;;
    esac
  done

  if [[ ${_force_flag} -eq 1 ]] ; then
    remove_files "${_target}"
  fi

  # TODO: What should we do if files already exist?
  if [[ -f "${_target}" ]] ; then
    error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot link ${_source} to ${_target} exists and is a file!"
  elif [[ -d "${_target}" ]] ; then
    error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot link ${_source} to ${_target} exists and is a directory"
  else
    ln -fs "${_source}" "${_target}"
  fi
}

move_file()
{
  local _source _target

  while [[ $# -gt 0 ]] ; do
    token="$1" ; shift
    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$token" ; shift
        elif [[ -z "${_target}" ]] ; then
          _target="$token" ; shift
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  mv "${_source}" "${_target}"
}

copy_file()
{
  local _source _target

  while [[ $# -gt 0 ]] ; do
    token="$1" ; shift
    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$token" ; shift
        elif [[ -z "${_target}" ]] ; then
          _target="$token" ; shift
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  cp "${_source}" "${_target}"
}

copy_files_to()
{
  local _path="$1" _file ; shift
  local _files=("$@")

  ensure_paths_exist "${_path}"

  for _file in "${_files[@]}" ; do

    if file_is_missing "${_file}" ; then
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot copy file ${_file} to ${_path} as the file does not exist."
    else
      cp "${_file}" "${_path}/${_file}"
    fi

  done
}

copy_directories_to()
{
  local _path="${1}" _directory ; shift
  local _directories=("$@")

  ensure_paths_exist "${_path}"

  for _directory in "${_directories[@]}" ; do

    if directory_exists "${_directory}" ; then
      cp -Rf "${_directory}" "${_path}/"
    else
      fail "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot copy directory ${_directory} to ${_path} as the directory does not exist."
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot copy directory ${_directory} to ${_path} as the directory does not exist."
    fi

  done
}

move_files_to()
{
  local _path="$1" _file ; shift
  local _files=("$@")

  ensure_paths_exist "${_path}"

  for _file in "${_files[@]}" ; do

    if file_exists "${_file}" ; then
      mv "${_file}" "${_path}/${_file}"
    else
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot move file ${_file} to ${_path} as the file does not exist."
    fi

  done
}

chown_files()
{
  local _idenity="$1" _file; shift

  for _file in "${@}" ; do

    if file_exists "${_file}" ; then
      chown -R ${_idenity} "${_file}"
    else
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot chown file ${_file} to ${_idenity} as the file does not exist."
    fi

  done
}

chown_paths()
{
  local _idenity="$1" _path; shift
  local _paths=("$@")

  for _path in "${_paths[@]}" ; do

    if directory_exists "${_path}" ; then
      chown ${_idenity} "${_path}"
    else
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot chown path ${_path} to ${_idenity} as the directory does not exist."
    fi

  done
}

chown_paths_recursively()
{
  local _idenity="$1" _path; shift
  local _paths=("$@")

  for _path in "${_paths[@]}" ; do

    if directory_exists "${_path}" ; then
      chown -R ${_idenity} "${_path}"
    else
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot recursively chown ${_path} to ${_idenity} as the directory does not exist."
    fi

  done
}

chmod_files()
{
  local _permissions="$1" _file; shift
  local _files=("$@")

  for _file in "${_files[@]}" ; do
    if file_exists "${_file}" ; then
      chmod ${_permissions} "${_file}"
    else
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot chmod file ${_file} to ${_permissions} as the file does not exist."
    fi
  done
}

chmod_paths()
{
  local _permissions="$1" _path; shift

  for _path in "${@}" ; do
    if directory_exists "${_directory}" ; then
      chmod ${_permissions} "${_path}"
    else
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot chmod directory ${_path} to ${_permissions} as the directory does not exist."
    fi
  done
}

chmod_paths_recursively()
{
  local _permissions="$1" _path; shift

  for _path in "${@}" ; do
    if directory_exists "${_directory}" ; then
      chmod -R ${_permissions} "${_path}"
    else
      error "${extension:-core} ${action} ${FUNCNAME}()\n => Cannot chmod directory ${_path} to ${_permissions} as the directory does not exist."
    fi
  done
}

enter()
{
  local _path="$1"

  builtin cd "${_path}" ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Could not enter directory ${_path}."
}

hash_file()
{
  local _file="${1:-}" ; shift
  local _key="${2:-}" ; shift

  [[ -f "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name not given.\n => Usage: $0 <filename> <key> [value]"

  ensure_paths_exist $(dirname $_file)

  ensure_files_exist "$_file"

  [[ -n "${_key}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Key not given.\n => Usage: $0 <filename> <key> [value]"

  value="$*"
  case "$value" in
    unset|delete)
      sed -i.tmp "s#^${_key}=.*\$##" "${_file}"
      ;;
    *)
      if [[ -z "$value" ]] ; then # get
        awk -F= '/^'"${key}"'=/{print $2}' "$_file"
      else # set
        if ! awk -F= "/^'"${_key}"'=/{print $2}" "${_file}" >/dev/null 2>&1; then
          echo "${_key}=$value" >> "${_file}"
        else # overwrite
          sed -i.tmp "s#^${_key}=.*\$#${_key}=$value#" "${_file}"
        fi
      fi
      ;;
  esac
}

file_is_executable()
{
  local _file="${1:-}"

  [[ -n "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name was not given!"

  [[ -x "${_file}" ]]
}

file_exists()
{
  local _file="${1:-}"

  [[ -n "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name was not given!"

  [[ -f "${_file}" ]]
}

file_is_nonempty()
{
  local _file="${1:-}"

  [[ -n "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name was not given!"

  [[ -s "${_file}" ]]
}

file_is_empty()
{
  local _file="${1:-}"

  [[ -n "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name was not given!"

  [[ -f "${_file}" && ! -s "${_file}" ]]
}

file_is_missing()
{
  local _file="${1:-}"

  [[ -n "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name was not given!"

  [[ ! -f "${_file}" ]]
}

file_is_empty_or_missing() {
  local _file="${1:-}"

  [[ -n "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name was not given!"

  [[ ! -f "${_file}" || ! -s "${_file}" ]] ;
}

file_contains()
{
  local _file="${1:-}" _pattern="${2:-}"

  [[ -n "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name was not given!"

  [[ -n "${_pattern}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => String pattern for search was not given!"

  grep "${_pattern}" "${_file}" >/dev/null 2>&1
}

symlink_exists()
{
  local _file="${1:-}"

  [[ -n "${_file}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => File path/name was not given!"

  [[ -L "${_file}" ]]
}

# Directory conditional dsl
directory_exists()
{
  local _directory="${1:-}"
  [[ -n "${_directory}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Directory name/path was not given!"

  [[ -d "$_directory" ]]
}

directories_in()
{
  local _path="${1:-}"

  [[ -n "${path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Directory name/path was not given!"

  [[ -d "${_path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -maxdepth 1 -type d
}

directories_in_matching()
{
  local _path="${1:-}" _pattern="${2:-}"

  [[ -n "${path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Directory name/path was not given!"

  [[ -d "${_path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  [[ -n "${_pattern}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -maxdepth 1 -type d
}

directories_under()
{
  local _path="${1:-}"

  [[ -n "${path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Directory name/path was not given!"

  [[ -d "${_path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -type d
}

directories_under_matching()
{
  local _path="${1:-}" _pattern="${2:-}"

  [[ -n "${path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Directory name/path was not given!"

  [[ -d "${_path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  [[ -n "${_pattern}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -iname "${_pattern}" -type d
}

files_in()
{
  local _path="${1:-}"

  [[ -n "${path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Directory name/path was not given!"

  [[ -d "${_path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -maxdepth 1 -type f
}

files_under()
{
  local _path="${1:-}"

  [[ -n "${path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Directory name/path was not given!"

  [[ -d "${_path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -type f
}

files_under_matching()
{
  local _path="${1:-}" _pattern="${2:-}"

  [[ -n "${path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => Directory name/path was not given!"

  [[ -d "${_path}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  [[ -n "${_pattern}" ]] ||
    fail "${extension:-core} ${action} ${FUNCNAME}()\n => '${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -iname "${_pattern}" -type f
}

