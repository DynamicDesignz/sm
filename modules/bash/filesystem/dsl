#!/usr/bin/env bash

#
# ## source_files
#
# Safely source files only if they exists and are nonempty.
#
# ##### Input Parameters
#
# One or more files.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# Nonempty files given will be sourced into the calling environment.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no files are given to sources.
#
# ##### Usage Examples
#
#     user$ source_files "$HOME/.dotfiles/scripts/functions"
#
source_files()
{
  local _file _files=("$@")

  (( ${#_files[@]} > 0 )) || fail "Cannot source files as no files were given."

  for _file in "${_files[@]}" ; do
    _file=${_file/\~\//$HOME\/} # Expand ~/ to full value of $HOME

    if file_is_nonempty "${_file}" ; then
      source "${_file}"
      # TODO: figure out how to see if 'source' itself failed or simply
      # returning nonzero code.
      # || fail "Failed to source ${_file}."
    fi
  done
}

#
# ## nonempty_files
#
# Outputs a subset of the named files that are nonempty.
#
# ##### Input Parameters
#
# One or more files.
#
# ##### Stream Outputs
#
# Each nonempty filename parameter will be printed to STDOUT of the calling
# environment.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no file names are given as arguments.
#
# ##### Usage Examples
#
#     user$ nonempty_files a $HOME/.bdmsrc c
#     /Users/wayneeseguin/.bdsmrc
#
nonempty_files()
{
  local _file _files=("$@")

  (( ${#_files[@]} > 0 )) ||
    fail "Cannot return nonempty files as no files were given."

  for _file in "${_files[@]}"
  do
    if file_is_nonempty "${_file}"
    then
      printf "${_file}\n"
    fi
  done
}

#
# ## ensure_paths_exist
#
# Iterates over the list of given paths, creates the directory if it
# does not exist.
#
# ##### Input Parameters
#
# A list of paths to create if missing.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# Paths that were given but do not exist will be created.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no paths were given to.
#
# ##### Usage Examples
#
#     user$ ls -a
#     . ..
#     user$ ensure_paths_exist a b c
#     user$ ls -a
#     . .. a b c
#
ensure_paths_exist()
{
  local _path _paths=("$@")

  (( ${#_paths[@]} > 0 )) ||
    fail "Cannot ensure paths exist as no paths were given."

  for _path in "${_paths[@]}"
  do
    directory_exists "${_path}" || mkdir -p "${_path}"
  done
}

#
# ## remove_files
#
# Removes the given files, if they exist.
#
# ##### Input Parameters
#
# One or more file names/paths.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# The named files will no longer exist on the system, if they existed to begin
# with.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no files were named.
# Fails if a named file is a directory.
# Fails if a named file exists but is not a file.
#
# ##### Usage Examples
#
#     user$ touch a b c
#     user$ ls -a
#     . .. a b c
#     user$ remove_files a b c
#     user$ ls
#     . ..
#
remove_files()
{
  local _file _files=("$@")

  (( ${#_files[@]} > 0 )) ||
    fail "Cannot remove files as no files were given."

  for _file in "${_files[@]}"
  do
    if [[ -f "${_file}" || -L "${_file}" ]] ; then
      rm -f "${_file}"
    elif [[ -d "${_file}" ]] ; then
      error "Cannot remove the file ${_file} as it is a directory."
    elif [[ -e "${_file}" ]] ; then
      error "Unknown filesystem entity type located at ${_file}, cannot remove."
    else
      true # already gone
    fi
  done
}

#
# ## remove
#
# Removes the given entries, if they exist.
#
# ##### Input Parameters
#
# One or more file, directory or symlink names/paths.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# The named files will no longer exist on the system, if they existed to begin
# with.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no files were named.
#
# ##### Usage Examples
#
#     user$ touch a
#     user$ mkdir b
#     user$ ln -s b c
#     user$ ls -a
#     . .. a b c
#     user$ remove a b c
#     user$ ls
#     . ..
#
remove()
{
  local _file _files=("$@")

  if (( ${#_files[@]} == 0 ))
  then
    fail "Cannot remove files as no files were given."
  fi

  for _file in "${_files[@]}"
  do
    if [[ -f "${_file}" || -L "${_file}" || -d "${_file}" ]] ; then
      rm -rf "${_file}"

    elif [[ -e "${_file}" ]] ; then
      error "Unhandled filesystem entity type located at ${_file}, cannot remove. (File, link and directory types are handled)"

    fi
  done
}

#
# ## remove_paths
#
# Function Description
#
# ##### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ##### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ##### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ##### Return Codes
#
# 0 if ...
# 1 if ...
#
# ##### Failure Scenarios
#
# Fails if ...
#
# ##### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
remove_paths()
{
  local _path _paths=("$@")

  (( ${#_paths[@]} > 0 )) || fail "Cannot remove paths as no paths were given."

  for _path in "${_paths[@]}" ; do
    if [[ -f "${_path}" ]] ; then
      error "Cannot remove the path '${_path}' as it is a file."
    elif [[ -L "${_path}" ]] ; then
      rm -f "${_path}"
    elif [[ -d "${_path}" ]] ; then
      rm -rf "${_path}"
    elif [[ -e "${_path}" ]] ; then
      error "Unknown filesystem entity type at ${_path}, cannot remove."
    else
      true # already gone
    fi
  done
}

#
# ## ensure_files_exist
#
# Iterates over the list of given files, creates the directory if it
# does not exist.
#
# ##### Input Parameters
#
# A list of files to create if missing.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# files that were given but do not exist will be created.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no files were given to.
#
# ##### Usage Examples
#
#     user$ ls -a
#     . ..
#     user$ ensure_files_exist a b c
#     user$ ls -a
#     . .. a b c
#
ensure_files_exist()
{
  local _file _files=("$@") _path

  (( ${#_files[@]} > 0 )) ||
    fail "Cannot ensure files exist as no files were given."

  for _file in "${_files[@]}"
  do
    _path="${_file%\/*}"
    [[ -d "${_path}" ]] || mkdir -p "${_path}"
    [[ -e "${_file}" ]] || touch "${_file}"
  done
}

#
# ## ensure_files_are_executable
#
# Sets the executable bits on a file if it is not executable.
#
# ##### Input Parameters
#
# One or more file name/paths
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# Files that were given and not executable will have their execute bits set.
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if no files were given as parameters.
# Fails if one of the files given was a directory.
# Fails if one of the files given does not exist.
# Fails if one of the files paths does not exist.
#
# ##### Usage Examples
#
#     user$ ensure_files_are_executable /etc/rc.d/postgresql
#
ensure_files_are_executable()
{
  # TODO: change this to be a  fail function if one is not
  #       make this into make_files_executable or some such
  local _file _files=("$@") _path

  if (( ${#_files[@]} == 0 ))
  then
    fail "Cannot ensure files are executable as no files were given."
  fi

  for _file in "${_files[@]}"
  do
    if [[ -d "${_file}" ]]
    then
      fail "Cannot make the file '${_file}' executable as it is a directory."
    fi

    if [[ ! -f "${_file}" ]]
    then
      fail "Cannot make the file '${_file}' executable as the file does not exist."
    fi

    _path="${_file%\/*}"
    if ! [[ -n "${_path}" && ! -d "${_file}" ]]
    then
      fail "Cannot make the file '${_file} executable as '${_path}' does not even exist."
    fi

    chmod +x "${_file}"
  done
}

#
# ## link
#
# Create a symlink from source to target.
#
# ##### Input Parameters
#
# First parameter is the source
# Second parameter is the target
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# Symlink is created if no failure conditions are triggered.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if target exists and is a file.
# Fails if target exists and is a directory.
#
# ##### Usage Examples
#
# The following usages are equivalent
#
#     user$ link from /home/user/.vim/vimrc to /home/user/.vimrc
#     user$ link /home/user/.vim/vimrc to /home/user/.vimrc
#     user$ link /home/user/.vim/vimrc /home/user/.vimrc
#
link()
{
  local token _source _target _force_flag=0

  while (( $# > 0 )) ; do
    token="$1" ; shift

    case "${token}" in
      to)
        _target="${1}" ; shift
        ;;
      from)
        _source="${1}" ; shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$token"
        elif [[ -z "${_target}" ]] ; then
          _target="$token"
        fi
        ;;
    esac
  done

  if (( _force_flag == 1 ))
  then
    remove "${_target}"
  fi

  # TODO: What should we do if files already exist?
  if [[ -f "${_target}" ]] ; then
    error "Cannot link ${_source} to ${_target} exists and is a file!"
  elif [[ -d "${_target}" ]] ; then
    error "Cannot link ${_source} to ${_target} exists and is a directory"
  else
    ensure_paths_exist "${_target%\/*}"
    ln -fs "${_source}" "${_target}"
  fi
}

#
# ## move_directory
#
# Moves a directory from one location to another.
# (This is also used to rename a directory.)
#
# ##### Input Parameters
#
# The first parameter is the source directory name
# The second parameter is the target directory name
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, a directory is renamed (moved).
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if the source directory is not specified.
# Fails if the target directory is not specified.
#
# ##### Usage Examples
#
#     user$ move_directory "freetds-0.91rc"* to "freetds-0.91"
#
move_directory()
{
  local _source _target _mode _owner

  while (( $# > 0 )) ; do
    token="$1" ; shift
    case "${token}" in
      to)
        _target="${1}" ; shift
        ;;

      from)
        _source="${1}" ; shift
        ;;

      mode)
         _mode="${1}" ; shift
        ;;

      owner)
         _owner="${1}" ; shift
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$token"
        elif [[ -z "${_target}" ]] ; then
          _target="$token"
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  [[ -n "${_source}" ]] ||
    fail "Cannot move file as the source and target must be specified. "

  [[ -n "${_target}" ]] ||
    fail "Cannot move file as the source and target must be specified. "

  mv "${_source}" "${_target}"

  [[ -z "${_mode:-}" ]]  || chmod -R "${_mode}" "${_target}"
  [[ -z "${_owner:-}" ]] || chown -R "${_owner}" "${_target}"
}

#
# ## move_file
#
# Moves a file from one location to another.
# (This is also used to rename a file.)
#
# ##### Input Parameters
#
# The first parameter is the source file name
# The second parameter is the target file name
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, a file is renamed (moved).
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if the source file is not specified.
# Fails if the target file is not specified.
#
# ##### Usage Examples
#
#     user$ move_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
#
move_file()
{
  local _source _target _mode _owner

  while (( $# > 0 )) ; do
    token="$1" ; shift
    case "${token}" in
      to)
        _target="${1}" ; shift
        ;;

      from)
        _source="${1}" ; shift
        ;;

      mode)
         _mode="${1}" ; shift
        ;;

      owner)
         _owner="${1}" ; shift
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$token"
        elif [[ -z "${_target}" ]] ; then
          _target="$token"
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  [[ -n "${_source}" ]] ||
    fail "Cannot move file as the source and target must be specified. "

  [[ -n "${_target}" ]] ||
    fail "Cannot move file as the source and target must be specified. "

  mv "${_source}" "${_target}"

  [[ -z "${_mode:-}" ]]  || chmod "${_mode}" "${_target}"
  [[ -z "${_owner:-}" ]] || chown "${_owner}" "${_target}"
}

#
# ## copy_file
#
# Copys a file from one location to another.
# (This is also used to rename a file.)
#
# ##### Input Parameters
#
# The first parameter is the source file name
# The second parameter is the target file name
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, a file is renamed (copyd).
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if the source file is not specified.
# Fails if the target file is not specified.
#
# ##### Usage Examples
#
#     user$ copy_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
#
copy_file()
{
  local _source _target

  while (( $# > 0 )) ; do
    token="$1" ; shift
    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      mode)
         _mode="${1}" ; shift
        ;;

      owner)
         _owner="${1}" ; shift
        ;;
      *)
        if [[ -z "${_source:-}" ]]
        then
          _source="$token"
          shift
        elif [[ -z "${_target:-}" ]]
        then
          _target="$token"
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  cp "${_source}" "${_target}"

  if [[ -n "${_mode:-}" ]]
  then
    chmod "${_mode}" "${_target}"
  fi

  if [[ -n "${_owner:-}" ]]
  then
    chown "${_owner}" "${_target}"
  fi

}

#
# ## copy_files_to
#
# Copys a given list of files into the named path.
#
# ##### Input Parameters
#
# The first parameter is the path to copy the files into.
# Remaining parameters are the file name/path list.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, all named files are copied into the target path.
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no files are given.
#
# ##### Usage Examples
#
#     user$ copy_files_to "$HOME/backup" "$HOME/.bashrc" "$HOME/.bash_profile"
#
copy_files_to()
{
  local _path="${1:-}" _file

  if [[ -z "${_path}" ]]
  then
    fail "Path was not given as the first parameter."
  else
    shift
  fi

  local _files=("$@")

  if (( ${#_files[@]} == 0 ))
  then
    fail "No files were given in order to copy them into ${_path}."
  fi

  log "copy_files_to is depreciated, please use copy_files with the 'to' specifier instead"

  ensure_paths_exist "${_path}"

  for _file in "${_files[@]}"
  do
    if file_is_missing "${_file}"
    then
      error "Cannot copy file ${_file} to ${_path} as the file does not exist."
    else
      cp "${_file}" "${_path}/${_file}"
    fi

  done
}

#
# ## copy_files
#
# Copys a given list of files into the named path.
#
# ##### Input Parameters
#
# The first parameter is the path to copy the files into.
# Remaining parameters are the file name/path list.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, all named files are copied into the target path.
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no files are given.
#
# ##### Usage Examples
#
#     user$ copy_files "$HOME/backup" "$HOME/.bashrc" "$HOME/.bash_profile"
#
copy_files()
{
  local _source _target _file _force_flag=0 _files=()

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        _files+=( "${token}" )
        ;;
    esac
  done

  if [[ -z "${_target}" ]]
  then
    fail "Cannot copy files as no target path was given (eg. copy_files ... to {path})."
  fi

  if (( ${#_files[@]} == 0 ))
  then
    fail "Cannot copy files as no files were given to copy."
  fi

  ensure_paths_exist "${_target}"

  for _file in "${_files[@]}"
  do
    if file_is_missing "${_file}"
    then
      error "Cannot copy file ${_file} to ${_target} as the file does not exist."
    else
      if (( _force_flag == 1 ))
      then
        cp -f "${_file}" "${_target}/${_file//*\/}"
      else
        cp "${_file}" "${_target}/${_file//*\/}"
      fi
    fi
  done
}

#
# ## copy_directories_to
#
# Copys a given list of directories into the named path.
#
# ##### Input Parameters
#
# The first parameter is the path to copy the directorys into.
# Remaining parameters are the directory name/path list.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, all named directories are copied into the target path.
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no directories are given.
#
# ##### Usage Examples
#
#     user$ copy_directories_to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
#
copy_directories_to()
{
  local _path="${1:-}" _directory

  if [[ -z "${_path}" ]]
  then
    fail "Path was not given as the first parameter."
  else
    shift
  fi

  local _directories=("$@")

  if (( ${#_directories[@]} == 0 ))
  then
    fail "No directories were given in order to copy them into ${_path}."
  fi

  ensure_paths_exist "${_path}"

  for _directory in "${_directories[@]}"
  do
    if directory_exists "${_directory}"
    then
      cp -Rf "${_directory}" "${_path}/"
    else
      error "Cannot copy directory ${_directory} to ${_path} as the directory '${_directory}' does not exist (in '$PWD')."
    fi
  done
}

#
# ## copy_directories to
#
# Copys a given list of directories into the named path.
#
# ##### Input Parameters
#
# The first parameter is the path to copy the directorys into.
# Remaining parameters are the directory name/path list.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, all named directories are copied into the target path.
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no directories are given.
#
# ##### Usage Examples
#
#     user$ copy_directories to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
#
copy_directories()
{
  local _source _target _directory _force_flag=0 _directories=()

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        _directories+=( "${token}" )
        ;;
    esac
  done

  if [[ -z "${_target}" ]]
  then
    fail "Cannot copy directories as no target path was given (eg. copy_directories ... to {path})."
  fi

  if (( ${#_directories[@]} == 0 ))
  then
    fail "Cannot copy directories as no directories were given to copy."
  fi

  ensure_paths_exist "${_target}"

  for _directory in "${_directories[@]}"
  do
    if directory_exists "${_directory}"
    then
      cp -Rf "${_directory}" "${_target}/"
    else
      error "Cannot copy directory ${_directory} to ${_target} as the directory '${_directory}' does not exist (in '$PWD')."
    fi
  done
}


#
# ## copy_directory
#
# Copys a directory from one location to another.
# (This is also used to rename a directory.)
#
# ##### Input Parameters
#
# The first parameter is the source directory name
# The second parameter is the target directory name
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, a directory is renamed (copyd).
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if the source directory is not specified.
# Fails if the target directory is not specified.
#
# ##### Usage Examples
#
#     user$ copy_directory "freetds-0.91rc"* to "freetds-0.91"
#
copy_directory()
{
  local _source _target

  while (( $# > 0 )) ; do
    token="$1" ; shift
    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$token"
          shift
        elif [[ -z "${_target}" ]] ; then
          _target="$token"
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  cp -Rf "${_source}" "${_target}"
}

#
# ## move_files_to
#
# Moves a given list of files into the named path.
#
# ##### Input Parameters
#
# The first parameter is the path to move the files into.
# Remaining parameters are the file name/path list.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, all named files are copied into the target path.
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no files are given.
#
# ##### Usage Examples
#
#     user$ move_files_to "$HOME/backup" "$HOME/.bashrc" "$HOME/.bash_profile"
#
move_files_to()
{
  local _path="${1:-}" _file

  if [[ -n "${_path}" ]]
  then
    fail "Path was not given as the first parameter."
  else
    shift
  fi

  log "DEPRECIATED, use 'move_files ... to _path' instead"

  local _files=("$@")

  if (( ${#_files[@]} > 0 ))
  then
    fail "No files given in order to chmod ${_permissions} them."
  fi

  ensure_paths_exist "${_path}"

  for _file in "${_files[@]}"
  do
    if file_exists "${_file}"
    then
      mv "${_file}" "${_path}/${_file}"
    else
      error "Cannot move file ${_file} to ${_path} as the file does not exist."
    fi
  done
}

#
# ## move_files
#
# Moves a given list of files into the named path.
#
# ##### Input Parameters
#
# Parameters are file name/path for one or more files
# Target directory is specified as 'to {{path}}'
# Optional source directory is specified as 'from {{path}}'
# Optional force flag '--force' may be specified
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# If successful, all named files are copied into the target path.
#
# ##### Return Codes
#
# 0 for success.
#
# ##### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no files are given.
#
# ##### Usage Examples
#
#     user$ move_files "$HOME/.bashrc" "$HOME/.bash_profile" to "$HOME/backup"
#
# Alternatively,
#
#     user$ move_files ".bashrc" ".bash_profile" from "$HOME" to "$HOME/backup"
#
move_files()
{
  local _source _target _file _force_flag=0 _files=()

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        _files+=( "${token}" )
        ;;
    esac
  done

  if [[ -z "${_target}" ]]
  then
    fail "Cannot move files as no target path was given (eg. move_files ... to {path})."
  fi

  if (( ${#_files[@]} == 0 ))
  then
    fail "Cannot move files as no files were given to move."
  fi

  ensure_paths_exist "${_target}"

  for _file in "${_files[@]}"
  do
    if [[ -n "${_source}" ]]
    then
      _file="${_source}/${_file}"
    fi

    if file_exists "${_file}"
    then
      if (( _force_flag == 1 ))
      then
        mv -f "${_file}" "${_target}/${_file//*\/}"
      else
        mv "${_file}" "${_target}/${_file//*\/}"
      fi
    else
      error "Cannot move file ${_file} to ${_path} as the file does not exist."
    fi
  done
}

#
# ## chown_files
#
# Change ownership of a list of files.
#
# ##### Input Parameters
#
# First parameter is the new owner[:group] of the files.
# Remaining parameters are the file names/paths.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of files was given.
#
# ##### Usage Examples
#
#     user$ chown_files $USER "$HOME/.bashrc" "$HOME/.bash_profile"
#
chown_files()
{
  local _identity="${1:-}" _file

  if [[ -z "${_identity}" ]]
  then
    fail "user[:group] not given as the first parameter."
  else
    shift
  fi

  local _files=("$@")

  if (( ${#_files[@]} == 0 ))
  then
    fail "No paths given to chmod ${_permissions}."
  fi

  for _file in "${_files[@]}"
  do
    if file_exists "${_file}"
    then
      chown -R ${_identity} "${_file}"
    else
      error "Cannot chown file ${_file} to ${_identity} as the file does not exist."
    fi
  done
}

#
# ## chown_paths
#
# Change ownership of a list of paths.
#
# ##### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ##### Usage Examples
#
#     user$ chown_paths $USER "$HOME" "/usr/local"
#
chown_paths()
{
  local _identity="${1:-}" _path

  if [[ -z "${_identity}" ]]
  then
    fail "user[:group] not given as the first parameter."
  else
    shift
  fi

  local _paths=("$@")

  if (( ${#_paths[@]} == 0 ))
  then
    fail "No paths given to chmod ${_permissions}."
  fi

  for _path in "${_paths[@]}"
  do
    if directory_exists "${_path}"
    then
      chown ${_identity} "${_path}"
    else
      error "Cannot chown path ${_path} to ${_identity} as the directory does not exist."
    fi
  done
}

#
# ## chown_paths_recursively
#
# Change ownership of a list of paths, recursively.
#
# ##### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ##### Usage Examples
#
#     user$ chown_paths_recursively $USER "$HOME" "/usr/local"
#
chown_paths_recursively()
{
  local _identity="${1:-}" _path

  if [[ -z "${_identity}" ]]
  then
    fail "user[:group] not given as the first parameter!!"
  else
    shift
  fi

  local _paths=("$@")

  if (( ${#_paths[@]} == 0 ))
  then
    fail "No paths given to chmod ${_permissions}."
  fi

  for _path in "${_paths[@]}"
  do
    if directory_exists "${_path}"
    then
      chown -R ${_identity} "${_path}"
    else
      error "Cannot recursively chown ${_path} to ${_identity} as the directory does not exist."
    fi
  done
}

#
# ## chmod_files
#
# Change ownership of a list of files.
#
# ##### Input Parameters
#
# First parameter is the new owner[:group] of the files.
# Remaining parameters are the file names/files.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of files was given.
#
# ##### Usage Examples
#
#     user$ chmod_files $USER "$HOME" "/usr/local"
#
chmod_files()
{
  local _permissions="${1:-}" _file

  if [[ -z "${_permissions}" ]]
  then
    fail "Permissions not given as the first parameter!!"
  else
    shift
  fi

  local _files=("$@")

  if (( ${#_files[@]} == 0 ))
  then
    fail "No files given to chmod ${_permissions}."
  fi

  for _file in "${_files[@]}"
  do
    if file_exists "${_file}"
    then
      chmod ${_permissions} "${_file}"
    else
      error "Cannot chmod file ${_file} to ${_permissions} as the file does not exist."
    fi
  done
}

#
# ## chmod_paths
#
# Change ownership of a list of paths.
#
# ##### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ##### Usage Examples
#
#     user$ chmod_paths $USER "$HOME" "/usr/local"
#
chmod_paths()
{
  local _permissions="$1" _path
  if [[ -z "${_permissions}" ]]
  then
    fail "Cannot chmod_paths as the permissions were not given as the first parameter!!"
  else
    shift
  fi

  local _paths=("$@")

  if (( ${#_paths[@]} == 0 ))
  then
    fail "Cannot chmod_paths as no paths were given in order to change permissions to ${_permissions}."
  fi

  for _path in "${_paths[@]}"
  do
    if directory_exists "${_directory}"
    then
      chmod ${_permissions} "${_path}"
    else
      error "Cannot chmod directory ${_path} to ${_permissions} as the directory does not exist."
    fi
  done
}

#
# ## chmod_paths_recursively
#
# Change ownership of a list of paths, recursively.
#
# ##### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ##### Usage Examples
#
#     user$ chmod_paths_recursively $USER "$HOME" "/usr/local"
#
chmod_paths_recursively()
{
  local _permissions="${1:-}" _path
  if [[ -z "${_permissions}" ]]
  then
    fail "Permissions not given as the first parameter!!"
  fi
  shift
  local _paths=("$@")

  if (( ${#_paths[@]} == 0 ))
  then
    fail "No paths given to chmod ${_permissions}."
  fi

  for _path in "${_paths[@]}"
  do
    if directory_exists "${_path}"
    then
      chmod -R ${_permissions} "${_path}"
    else
      error "Cannot chmod directory ${_path} to ${_permissions} as the directory does not exist."
    fi
  done
}

#
# ## enter
#
# Changes the current working directory ($PWD) to the given directory with
# sanity checks.
#
# ##### Input Parameters
#
# First parameter is the directory to change into.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# The current working directory (PWD) will become the given directory if
# successful.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no directory was given.
# Fails if the given directory does not exist.
#
# ##### Usage Examples
#
#     user$ enter "/usr/local/src"
#
enter()
{
  local _path="$1"

  if [[ -z "${_path}" ]]
  then
    fail "Cannot enter a directory as no directory was given."
  fi

  if [[ ! -d "${_path}" ]]
  then
    error "Cannot enter the directory '${_path}' as it does not exist."
  fi

  if ! builtin cd "${_path}"
  then
    error "There was an error ($?) wile attempting to enter the directory '${_path}'."
  fi
}

#
# ## hash_file
#
# Set and get key/value pairs from a given has file.
#
# ##### Input Parameters
#
# The first parameter is the file name/path for the hash file.
# The second parameter is the key name.
# The third (optional) parameter is the value to assign to the given key.
#
# ##### Stream Outputs
#
# The value of the key retrieved is printed if no value parameter was given.
#
# ##### Environmental effects
#
# If a value parameter was given the key=value pair is written to the named
# hash file.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no file name/path was provided.
# Fails if no key name was given.
# Fails if the file path does not exist.
#
# ##### Usage Examples
#
#     user$ hash_file /usr/local/bdsm/extensions/core/config/defaults website_url
#     https://bdsm.beginrescueend.com/
#
hash_file()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "File path/name not given.\n => Usage: $0 <filename> <key> [value]"
  else
    shift
  fi

  local _key="${1:-}"

  if [[ -z "${_key}" ]]
  then
    fail "Key not given.\n => Usage: $0 <filename> <key> [value]"
  else
    shift
  fi

  local _path=$(dirname "${_file}")
  if [[ -d "${_path}" ]]
  then
    ensure_files_exist "$_file"
  else
    error "Cannot access the database file '${_file}' as the directory '${_file%\/*}' does not exist."
  fi

  value="$*"
  case "$value" in
    unset|delete)
      sed -i.tmp "s#^${_key}=.*\$##" "${_file}"
      ;;
    *)
      if [[ -z "${value}" ]]
      then # get
        awk -F= '/^'"${_key}"'=/{print $2}' "$_file"
      else # set
        if ! awk -F= "/^'"${_key}"'=/{print $2}" "${_file}" >/dev/null 2>&1
        then
          echo "${_key}=$value" >> "${_file}"
        else # overwrite
          sed -i.tmp "s#^${_key}=.*\$#${_key}=$value#" "${_file}"
        fi
      fi
      ;;
  esac
}

#
# ## file_is_executable
#
# Check if a file name/path is executable.
#
# ##### Input Parameters
#
# First parameter is a file name/path.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the named file is executable.
# 1 if the named file is not executable or does not exist.
#
# ##### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ##### Usage Examples
#
#     user$ file_is_executable /bin/bash
#     user$ echo $?
#     0
#
#     user$ file_is_executable /bin/asdfasdf
#     user$ echo $?
#     1
#
file_is_executable()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "Cannot check if a file is executable as no file path/name was given"
  fi

  if [[ -x "${_file}" ]]
  then
    return 0
  else
    return 1
  fi
}

#
# ## file_exists
#
# Check if a file name/path exists.
#
# ##### Input Parameters
#
# First parameter is a file name/path.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the named file exists.
# 1 if the named file does not exist or does not exist.
#
# ##### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ##### Usage Examples
#
#     user$ file_exists /bin/bash
#     user$ echo $?
#     0
#
#     user$ file_exists /bin/asdfasdf
#     user$ echo $?
#     1
#
file_exists()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "Cannot check to see if a file exists as no file name/path was given"
  fi

  if [[ -f "${_file}" ]]
  then
    return 0
  else
    return 1
  fi
}

#
# ## file_is_nonempty
#
# Check if a file name/path is nonempty.
#
# ##### Input Parameters
#
# First parameter is a file name/path.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the named file is nonempty.
# 1 if the named file is empty or does not exist.
#
# ##### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ##### Usage Examples
#
#     user$ file_is_nonempty /bin/bash
#     user$ echo $?
#     0
#
#     user$ file_is_nonempty /bin/asdfasdf
#     user$ echo $?
#     1
#
file_is_nonempty()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "Cannot check if file is nonempty as no file path/name was given"
  fi

  if [[ -d "${_file}" ]]
  then
    error "When checking whether the file '${_file}' is nonempty, a directory was found in its place."
  fi

  if [[ -s "${_file}" ]]
  then
    return 0
  else
    return 1
  fi
}


#
# ## file_is_empty
#
# Check if a file name/path is empty.
#
# ##### Input Parameters
#
# First parameter is a file name/path.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the named file is empty.
# 1 if the named file is not empty or does not exist.
#
# ##### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ##### Usage Examples
#
#     user$ file_is_empty /bin/bash
#     user$ echo $?
#     1
#
#     user$ file_is_empty /bin/asdfasdf
#     user$ echo $?
#     0
#
file_is_empty()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "Cannot check if a file is empty as no file path/name was given"
  fi

  if [[ -f "${_file}" && ! -s "${_file}" ]]
  then
    return 0
  else
    return 1
  fi
}

#
# ## file_is_missing
#
# Check if a file name/path is missing.
#
# ##### Input Parameters
#
# First parameter is a file name/path.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the named file is missing.
# 1 if the named file is not missing or does not exist.
#
# ##### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ##### Usage Examples
#
#     user$ file_is_missing /bin/bash
#     user$ echo $?
#     1
#
#     user$ file_is_missing /bin/asdfasdf
#     user$ echo $?
#     0
#
file_is_missing()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "Cannot check if file is missing as no file path/name was given"
  fi

  if [[ ! -f "${_file}" ]]
  then
    return 0
  else
    return 1
  fi
}

#
# ## file_is_empty_or_missing
#
# Check if a file name/path is empty or missing.
#
# ##### Input Parameters
#
# First parameter is a file name/path.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the named file is empty or missing.
# 1 if the named file exists or is nonempty.
#
# ##### Failure Scenarios
#
# Fails if no file name/path was given.
#
# ##### Usage Examples
#
#     user$ file_is_missing /bin/bash
#     user$ echo $?
#     1
#
#     user$ file_is_missing /bin/asdfasdf
#     user$ echo $?
#     0
#
file_is_empty_or_missing()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "Cannot check if file is empty or missing as no file path/name was given"
  fi

  if [[ ! -f "${_file}" || ! -s "${_file}" ]]
  then
    return 0
  else
    return 1
  fi
}

#
# ## file_contains()
#
# Checks if a named file contains a given string/unix regexp pattern.
#
# ##### Input Parameters
#
# First parameter is the file name/path.
# Second parameter is the pattern to match.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the given file contains the given pattern.
# 1 if the given file does not contain the given pattern.
#
# ##### Failure Scenarios
#
# Fails if the file path/name was not given
# Fails if the pattern is not given.
# Fails if the file path/name given either does not exist or is not a file.
#
# ##### Usage Examples
#
#     user$ cat "$HOME/test"
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
#
#     modules filesystem
#
#     if file_contains "$HOME/.bdsmrc" ".*w00t.*"
#     then
#       echo "w00t! "
#     else
#       echo "no w00t :("
#     fi
#
#     user$ "$HOME/test"
#     no w00t :(
#
file_contains()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "File path/name was not given!"
  else
    shift
  fi

  local _pattern="${1:-}"
  if [[ -z "${_pattern}" ]]
  then
    fail "String pattern for search was not given!"
  fi

  if [[ ! -f "${_file}" ]]
  then
    fail "First parameter must be a file, '${_file}' does not appear to be a file."
  fi

  if grep "${_pattern}" "${_file}" >/dev/null 2>&1
  then
    return 0
  else
    return 1
  fi
}

#
# ## symlink_exists
#
# Check if a symlink name/path exists.
#
# ##### Input Parameters
#
# First parameter is a symlink name/path.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the named symlink exists.
# 1 if the named symlink does not exist or does not exist.
#
# ##### Failure Scenarios
#
# Fails if no symlink name/path was given.
#
# ##### Usage Examples
#
#     user$ symlink_exists /usr/local/bin/bdsm
#     user$ echo $?
#     0
#
#     user$ symlink_exists /bin/asdfasdf
#     user$ echo $?
#     1
#
symlink_exists()
{
  local _file="${1:-}"

  if [[ -z "${_file}" ]]
  then
    fail "Cannot check if symlink exists as no path/name was given"
  fi

  if [[ -L "${_file}" ]]
  then
    return 0
  else
    return 1
  fi
}

#
# ## directory_exists
#
# Check if a directory name/path exists.
#
# ##### Input Parameters
#
# First parameter is a directory name/path.
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the named directory exists.
# 1 if the named directory does not exist or does not exist.
#
# ##### Failure Scenarios
#
# Fails if no directory name/path was given.
#
# ##### Usage Examples
#
#     user$ directory_exists /usr/local/bin/bdsm
#     user$ echo $?
#     0
#
#     user$ directory_exists /bin/asdfasdf
#     user$ echo $?
#     1
#
directory_exists()
{
  local _directory="${1:-}"

  if [[ -z "${_directory}" ]]
  then
    fail "Cannot check if directory exists as no name/path was given"
  fi

  if [[ -d "$_directory" ]]
  then
    return 0
  else
    return 1
  fi
}

#
# ## function_name
#
# Function Description
#
# ##### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ##### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ##### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ##### Return Codes
#
# 0 if ...
# 1 if ...
#
# ##### Failure Scenarios
#
# Fails if ...
#
# ##### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
directories_in()
{
  local _path="${1:-}"

  if [[ -z "${path}" ]]
  then
    fail "Directory name/path was not given!"
  fi

  if [[ ! -d "${_path}" ]]
  then
    fail "'${_path}' is not a directory!"
  fi

  if find "${_path}" -mindepth 1 -maxdepth 1 -type d
  then
    return 0
  else
    return 1
  fi
}

directories_in_matching()
{
  local _path="${1:-}" _pattern="${2:-}"

  if [[ -z "${path}" ]]
  then
    fail "Directory name/path was not given!"
  fi

  if [[ ! -d "${_path}" ]]
  then
    fail "'${_path}' is not a directory!"
  fi

  if [[ -z "${_pattern}" ]]
  then
    fail "'${_path}' is not a directory!"
  fi

  if find "${_path}" -mindepth 1 -maxdepth 1 -type d
  then
    return 0
  else
    return 1
  fi
}

directories_under()
{
  local _path="${1:-}"

  if [[ -z "${path}" ]]
  then
    fail "Directory name/path was not given!"
  fi

  if [[ ! -d "${_path}" ]]
  then
    fail "'${_path}' is not a directory!"
  fi

  if find "${_path}" -mindepth 1 -type d
  then
    return 0
  else
    return 1
  fi
}

directories_under_matching()
{
  local _path="${1:-}"

  if [[ -z "${path}" ]]
  then
    fail "Directory name/path was not given!"
  else
    shift
  fi

  local _pattern="${1:-}"

  if [[ ! -d "${_path}" ]]
  then
    fail "'${_path}' is not a directory!"
  fi

  if [[ -z "${_pattern}" ]]
  then
    fail "'${_path}' is not a directory!"
  fi

  if find "${_path}" -mindepth 1 -iname "${_pattern}" -type d
  then
    return 0
  else
    return 1
  fi
}

#
# ## function_name
#
# Function Description
#
# ##### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ##### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ##### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ##### Return Codes
#
# 0 if ...
# 1 if ...
#
# ##### Failure Scenarios
#
# Fails if ...
#
# ##### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
files_in()
{
  local _path="${1:-}"

  if [[ -z "${path}" ]]
  then
    fail "Directory name/path was not given!"
  fi

  if [[ ! -d "${_path}" ]]
  then
    fail "'${_path}' is not a directory!"
  fi

  if find "${_path}" -mindepth 1 -maxdepth 1 -type f
  then
    return 0
  else
    return 1
  fi
}

#
# ## function_name
#
# Function Description
#
# ##### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ##### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ##### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ##### Return Codes
#
# 0 if ...
# 1 if ...
#
# ##### Failure Scenarios
#
# Fails if ...
#
# ##### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
files_under()
{
  local _path="${1:-}"

  if [[ -n "${path}" ]]
  then
    fail "Directory name/path was not given!"
  fi

  if [[ -d "${_path}" ]]
  then
    fail "'${_path}' is not a directory!"
  fi

  if find "${_path}" -mindepth 1 -type f
  then
    return 0
  else
    return 1
  fi
}

#
# ## files_in_path_matching
#
# Find all files in given path matching a given name glob pattern.
#
# ##### Input Parameters
#
# First parameter is the path to search in
# Second parameter is the pattern to match in
#
# ##### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ##### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ##### Return Codes
#
# 0 if ...
# 1 if ...
#
# ##### Failure Scenarios
#
# Fails if ...
#
# ##### Usage Examples
#
#     user$ files_in_path_matching ...
#
files_in_path_matching()
{
  local _path="${1:-}"

  if [[ -z "${path}" ]]
  then
    fail "Directory name/path was not given!"
  else
    shift
  fi

  _pattern="${1:-}"
  if [[ ! -d "${_path}" ]]
  then
    fail "'${_path}' is not a directory!"
  else
    shift
  fi

  if [[ -z "${_pattern}" ]]
  then
    fail "Cannot find files as a filename or pattern was not given."
  fi

  if find "${_path}" -mindepth 1 -iname "${_pattern}" -type f
  then
    return 0
  else
    return 1
  fi
}

#
# ## replace_content
#
# Replaces a given (sed compatable) pattern with given replacement text in a
# file.
#
# ##### Input Parameters
#
# First parameter is the pattern
# [optional 'with']
# Second parameter is the replacement content
# [optional 'in']
# Third parameter is the file name/path
#
# ##### Stream Outputs
#
# None.
#
# ##### Environmental effects
#
# The pattern will be matched against the file name/path content and the
# replacement text will be put in place.
#
# ##### Return Codes
#
# 0 for success
#
# ##### Failure Scenarios
#
# Fails if no pattern was given
# Fails if replacement content was not given
# Fails if filename was not given
# Fails if the file does not exist
#
# ##### Usage Examples
#
# # Replace contents in a file with a given (sed) regex pattern.
#
#     replace_content "^PREFIX =.*" with "${install_path}" in Makefile
#
replace_content()
{
  local _token _pattern _content _file

  while (( $# > 0 ))
  do
    _token="$1"
    shift

    case "${_token}" in
      (with)
        _content="${1:-}"
        shift
        ;;
      (in)
        _file="${1}"
        shift
        ;;
      (*)
        if [[ -z "${_pattern}" ]]
        then
          _pattern="${_token}"
        else
          fail "Unknown token '${_token}' passed as a parameter.'"
        fi
        ;;
    esac
  done

  if [[ -z "${_pattern:-}" ]]
  then
    fail "Cannot replace content as not even a pattern was given."
  fi

  if [[ -z "${_content:-}" ]]
  then
    fail "Cannot replace content as the replacement content was not given, specify by 'with \"replacement text\"'."
  fi

  if [[ -z "${_file:-}" ]]
  then
    fail "Can not file content as the filename was not given, specify by 'in \"/path/to/filename\"'"
  fi

  if [[ ! -f "${_file:-}" ]]
  then
    fail "Can not replace file content as the file does not exist."
  fi

  if sed -i -e "s#${_pattern}#${_content}#g" "${_file}"
  then
    return 0
  else
    return 1
  fi
}

#
# ## file_matches_md5
#
# Checks to see if the given file matches the given md5 sum.
#
# ##### Input Parameters
#
# None.
#
# ##### Stream Outputs
#
# none.
#
# ##### Environmental effects
#
# None.
#
# ##### Return Codes
#
# 0 if the file matches the md5sum
# 1 if the file does not match the md5sum
# 1 if the file is empty or missing
#
# ##### Failure Scenarios
#
# Fails if no file name/path was given.
# Fails if no md5 string was given.
#
# ##### Usage Examples
#
# Example Usage:
#
# user$ file_matches_md5
#
# ##### Notes
#
file_matches_md5()
{
  local _file="$1" _md5="$2" _file_md5

  if [[ -z "${_file}" ]]
  then
    fail "Cannot determine if file matches md5 as no file was given."
  fi

  if [[ -z "${_md5}" ]]
  then
    fail "Cannot determine if file matches md5 as no md5 was given."
  fi

  if [[ ! -s "${_file}" ]]
  then
    return 1
  fi

  _file_md5="$(file_md5 "${_file}")"

  if [[ "${_file_md5// *}" = "$_md5" ]]
  then
    return 0
  else
    return 1
  fi
}

extract_archive()
{
  local _archive="${1:-}"

  if [[ -z "${_archive}" ]]
  then
    fail "Cannot extract an archive to a target location as no archive was given."
  else
    shift
  fi

  local _path="${1:-}"

  case "${_archive}" in
    *.tar.gz|*.tgz) # gzip
      if ! tar zxf "${_archive}"
      then
        error "There was an error while extracting the archive '${_archive}'"
      fi
      ;;
    *tar.xz) # LZMA
      # TODO: if 'xz' command exists, use that, otherwise use tar J
      if ! tar Jxf "${_archive}"
      then
        error "There was an error while extracting the archive '${_archive}'"
      fi
      ;;
    *.tar.bz2) # bzip
      if ! tar jxf "${_archive}"
      then
        error "There was an error while extracting the archive '${_archive}'"
      fi
      ;;
    *.zip)
      if ! unzip "${_archive}" -d "${_path:-}"
      then
        error "There was an error while extracting the archive '${_archive}'"
      fi
      ;;
    *)
      error "Unknown archive format for ${_archive}"
      ;;
  esac
}

file_md5()
{
  local _file="${1:-}" _command _md5

  if [[ -z "${_file}" ]]
  then
    fail "Cannot calculate md5 of a file as no file name/path was given."
  fi

  if os_is_darwin
  then
    _command="/sbin/md5 -q"

  else
    if command_exists "md5sum"
    then
      _command="md5sum"

    elif command_exists md5
    then
      _command="md5"

    else
      error "Could not find a suitable md5 command in the path."
    fi
  fi

  if _md5="$(${_command} "$_file" 2>/dev/null)"
  then
    printf "${_md5// *}"

  else # Should this be error ?
    warn "There was an unknown error computing the md5"
    return 1
  fi
}
