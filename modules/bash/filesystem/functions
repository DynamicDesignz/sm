#!/usr/bin/env bash

#
# BDSM filesystem module DSL functions
#

# Safely source files and notify the user if they do not exist.
# Recommended to put in /etc/bash.bashrc or ~/.bashrc and be sure
# it is sourced from ~/.bash_profile
source_files()
{
  local _file

  for _file in "$@" ; do
    _file=${_file/\~\//$HOME\/} # Expand ~/ to full value of $HOME
    [[ -s "${_file}" ]] && source "${_file}"
  done
}

# safely source the first file found
nonempty_files()
{
  local _file

  for _file in "${@}" ; do
    [[ -s "$_file" ]] && printf "$_file"
  done
}

ensure_paths_exist()
{
  local _path

  for _path in "$@" ; do
    [[ -d "${_path}" ]] || mkdir -p "${_path}"
  done
}

remove_files()
{
  local _file

  for _file in "$@" ; do
    if [[ -f "${_file}" || -L "${_file}" ]] ; then
      rm -f "${_file}"
    elif [[ -d "${_file}" ]] ; then
      error "${_file} is a directory! "
    elif [[ -e "${_file}" ]] ; then
      error "Unknown entry at ${_file}, cannot remove."
    else
      true # already gone
    fi
  done
}

remove_paths()
{
  local _path

  for _path in "$@" ; do
    if [[ -f "${_path}" ]] ; then
      error "${_path} is a file! "
    elif [[ -L "${_path}" ]] ; then
      rm -f "${_path}"
    elif [[ -d "${_path}" ]] ; then
      rm -rf "${_path}"
    elif [[ -e "${_path}" ]] ; then
      error "Unknown entry at ${_path}, cannot remove."
    else
      true # already gone
    fi
  done
}

ensure_files_exist()
{
  local _file

  for _file in "$@" ; do
    [[ -e "${_file}" ]] || touch "${_file}"
  done
}

# TODO: change this to be a fail function if one is not
#       make this into make_files_executable or some such
ensure_files_are_executable()
{
  local _file="$1"

  ensure_files_exist "${_file}"

  if [[ -d "${_file}" ]] ; then
    fail "Cannot make ${_file} executable, it is a directory."
  else
    chmod +x "${_file}"
  fi
}

#
# Link files
#
# The following usages are equivalent
#
# link from /home/user/.vim/vimrc to /home/user/.vimrc
# link /home/user/.vim/vimrc to /home/user/.vimrc
# link /home/user/.vim/vimrc /home/user/.vimrc
#
link()
{
  local token _source _target _force_flag=0

  while [[ $# -gt 0 ]] ; do
    token="$1" ; shift

    case "${token}" in
      to)
        _target="${1}" ; shift
        ;;
      from)
        _source="${1}" ; shift
        ;;
      --force)
        _force_flag=1
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$token"
        elif [[ -z "${_target}" ]] ; then
          _target="$token"
        fi
        ;;
    esac
  done

  if [[ ${_force_flag} -eq 1 ]] ; then
    remove_files "${_target}"
  fi

  # TODO: What should we do if files already exist?
  if [[ -f "${_target}" ]] ; then
    error "Cannot link ${_source} to ${_target} exists and is a file!"
  elif [[ -d "${_target}" ]] ; then
    error "Cannot link ${_source} to ${_target} exists and is a directory"
  else
    ln -fs "${_source}" "${_target}"
  fi
}

rename()
{
  move "${*}"
}

move()
{
  local _source _target

  while [[ $# -gt 0 ]] ; do
    case "${1}" in
      to)
        _target="${1}"
        shift
        ;;
      from)
        _source="${1}"
        shift
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$1" ; shift
        elif [[ -z "${_target}" ]] ; then
          _target="$1" ; shift
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  mv "${_source}" "${_target}"
}

copy_files_to()
{
  local _path="$1" _file ; shift

  ensure_paths_exist "${_path}"

  for _file in "$@" ; do
    [[ -s "${_file}" ]] && cp "${_file}" "${_path}/${_file}"
  done
}

copy_directories_to()
{
  local _path="${1}" _directory ; shift

  ensure_paths_exist "${_path}"

  for _directory in "$@" ; do
    cp -Rf "${_directory}" "${_path}/"
  done
}

move_files_to()
{
  local _path="$1" _file ; shift

  ensure_paths_exist "${_path}"

  for _file in "$@" ; do
    [[ -f "${_file}" ]] && mv "${_file}" "${_path}/${_file}"
  done
}

chown_files()
{
  local _idenity="$1" _file; shift

  for _file in "${@}" ; do
    [[ -f "${_file}" ]] && chown -R ${_idenity} "${_file}"
  done
}

chown_paths()
{
  local _idenity="$1" _path; shift

  for _path in "${@}" ; do
    [[ -d "${_file}" ]] && chown -R ${_idenity} "${_path}"
  done
}

chmod_files()
{
  local _permissions="$1" _file; shift

  for _path in "${@}" ; do
    [[ -f "${_file}" ]] && chmod ${_permissions} "${_file}"
  done
}

chmod_paths()
{
  local _permissions="$1" _path; shift

  for _path in "${@}" ; do
    [[ -d "${_path}" ]] && chmod -R ${_permissions} "${_path}"
  done
}

enter()
{
  local _path="$1"

  if [[ ! -d "${_path}" ]] ; then
    fail "Could not enter directory ${_path}."
  else
    builtin cd "${_path}"
  fi
}

hash_file()
{
  [[ -f "$1" ]] || fail "db() => Usage: $0 database key [value]"

  database_file="$1" ; shift
  key="$1"           ; shift

  ensure_paths_exist $(dirname $database_file)
  ensure_files_exist "$database_file"

  [[ -n "$key" ]] || fail "usage: $0 database key [value]"

  value="$*"
  case "$value" in
    unset|delete)
      sed -i.tmp "s#^$key=.*\$##" $database_file
      ;;
    *)
      if [[ -z "$value" ]] ; then # get
        awk -F= '/^'"${key}"'=/{print $2}' "$database_file"
      else # set
        if ! awk -F= "/^'"$key"'=/{print $2}" "$database_file" >/dev/null 2>&1; then
          echo "$key=$value" >> $database_file
        else # overwrite
          sed -i.tmp "s#^$key=.*\$#$key=$value#" "$database_file"
        fi
      fi
      ;;
  esac
}

# File conditional functions
is_executable() { [[ -x "$1" ]] ; }
file_exists() { [[ -f "$1" ]] ; }
file_nonempty() { [[ -s "$1" ]] ; }
file_contains()
{
  local _file="${1}" _string="${2}"
  grep -q "${_string}" "${_file}"
}

# Directory conditional functions
directory_exists() { [[ -d "$1" ]] ; }

