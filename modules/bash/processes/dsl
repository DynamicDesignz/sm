#!/usr/bin/env bash

lockfile_lock()
{
  local _lockfile="${1:-}"

  if [[ -z "${_lockfile}" ]]
  then
    fail "Cannot lock onto a lockfile as no lockfile was specified as the first parameter."
  fi

  # The first instance that successfully writes it's pid to the lockfile 'wins'
  printf "$$" >> "${_lockfile}"

  read -r _pid < "${_lockfile}"

  if [[ "${_pid}" == "$$" ]]
  then
    # Ensure the lockfile is released on exit while preserving existing EXIT traps.
    trap "rm -f ${_lockfile};$(trap | awk '/EXIT/' | sed -e "s#' EXIT##" -e "s#.*'##")" EXIT
    return 0 # The lock has been obtained! Proceed with nefarious things!
  else # Question: Should this be an error exit code or ?
    succeed "Another process already owns the lockfile, exiting."
  fi
}

