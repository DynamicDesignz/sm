#!/usr/bin/env bash

shopt -s extglob # Extended globs

set -o errtrace

export PS4='+ ${BASH_SOURCE} : ${FUNCNAME[0]:+${FUNCNAME[0]}() } ${LINENO} '

#
# This file contains the functions that compries the BDSM framework DSL.
#
log()
{
  printf "$*\n"
  return $?
}

error()
{
  printf "\nERROR: $*\n"
}

warn()
{
  printf "\nWARNING: $*\n"
}

debug()
{
  [[ ${debug_flag:-0} -eq 1 ]] && printf "DEBUG: $*\n"
}

succeed() {
  log "\n$*\n" ; exit 0
}

fail() {
  error "$*" ; exit 1
}

# Safely source files and notify the user if they do not exist.
# Recommended to put in /etc/bash.bashrc or ~/.bashrc and be sure
# it is sourced from ~/.bash_profile
source_files()
{
  local _file

  for _file in "$@" ; do
    _file=${_file/\~\//$HOME\/} # Expand ~/ to full value of $HOME

    if [[ -s "${_file}" ]] ; then
      source "${_file}"
    else
      if [[ -e "${_file}" ]] ; then
        true # simply an empty file, no warning necessary.
      else
        printf "NOTICE: ${_file} does not exist, not loading.\n"
      fi
    fi
  done
}

# safely source the first file found
nonempty_files()
{
  local _file

  for _file in "${@}" ; do
    [[ -s "$_file" ]] && printf "$_file"
  done
}

first()
{
  printf "$1"
}

ensure_paths_exist()
{
  local _path

  for _path in "$@" ; do
    [[ -d "${_path}" ]] || mkdir -p "${_path}"
  done
}

match()
{
  local _value="$1" _regex="$2"

  shopt -s extglob

  case "${_value}" in
    ${_regex}) return 0 ;;
    *)        return 1 ;;
  esac
}

# Source bdsmrc files, cascaded.
bdsmrc()
{
  source_files \
    "/etc/bdsmrc" \
    "$HOME/.bdsmrc"
}

init_scripts_path()
{
  if [[ $UID -eq 0 ]] ; then
    if [[ -d "/etc/init.d" ]] ; then
      printf "/etc/init.d"
    elif [[ -d "/etc/rc.d" ]] ; then
      printf "/etc/rc.d"
    else
      fail "Unknown init scripts directory (/etc/init.d or /etc/rc.d not found)."
    fi
  else
    printf "$HOME/.init.d/"
  fi
}

remove_files()
{
  local _file

  for _file in "$@" ; do
    if [[ -f "${_file}" ]] ; then
      rm -f "${_file}"
    elif [[ -d "${_file}" ]] ; then
      error "${_file} is a directory! "
    elif [[ -L "${_file}" ]] ; then
      error "${_file} is a symlink! "
    fi
  done
}

ensure_files_exist()
{
  local _file

  for _file in "$@" ; do
    [[ -e "${_file}" ]] || touch "${_file}"
  done
}

#
# Link files
#
# The following usages are equivalent
#
# link from /home/user/.vim/vimrc to /home/user/.vimrc
# link /home/user/.vim/vimrc to /home/user/.vimrc
# link /home/user/.vim/vimrc /home/user/.vimrc
#
link()
{
  local _source _target

  while [[ $# -gt 0 ]] ; do
    case "${1}" in
      to|from)
        shift
        ;;

      *)
        if [[ -z "${_source}" ]] ; then
          _source="$1" ; shift
        elif [[ -z "${_target}" ]] ; then
          _target="$1" ; shift
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  # TODO: What should we do if files already exist?
  if [[ -f "${_target}" ]] ; then
    error "Cannot link ${_source} to ${_target} exists and is a file!"
  elif [[ -d "${_target}" ]] ; then
    error "Cannot link ${_source} to ${_target} exists and is a directory"
  else
    ln -fs "${_source}" "${_target}"
  fi
}

copy_files_to()
{
  local _path="$1" _file ; shift
  ensure_paths_exist "${_path}"
  for _file in "$@" ; do
    [[ -s "${_file}" ]] && cp "{$_file}" "${_path}/${_file}"
  done
}

copy_directories_to()
{
  local _path="${1}" _directory ; shift
  ensure_paths_exist "${_path}"
  for _directory in "$@" ; do
    cp -Rf "${_directory}" "${_path}/${_directory}/"
  done
}

move_files_to()
{
  local _path="$1" _file ; shift
  ensure_paths_exist "${_path}"
  for _file in "$@" ; do
    [[ -f "${_file}" ]] && mv "${_file}" "${_path}/${_file}"
  done
}

chown_paths()
{
  local _idenity="$1" _path; shift
  for _path in "${@}" ; do
    chown -R ${_idenity} "${_path}"
  done
}

install_template()
{
  local _name _target _source

  while [[ $# -gt 0 ]] ; do
    case "${1}" in
      to)
        shift ; _target="$1" ; shift
        ;;
      from)
        shift ; _source="$1" ; shift
        ;;

      *)
        if [[ -z "${_name}" ]] ; then
          _name="$1" ; shift
        elif [[ -z "${_target}" ]] ; then
          _target="$1" ; shift
          break # When we have a target we are done.
          # An alternative idea would be to allow an array of multiple targets
          # to symlink to...
        fi
        ;;
    esac
  done

  local _template="${extension_templates_path}/${_template}.template"

  ensure_paths_exist "$(dirname "${_target}")"

  if [[ -f "${_template}" ]] ; then
    if [[ -d "${_target}" ]] ; then
      fail "${_target} is a directory, cannot install template ${_name}"
    else
      cp -f "${_template}" "${_target}"
    fi
  else
    fail "Template missing: #{_template}"
  fi
}

[[ ${trace_flag:-0} -eq 1 ]] && set -o xtrace
[[ ${debug_flag:-0} -eq 1 ]] && set -o verbose

