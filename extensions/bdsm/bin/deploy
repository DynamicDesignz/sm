#!/usr/bin/env bash

if [[ "$trace_flag" -eq 1 ]] ; then set -x ; fi
if [[ -s "/etc/bdsmrc" ]]    ; then source "/etc/bdsmrc" ; fi
if [[ -s "$HOME/.bdsmrc" ]]  ; then source "$HOME/.bdsmrc" ; fi

# TODO:
#
#   * Crank up the verbosity on errors
#
hook() {
  if [[ "$hooks_flag" -ne 0 ]] ; then
    # Server Level
    if [[ -s "$shared_path/config/deploy/$1" ]] ; then
      source "$shared_path/config/deploy/$1"
    fi

    # Project Level
    if [[ -d "$shared_path/$project" ]] ; then
      if [[ -x "$shared_path/$project/config/deploy/$1" ]] ; then
        "$shared_path/$project/config/deploy/$1"
      elif [[ -x "$shared_path/$project/.$1" ]] ; then
        "$shared_path/$project/.$1"
      fi
    fi
  fi
}

update() {
  update_repository && update_current
  return $?
}

update_repository() {
  $scripts_path/log "info" "Updating local repository in $shared_path/$project."

  builtin cd "$shared_path/$project" > /dev/null 2>&1

  if [[ "git" = "$scm" ]] ; then
    git checkout master -f -q
    git reset --hard HEAD 2>/dev/null # There should be *no* changes to the pristine repo.

    #current_branch=$(git branch | awk '/\* /{print $2}')

    $scripts_path/log "info" "Pulling updates from $remote"
    git fetch $remote

    $scripts_path/log "info" "Switching to branch $branch"
    if [[ -z "$(git branch | awk "/$branch$/")" ]] ; then
      git checkout -b $branch --track $remote/$branch 2>/dev/null
    elif [[ -z "$(git branch | awk "/\* $branch$/")" ]] ; then
      git checkout $branch 2>/dev/null
      if [[ $? -gt 0 ]] ; then
        $scripts_path/log "error" "Branch $remote/$branch not found. Skipping remainder of update."
        return 1
      fi
    else
      $scripts_path/log "info" "Already on branch '$branch'."
    fi
    git pull

    if [[ ! -z "$revision" ]] ; then
      git checkout $revision >/dev/null 2>&1
    fi

    if [[ -f .gitmodules ]] ; then
      $scripts_path/log "info" "Updating submodules."
      git submodule init 2>/dev/null
      git submodule update
    fi

  elif [[ "hg" = "$scm" ]] ; then
    hg pull
    if [[ ! -z "$revision" ]] ; then
      hg update $branch $revision # TODO: Find out if this is how it's done for hg ;)
    else
      hg update $branch
    fi
  elif [[ "svn" = "$scm" ]] ; then
    # TODO: specific revision / branch handling
    if [[ "$revision" -gt 0 ]] ; then
      svn update
      svn checkout -r $revision
    else
      svn update
    fi
  else
    $scripts_path/log "warn" "No scm specified found (git,hg,svn)"
    exit 1
  fi
}

update_current() {
  if [ -d $current_path ] ; then
    $scripts_path/log "info" "Moving aside previous release."
    mkdir -p $project_path/previous
    mv $current_path $project_path/previous/$timestamp
  fi
  $scripts_path/log "info" "Installing new release to $current_path"
  rsync -ag --exclude=".${scm}/*" $shared_path/$project/ $current_path;
  mkdir -p $current_path/public
}

configure() {
  if [[ ! -d "$current_path/config" ]] ; then mkdir -p "$current_path/config" ; fi

  builtin cd $shared_path/config
  $scripts_path/log "info" "Setting up persistent yaml files:"
  for yaml_file in *.yml; do
    $scripts_path/log "info" " - $yaml_file"
    rm -f $current_path/config/$yaml_file
    ln -nfs $shared_path/config/$yaml_file $current_path/config/$yaml_file
  done

  $scripts_path/log "info" "Setting up persistent config files:"
  for config_file in $(ls $shared_path/config/*.conf 2>/dev/null); do
    file_name=$(basename $config_file)
    $scripts_path/log "info" " - $file_name"
    rm -f $current_path/config/$file_name
    ln -nfs $shared_path/config/$file_name $current_path/config/$file_name
  done

  $scripts_path/log "info" "Setting up persistent ruby config files:"
  for config_file in $(ls $shared_path/config/*.rb 2>/dev/null); do
    file_name=$(basename $config_file)
    $scripts_path/log "info" " - $file_name"
    rm -f $current_path/config/$file_name
    ln -nfs $shared_path/config/$file_name $current_path/config/$file_name
  done
}

symlink() {
  $scripts_path/log "info" "Setting up persistent directories"

  for dir in tmp log pids files ; do
    if [[ -d $shared_path/$dir ]] ; then
      $scripts_path/log "info" " - $dir"
      rm -rf $current_path/$dir
      ln -nfs $shared_path/$dir $current_path/$dir
    else
      $scripts_path/log "info" "<i> $shared_path/$dir does not exist, skipping."
    fi
  done

  for dir in $(ls -A $shared_path/public/) ; do
    if [[ ! -z "$dir" ]] ; then
      $scripts_path/log "info" " - public/$dir"
      rm -rf $current_path/public/$dir
      ln -nfs $shared_path/public/$dir $current_path/public/$dir
    fi
  done
}

cleanup() {
  mkdir -p $project_path/previous
  if [[ ! -z "$old_releases" ]] ; then
    $scripts_path/log "info" "Removing old releases..."
    builtin cd $project_path/previous
    for release in $(echo $old_releases) ; do
      if [[ -d "$release" ]] ; then
        $scripts_path/log "info" " - $release"
        rm -rf $release
      else
        $scripts_path/log "info" "info" "Skipping ~/previous/$release as the directory does not exist."
      fi
    done
    cd
  fi
}

detect_scm() {
  if [[ -z "$scm" ]] ; then
    if [[ -d "$shared_path/$project/.git" ]] ; then
      scm="git"
    elif [[ -d "$shared_path/$project/.svn" ]] ; then
      scm="svn"
    elif [[ -d "$shared_path/$project/.hg" ]] ; then
      scm="hg"
    fi
  fi
}

detect_scm

$scripts_path/log "info" "info" "Deploying..."
(
  update_repository ; hook "before_deploy"
  update_current    ; hook "after_update_current"
  configure         ; hook "after_configure"
  symlink           ; hook "after_symlink"
  cleanup           ; hook "after_deploy"
)
result=$?

$scripts_path/log "info" "info" "Deploy started at $timestamp and completed at $(date +%m.%d.%Y-%H:%M:%S)"

exit $result
