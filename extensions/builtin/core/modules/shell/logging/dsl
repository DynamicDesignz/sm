#!/usr/bin/env bash

log()
{
  printf "$*\n"
}

debug()
{
  if (( ${debug_flag:=0} >= 1 ))
  then
    printf "DEBUG: $*\n"
  fi
}

fail()
{
  printf "FAIL: $*\n"
}

#
# ## set_ps4()
#
# Set the environmental PS4 variable for informative tracing.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ echo "'$PS4'"
#     '+ '
#     user$ set_ps4
#     user$ echo "'$PS4'"
#     ' > ${BASH_SOURCE##${bdsm_path}\/} ${FUNCNAME[0]:+${FUNCNAME[0]}()} ${LINENO} $ '
#
# ### Code Walkthrough
set_ps4()
{
  # Set the PS4 variable. Then export the PS4 variabel so that this script and
  # called bash scripts will display a more detailed and formatted trace output.
  # Finally return true, 0, for success.
  PS4="# \${BASH_SOURCE##\${bdsm_path}\/extensions\/} \${FUNCNAME[0]:+\${FUNCNAME[0]}()} \${LINENO} $ "
  export PS4
  return 0
}

#
# ## trace()
#
# Toggle tracing functionality on or off. If 'on' is triggered then every line
# of code execution after the function returns will be displayed in the format
# specified by the PS4 environment variable (see set_ps4).
#
# ### Input Parameters
#
# First parameter is either empty, 'on' or 'off'
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ trace on
#     user$ echo "hi"
#     >   1 $ echo hi
#     user$ trace off
#     >  trace() 1 $ local _option=off
#     >  trace() 3 $ [[ off = \o\n ]]
#     >  trace() 8 $ set +o xtrace
#
# ### Code Walkthrough
trace()
{
  # Declare the option varibale and set it to the first parameter, if nonempty,
  # and to 'on' if no parameters were given.
  local _option="${1}"

  # If the option is on (default) then Set the trace_flag to 1, export
  # trace_flag and then turn on shell tracing.  Otherwise turn off shell
  # tracing, set the trace_flag to 0 and export it.
  if [[ "${_option}" = "on" ]]
  then
    trace_flag=1
    export trace_flag
    set -o xtrace
  else
    set +o xtrace
    trace_flag=0
    export trace_flag
  fi
}

#
# ## enable_trace()
#
# Turns tracing on.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ enable_trace
#
# ### Code Walkthrough
enable_trace()
{
  # Enable shell tracing
  trace on
}

#
# ## disable_trace()
#
# Turns tracing off.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No current failure scenarios.
#
# ### Usage Examples
#
#     user$ disable_trace
#
# ### Code Walkthrough
disable_trace()
{
  # Disable shell tracing
  trace off
}

#
# ## debug()
#
# Toggle verbose debugging functionality on or off. If 'on' is triggered then
# every line of code execution after the function returns will be displayed.
#
# ### Input Parameters
#
# First parameter is either empty, 'on' or 'off'
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ debug on
#     user$ echo "hi"
#     >   1 $ echo hi
#     user$ debug off
#     >  debug() 1 $ local _option=off
#     >  debug() 3 $ [[ off = \o\n ]]
#     >  debug() 8 $ set +o xdebug
#
# ### Code Walkthrough
debug()
{
  # Declare the option varibale and set it to the first parameter, if nonempty,
  # and to 'on' if no parameters were given.
  local _option="${1:-on}"

  # If the option variable is set to on (the default) then set and export the
  # debug_flag variable to 1 (enable) thus enabling verbose shell echoing
  # (every code line is printed before execution). Otherwise disable verbose
  # shell echoing, set debug_flag to 0 (disabled) and export
  if [[ "${_option}" = "on" ]]
  then
    export debug_flag=1
    set -o verbose
  else
    set +o verbose
    debug_flag=0
    export debug_flag
  fi
}

#
# ## enable_debug()
#
# Enables verbose debugging output.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ enable_debug
#
# ### Code Walkthrough
enable_debug()
{
  # Turn debugging on.
  debug on
}

#
# ## disable_debug()
#
# Disables verbose debugging output.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ disable_debug
#
# ### Code Walkthrough
disable_debug()
{
  # Turn debugging off
  debug off
}

#
# ## enable_backtrace()
#
# Enables backtrace and program exit whenever a command returns a nonzero value
# that is not handled.
#
# ### Input Parameters
#
# First parameter is optional. If it is passed it is a message that will be
# outputed when a command trigger the program to error exit.
#
# ### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ cat ./test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/extensions/builtin/core/modules/shell/core/initialize" # Load BDSM framework core.
#     modules trace # Load the trace module.
#     enable_backtrace
#     echo "Error exit with backtrace is now off."
#     false # Does not cause exiting with backtrace printing.
#
#     user$ $PWD/test
#     Error exit with backtrace is on.
#     ERROR: A command has returned an unhandled error code (nonzero return value).
#     Error Backtrace:
#        Trace   Function           Line  File
#           1.   main()                7  /Users/wayneeseguin/test
#
# ### Code Walkthrough
enable_backtrace()
{
  # Declare a message local variable and set it to the first parameter or empty
  # string if the first paramter was not passed in.
  local _message="${1:-}"

  # If the message variable is not empty then enable the backtrace with the
  # message attached to the backtrace call. Otherwise enable the backtrace with
  # no message attached to the backtrace call.
  # Then turn on shell exit on error option.
  if [[ -n "${_message}" ]]
  then
    trap "backtrace \"${_message}\"" ERR
  else
    trap "backtrace \"A command has returned an unhandled error code (nonzero return value).\"" ERR
  fi
  set -o errexit
}

#
# ## function_name()
#
# Function Description
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ cat ./test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/extensions/builtin/core/modules/shell/core/initialize" # Load BDSM framework core.
#     modules trace # Load the trace module.
#     disable_backtrace
#     echo "Error exit with backtrace is now off."
#     false # Does not cause exiting with backtrace printing.
#
#     user$ ./test
#     Error exit with backtrace is now off.
#
# ### Code Walkthrough
disable_backtrace()
{
  # Turn off shell error exit option and clear all ERR signal traps.
  set +o errexit
  trap - ERR
}

#
# ## backtrace()
#
# Display a backtrace of the current call stack to the point that backtrace was
# called from. Currently trace is turned on as well so that execution after
# calling backtrace is traced.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# The call stack up to the current point of execution is printed to STDOUT of
# the calling environment.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ cat ./test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/extensions/builtin/core/modules/shell/core/initialize" # Load BDSM framework core.
#     modules trace # Load the trace module.
#
#     functiona()
#     {
#       echo "function a"
#       functionb
#       echo "function a"
#     }
#
#     functionb()
#     {
#       echo "function b"
#       functionc
#       echo "function b"
#     }
#
#     functionc()
#     {
#       echo "function c"
#       backtrace
#       echo "function c"
#     }
#
#     functiona
#
#     user$ $PWD/test
#     function a
#     function b
#     function c
#     Error Backtrace:
#        Trace   Line Function             File
#           4.     25 functionc()          /Users/wayneeseguin/test
#           3.     18 functionb()          /Users/wayneeseguin/test
#           2.     11 functiona()          /Users/wayneeseguin/test
#           1.     29 main()               /Users/wayneeseguin/test
#      > /Users/wayneeseguin/test functionc() 26 $ echo 'function c'
#     function c
#      > /Users/wayneeseguin/test functionb() 19 $ echo 'function b'
#     function b
#      > /Users/wayneeseguin/test functiona() 12 $ echo 'function a'
#     function a
#
# ### Code Walkthrough
backtrace()
{
  # Turn off shell tracing
  set +o xtrace

  # Declare separator and columns variables. Initialize columns to the terminal
  local _separator _columns

  # If setting the columns via tput does not work then default the columns to 80
  if ! _columns=$(tput cols)
  then
    _columns=80
  fi

  # Set the separator variable contents to the separator filled out to the
  # number of columns.
  printf -v _separator '%*s' "${_columns:-${COLUMNS:-80}}"

  # Store the passed in message, if given as the first parameter, in the
  # message variable, default to empty string.
  local _message="${1:-}"

  # If a message was given print the message to the calling environment's STDERR
  if variable_is_nonempty _message
  then
    printf "\n${_message}\n\n" >&2
  fi

  # Declare function local variables
  local _source _function _line _index _largest _format _digits _longest

  # Loop over the function names in the function array stack to determine
  # which has the longest length.
  # Note that we do not use array_largest here as we are in an error function.
  for (( _index=0 ; _index < ${#FUNCNAME[@]} ; _index++ ))
  do
    # For each function name in the stack if the function name is longer than
    # the length of current largest then
    if (( ${#FUNCNAME[${_index}]} > ${#_largest} ))
    then
      # set it as the new largest element
      _largest=${FUNCNAME[${_index}]}
    fi
  done

  # Loop over the bash source files array in order to determine
  # which has the the longest length.
  # Note that we do not use array_largest here as we are in an error function.
  for (( _index=0 ; _index < ${#BASH_SOURCE[@]} ; _index++ ))
  do
    # For each source file in the source files array, if the file name/path
    # is longer than the current longest then set it as the new longest element
    if (( ${#BASH_SOURCE[${_index}]} > ${#_longest} ))
    then
      _longest=${BASH_SOURCE[${_index}]}
    fi
  done

  for (( _index=0 ; _index < ${#BASH_LINENO[@]} ; _index++ ))
  do
    # For each line number in the line numbers array, if the number of digits
    # is longer than the current longest digits then set it as the new largest
    if (( ${#BASH_LINENO[${_index}]} > ${#_digits} ))
    then
      _digits=${BASH_LINENO[${_index}]}
    fi
  done

  # Determine the format string output for the backtrace based on the users
  # set editor. If an editor has not been set, default the editor variable to
  # the pager or empty string.
  case "${EDITOR:=${PAGER:-}}" in
    (mvim*|mate*)
      # Set the format based on GUI editing tools format for opening
      # a file to a given line using a file URI.
      _format="%-60s # %-$((${#_largest} + 2))s \n"
      # Print the backtrace header to the calling environment's STDERR
      printf "${_format}" "Source" "function()"  1>&2
      ;;
    (vi*|gvim*|emacs*|*)
      # Set the format based on the console editing tools format for opening
      # a file to a given line.
      # _format="%-$((${#_largest} + 2))s $ %${#EDITOR}s +%-$((${#_digits}))s %-$((${#_longest} + 2))s %s\n"
      _format="%${#EDITOR}s +%-$((${#_digits}))s %-$((${#_longest} + 2))s # %s %-$((${#_largest} + 2))s\n"
      # Print the backtrace header to the calling environment's STDERR
      printf "${_format}" ' ' "#" "source file" "function()"  1>&2
      ;;
  esac

  # Print the backtrace separator line.
  printf "${_separator// /=}\n" 1>&2

  # Iterate over the functions array stack skipping this backtrace function [0]
  for (( _index=1 ; _index < ${#FUNCNAME[@]} ; ++_index ))
  do
    _source="${BASH_SOURCE[${_index}]}"
    _function="${FUNCNAME[${_index}]:+${FUNCNAME[${_index}]}()}"
    _line=${BASH_LINENO[$(( _index - 1 ))]}

    case "$_function" in
      fail\(\)|error\(\)|command_not_found_handle\(\)|command_not_found\(\))
        continue
        ;;
    esac

    # Determine the format string output for the backtrace based on the users
    # set editor. Note that if an editor was not set then previously we have
    # defualted it to the pager. If no pager is set we simply output a standard
    # unix utility trace line.
    case "${EDITOR:-}" in
      # Print with the format and content for GUI editing tools a file to open a
      # given line using a URI. print backtrace to calling environment's STDERR
      (mvim*|mate*)
        printf "${_format}" "open ${EDITOR// *}://open?url=file://${_source}&line=${_line}" "${_function}" 1>&2
        ;;
      # Print with the format and content for console editing tools a to open a
      # file to a given line print backtrace to calling environment's STDERR
      (vi*|gvim*|emacs*|*)
        printf "${_format}" "${EDITOR}" "${_line}" "${_source} " "${_function}" 1>&2
        ;;
    esac
  done

  # Print the backtrace separator line and if the trace flag is nonnegative
  # then turn tracing back on
  printf "${_separator// /=}\n" 1>&2

  if (( trace_flag > 0 ))
  then
    enable_trace
  fi
}

