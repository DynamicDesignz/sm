#!/usr/bin/env bash

# Author: Wayne E. Seguin
# See bdsm LICENSE file for license information.

shopt -s extglob # Extended globs

# Load System Configuration, if it exists.
[[ -s "/etc/bdsmrc" ]] && . /etc/bdsmrc

# Load User Configuration, if it exists.
[[ -s "$HOME/.bdsmrc" ]] && . "$HOME/.bdsmrc"

# The default prefix is /usr/local,
# this should be set to where BDSM is installed to in /etc/bdsmrc
prefix="${prefix:-/usr/local}"
bindir="${bindir:-/usr/local/bin}"

if [[ "$prefix" = "$HOME" ]] ; then
  true "${bdsm_path:="${prefix}bdsm"}"
else
  true "${bdsm_path:="${prefix}/bdsm"}"
fi

export scripts_path="${scripts_path:-"${bdsm_path}/scripts"}"

# Load BDSM bash helper functions
source "${scripts_path}/bash/bdsm"

# Initialize BDSM framework and variables and functions.
source_files "${scripts_path}/initialize" "${scripts_path}/functions"

# Load the BDSM framework version.
[[ -s "$bdsm_path/VERSION" ]] && VERSION="$(cat "$bdsm_path/VERSION")"

user="$USER"

#
# parse args
#
while [[ $# -gt 0 ]] ; do

  token="$1" ; shift

  case "$token" in
    # TODO: extension detection "did you mean"

    # TODO: Fall back on default actions instead of specifying them here
    #       In case the user has set their default serfice in the environment.

    deploy|rollback)
      extension="deploy"
      action="$token"
      parse_break=1
    ;;

    bdsmrc)
      extension="bdsm"
      action="$token"
      parse_break=1
    ;;

    help)
      action="help"
      if [[ -n "$1" ]] ; then
        extension="$1"
        parse_break=1
      fi
    ;;

    exten*)            extension="extension"           ;;
    --disable-hooks)   hooks_flag=0                    ;;
    --project)         project="$1"            ; shift ;;
    --environment)     environment="$1"        ; shift ;;
    --repo|repository) repository="$1"         ; shift ;;
    --revision)        revision="$1"           ; shift ;;
    --user)            user="$1"               ; shift ;;
    --head)            head_flag=1                     ;;
    --debug)           debug_flag=1                    ;;
    --trace)           trace_flag=1 ; debug_flag=1     ;;
    -v|--version)      action="version"                ;;

    --) args="$@" # Stop processing arguments.
      ;;

    *)
      #if $scripts_path/match "$token" $extensions ; then
      if [[ -z "$extension" ]] ; then
        if [[ -d "$extensions_path/$token" ]] ; then
          extension="$token"
        else
          extension="${extension:-bdsm}"
        fi
      fi

      if [[ -z "$action" ]] ; then
        if [[ -x "$extensions_path/$extension/bin/$token" ]] ; then
          action="$token"
          parse_break=1
        fi
      elif [[ -d "/data/$token" ]] ; then
        project="$token"
        project_path="/data/$token"
      elif [[ -d "/home/$token" ]] ; then
        project="$token"
        project_path="/home/$token"
      else
        # determine sanity of project
        action="error"
        error_message="Unrecognized command line argument(s): '$token $@'"
      fi
    ;;
  esac

  if [[ -n "$parse_break" || -n "$error_message" ]] ; then
    unset parse_break
    break
  fi

done

[[ -n "$error_message" ]] && fail "$error_message"

#
# Main Logic
#
if [[ ${trace_flag:-0} -eq 1 ]] ; then

  export trace_flag
  set -o xtrace

elif [[ ${debug_flag:-0} -eq 1 ]] ; then

  export debug_flag
  set -o verbose

fi

if [[ "version" = "$action" ]] ; then
  version
elif [[ -n "$extension" && -n "$action" ]] ; then

  if [[ -s "$extensions_path/$extension/bin/$action" ]] ; then
    extension_path="$extensions_path/$extension"
    extension_config_path="$extensions_path/$extension/config"
    extension_templates_path="$extensions_path/$extension/templates"
    extension_scripts_path="$extensions_path/$extension/scripts"
    extension_bin_path="$extensions_path/$extension/bin"

    paths=$(env | awk -F= -v ORS=' ' '/_path/{print $1}')
    flags=$(env | awk -F= -v ORS=' ' '/_flag/{print $1}')

    export action args bdsm_path bindir database debug_flag environment error_message extension extension_bin_path extension_config_path extension_path extension_scripts_path extension_templates_path flags head_flag hooks_flag parse_break paths prefix project project_path repository result revision scripts_path trace_flag user

    cd "$extensions_path/$extension" > /dev/null 2>&1

    action_file="$extensions_path/$extension/bin/$action"
    action_file_type="$(file "$action_file")"

    case "$action_file_type" in
      *sh script*|*POSIX shell*|*Bourne-Again*)
        action_type="bash"
        ;;

      *ASCII*)
        # Launch with helper functions, if possible.
        extension="${action_file//.}"
        case "${extension}" in
          bash|sh) action_type="bash" ;;
          #rb) action_type="ruby"   ;;
          *)
            if [[ -x "${action_file}" ]] ; then
              action_type="binary"
            else
              action_type="not executable"
            fi
            ;;
        esac
        result=$?
        ;;

      cannot open)
        action_type="dne"
        ;;

      *)
        if [[ -x "${action_file}" ]] ; then
          action_type="binary"
        else
          action_type="noexec"
        fi
        ;;
    esac

    case "${action_type}" in
      bash)
        (
        source_files \
          "${scripts_path}/bash/bdsm" \
          "${extension_scripts_path}/initialize"

        . "$action_file"
        )
        ;;
      # ruby|python|lua|javascript)
      #   # ADD "${scripts_path}/${action_type}/" to the lib path so the script can require "bdsm"
      #  "${action_file}"
      #  ;;
      dne|noexec)
        fail "processing ${action} failed, does not exist or is not executable."
        ;;
      binary|*)
        "${action_file}"
        ;;
    esac
  fi
elif [[ -n "$extension" ]] ; then
  echo $(actions_for_extension $extension)
else
  usage
fi
result=$?

if [[ ${verbose_flag:-0} -eq 1 ]]; then
  if [[ ${result} -gt 0 ]] ; then
    log "'$action $*' returned error ($result)\n\n"
  else
    log "'$action $*' returned success ($result)\n\n"
  fi
fi

exit $result
