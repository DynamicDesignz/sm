#!/usr/bin/env bash

# Author: Wayne E. Seguin
# See BDSM LICENSE file for Apache 2.0 license information.

# Load System then User Configuration, if exists.
[[ -s "/etc/bdsmrc" ]] && . /etc/bdsmrc
[[ -s "$HOME/.bdsmrc" ]] && . "$HOME/.bdsmrc"

# In case bdsm is being called from within a hook for example, we unset these:
unset extension action

# The default prefix is /usr/local,
# this should be set to where BDSM is installed to in /etc/bdsmrc
prefix="${prefix:-/usr/local}"

if [[ "$prefix" = "$HOME" ]] ; then
  true "${bdsm_path:="${prefix}bdsm"}"
else
  true "${bdsm_path:="${prefix}/bdsm"}"
fi

true "${modules_path:="${bdsm_path}/modules"}"

export initial_pwd="$PWD" # record this early on.

# Load BDSM bash DSL functions and initialize for BDSM core itself manually.
source "${modules_path}/bash/bdsm/functions"
source "${modules_path}/bash/bdsm/initialize"

# Load the BDSM framework version.
[[ -s "$bdsm_path/VERSION" ]] && VERSION="$(cat "$bdsm_path/VERSION")"

user="$USER"


#
# parse args
#
while [[ $# -gt 0 ]] ; do

  token="$1" ; shift

  case "$token" in
    # TODO: extension detection "did you mean"

    # TODO: Fall back on default actions instead of specifying them here
    #       In case the user has set their default serfice in the environment.

    deploy|rollback)
      extension="deploy"
      action="$token"
      parse_break=1
    ;;

    bdsmrc)
      extension="bdsm"
      action="$token"
      parse_break=1
    ;;

    help)
      action="help"
      extension="${1:-bdsm}"
      parse_break=1
    ;;

    get)
      extension="bdsm"
      action="get"
      extension_args=("@")
      parse_break=1
    ;;

    --disable-hooks)   hooks_flag=0                    ;;
    --project)         project="$1"            ; shift ;;
    --environment)     environment="$1"        ; shift ;;
    --repo|repository) repository="$1"         ; shift ;;
    --revision)        revision="$1"           ; shift ;;
    --user)            user="$1"               ; shift ;;
    --head)            head_flag=1                     ;;
    --debug)           debug_flag=1                    ;;
    -v|--version)      action="version"                ;;
    --trace)
      trace_flag=1
      source "${modules_path}/bash/trace/initialize"
      ;;

    ext*)
      extension="extension"
      ;;

    --) extension_args=("$@") # Stop processing arguments.
      ;;

    *)
      #if $modules_path/match "$token" $extensions ; then
      if [[ -z "$extension" ]] ; then
        if [[ -d "$extensions_path/$token" ]] ; then
          extension="$token"
        else
          extension="${extension:-bdsm}"
        fi
      fi

      if [[ -z "$action" ]] ; then
        if [[ -x "$extensions_path/$extension/bin/$token" ]] ; then
          action="$token"
          extension_args=("$@")
          parse_break=1
        fi
      elif [[ -d "/data/$token" ]] ; then
        project="$token"
        project_path="/data/$token"
      elif [[ -d "/home/$token" ]] ; then
        project="$token"
        project_path="/home/$token"
      else
        # determine sanity of project
        action="error"
        error_message="Unrecognized command line argument(s): '$token $@'"
      fi
    ;;
  esac

  if [[ -n "$parse_break" || -n "$error_message" ]] ; then
    unset parse_break
    break
  fi

done

[[ -n "$error_message" ]] && fail "$error_message"

#
# Main Logic
#
if [[ -n ${extension} ]] ; then
  if [[ "${action}" = "version" ]] ; then
    extension_version "${extension}" "${action}"
  elif [[ -n "${action}" ]] ; then
    extension_action "${extension}" "${action}"
  else
    log "$(actions_for_extension $extension)"
  fi
else
  usage
fi
result=$?

if [[ ${verbose_flag:-0} -eq 1 ]]; then
  if [[ ${result} -gt 0 ]] ; then
    log "'$action $*' returned error ($result)\n\n"
  else
    log "'$action $*' returned success ($result)\n\n"
  fi
fi

exit $result
