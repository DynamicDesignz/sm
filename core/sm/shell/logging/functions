#!/bin/sh

#
# SM Framework Core Module ~ Logging (logging)
#
log()
{
  local _token _command _message=()

  while (( $# ))
  do
    _token="$1"
    case "${_token}" in
      (eval|search|todo|warn|debug|error|succeed|step)
        _command="${_token}"
        ;;
      (*)
        _message+=("$@{_token}")
        ;;
      else
    esac
  done

  if [[ -n "${_command}" ]]
  then
    __sm.log.${_command} "${_message[@]}"
  else
    __sm.log.log "${_message[@]}"
  fi
}

log_search()
{
  printf "log_search is depreciated, use 'log search instead'\n" >&2
  __sm.log.search "$@"
}

todo()
{
  printf "todo is depreciated, use 'log todo instead'\n" >&2
  __sm.log.todo "$@"
}

warn()
{
  printf "warn is depreciated, use 'log warn instead'\n" >&2
  __sm.log.warn "$@"
}

debug()
{
  printf "debug is depreciated, use 'log debug instead'\n" >&2
  __sm.log.debug "$@"
}

error()
{
  printf "error is depreciated, use 'log __sm.log.error instead'\n" >&2
  __sm.log.error "$@"
}

succeed()
{
  printf "succeed is depreciated, use 'log succeed instead'\n" >&2
  __sm.log.succeed "$@"
}

fail()
{
  printf "fail is depreciated, use 'log __sm.log.fail instead'\n" >&2
  __sm.log.fail "$@"
}

log_step()
{
  printf "log_step is depreciated, use 'log step instead'\n" >&2
  __sm.log.step "$@"
}

trace_filter()
{
  set +o xtrace
  if [[ -n "$1" ]]
  then
    if [[ -n "${BASH_VERSION}" ]]
    then
      __sm.log.trace.filter start $state "${FUNCNAME[1]}=$1"
    elif [[ -n "${ZSH_VERSION}" ]]
    then
      __sm.log.trace.filter start $state "${funcstack[2]}=$1"
    fi
  else
    __sm.log.trace.filter stop $state "${trace_filter_stack[@]}"
  fi
}

# Examples
#
#     user$ cat ./test
#     #!/bin/sm
#     modules api/trace # Load the trace module.
#
#     functiona()
#     {
#       echo "function a"
#       functionb
#       echo "function a"
#     }
#
#     functionb()
#     {
#       echo "function b"
#       functionc
#       echo "function b"
#     }
#
#     functionc()
#     {
#       echo "function c"
#       backtrace
#       echo "function c"
#     }
#
#     functiona
#
#     user$ $PWD/test
#     function a
#     function b
#     function c
#     __sm.log.error Backtrace:
#        Trace   Line Function             File
#           4.     25 functionc()          /Users/sm/test
#           3.     18 functionb()          /Users/sm/test
#           2.     11 functiona()          /Users/sm/test
#           1.     29 main()               /Users/sm/test
#      > /Users/sm/test functionc() 26 $ echo 'function c'
#     function c
#      > /Users/sm/test functionb() 19 $ echo 'function b'
#     function b
#      > /Users/sm/test functiona() 12 $ echo 'function a'
#     function a
#
# ### Code Walkthrough
backtrace()
{
  trace_filter backtrace # backtrace is disabled by default.

  local _separator _columns _stack _trace _message _flag _source _function _line \
    _index _largest _format _digits _longest


  if [[ -n "${BASH_VERSION}" ]]
  then
    _stack=(${FUNCNAME[@]})
    _trace=(${BASH_SOURCE[@]})
  elif [[ -n "${ZSH_VERSION}" ]]
  then
    _stack=(${funcstack[@]})
    _trace=(${functrace[@]})
  fi

  _columns=$(tput cols 2>/dev/null || echo 80)

  printf -v _separator '%*s' "${_columns:-${COLUMNS:-80}}"

  _message="${1:-}" _flag="$2"

  [[ -z ${_message} ]] || printf "\n${_message}\n\n" >&2

  # Loop over the function names in the function array stack, to determine
  # which is longest.
  # Note that we do not use array largest here, as we are inside an __sm.log.error function.
  for (( _index=0 ; _index < ${#_stack[@]} ; _index++ ))
  do
    # For each function name in the stack, if the function name is longer than
    # the current largest, then...
    if (( ${#_stack[${_index}]} > ${#_largest} ))
    then
      # ...set it as the new largest element.
      _largest=${_stack[${_index}]}
    fi
  done

  # Loop over the bash source files array, to find the longest element.
  # Note that we do not use array largest here, as we are in an __sm.log.error function.
  for (( _index=0 ; _index < ${#BASH_SOURCE[@]} ; _index++ ))
  do
    # For each source file in the source files array, if the file name/path
    # is longer than the current longest, then set it as the new longest element.
    (( ${#BASH_SOURCE[${_index}]} <= ${#_longest} )) ||
      _longest=${BASH_SOURCE[${_index}]}
  done

  for (( _index=0 ; _index < ${#BASH_LINENO[@]} ; _index++ ))
  do
    # For each line number in the line numbers array, if the number of digits
    # is greater than the current longest digits, then set it as the new largest.
    (( ${#BASH_LINENO[${_index}]} <= ${#_digits} )) ||
      _digits=${BASH_LINENO[${_index}]}
  done

  # Determine the format string output for the backtrace, based on your
  # set editor. If you haven't set an editor, SM defaults the editor variable to
  # the pager, or to empty string.
  case "${EDITOR:="vi"}" in
    (mvim*|mate*)
      # Set the format based on GUI editing tools format for opening
      # a file to a given line using a file URI.
      _format="%-60s # %-$((${#_largest} + 2))s \n"
      # Print the backtrace header to the calling environment's STDERR
      printf "${_format}" "Source" "function()"  1>&2
      ;;
    (vi*|gvim*|emacs*|*)
      # Set the format based on the console editing tools format for opening
      # a file to a given line.
      # _format="%-$((${#_largest} + 2))s $ %${#EDITOR}s +%-$((${#_digits}))s %-$((${#_longest} + 2))s %s\n"
      _format="%${#EDITOR}s +%-$((${#_digits}))s %-$((${#_longest} + 2))s # %s %-$((${#_largest} + 2))s\n"
      # Print the backtrace header to the calling environment's STDERR.
      printf "${_format}" ' ' "#" "source file" "function()"  1>&2
      ;;
  esac

  # Print the backtrace separator line.
  printf "${_separator// /=}\n" 1>&2

  # Iterate over the functions array stack, skipping this backtrace function [0].
  for (( _index=1 ; _index < ${#_stack[@]} ; ++_index ))
  do
    _source="${BASH_SOURCE[${_index}]}"
    _function="${_stack[${_index}]:+${_stack[${_index}]}()}"
    _line=${BASH_LINENO[$(( _index - 1 ))]}

    case "$_function" in
      fail\(\)|error\(\)|command_not_found_handle\(\)|command_not_found\(\))
        continue
        ;;
    esac

    # Determine the format string output for the backtrace, based on your
    # set editor. Note that if you didn't set an editor, BDSM previously
    # defaulted it to the pager. If no pager is set, BDSM simply outputs a standard
    # Unix utility trace line.
    case "${EDITOR:-}" in
      # Print a file with the format and content for GUI editing tools, to open a
      # given line using a URI. Print a backtrace to calling environment's STDERR.
      (mvim*|mate*)
        printf "${_format}" "open ${EDITOR// *}://open?url=file://${_source}&line=${_line}" "${_function}" 1>&2
        ;;
      # Print a file with the format and content for console editing tools, to open a
      # file to a given line. Print backtrace to calling environment's STDERR.
      (vi*|gvim*|emacs*|*)
        printf "${_format}" "${EDITOR}" "${_line}" "${_source} " "${_function}" 1>&2
        ;;
    esac
  done

  # Print the backtrace separator line, and if the trace flag is nonnegative,
  # then turn tracing back on.
  printf "${_separator// /=}\n" 1>&2

  [[ "${_flag}" != "no_exit" ]] || return 0

  __sm.seppuku
}

__sm.log.step "$@"
{
  local _message="${1:-}" _output _log_file _status

  if (( $# > 1 ))
  then
    shift
    __sm.log.piece "${_message}"

    _log_file="${TMP_PATH:-/tmp}/$$.stderr.log"

    touch "${_log_file}"
    if "$@" > "${_log_file}"
    then
      __sm.log.piece "succ"
      cat "${_log_file}"
      rm -rf "${_log_file}"
      return 0
    else
      _status="$?"
      __sm.log.piece "fail"
      cat "${_log_file}" >&2
      rm -rf "${_log_file}"
      return ${_status} # pass __sm.log.error return status code up !
    fi
  else
    __sm.log.piece "${_message}"
  fi
}

__sm.log.log()
{
  printf "$*\n"
}

__sm.log.todo()
{
  if (( debug_flag )) && __sm.log.options.check "$debug_flags" "todo"
  then
    local file="${BASH_SOURCE[2]}" line="${BASH_LINENO[1]}"
    printf "DEBUG todo: ${file##${sm_path}\/}:${line}:\n"
    printf "$*" | xargs -s 72 | xargs -I {} printf "DEBUG todo: # {}\n"
  else
    return 0
  fi
}

__sm.log.error()
{
  set +o xtrace
  if [[ -n "${BASH_VERSION}" ]]
  then
    printf "ERROR(${FUNCNAME[2]}): $*\n" >&2
  elif [[ -n "${ZSH_VERSION}" ]]
  then
    printf "ERROR(${funcstack[3]}): $*\n" >&2
  fi
  set +o errtrace
  trap - ERR
  exit 1
}

__sm.log.succeed()
{
  set +o xtrace
  if [[ -n "$*" ]]
  then
    printf "$*\n"
  fi
  #exit 0
}

__sm.log.fail()
{
  trace_flag=0
  if [[ -n "${bash_version}" ]]
  then
    backtrace "fail(${funcname[2]}): $*"
  elif [[ -n "${zsh_version}" ]]
  then
    backtrace "fail(${funcstack[3]}): $*"
  fi
  exit 1
}

__sm.set.ps4()
{
  # Set and export the PS4 variable, so that this script -- and called bash scripts --
  # will display more detailed and formatted trace output.
  # Finally, return true, 0, for success.
  if [[ -n "${BASH_VERSION}" ]]
  then
    PS4="# \${BASH_SOURCE##\${sm_path}\/} \${FUNCNAME[0]:+\${FUNCNAME[0]}()} \${LINENO} $ "
  elif [[ -n "${ZSH_VERSION}" ]]
  then
    PS4="+%x:%I %N():%i > "
  fi
  export PS4

  return 0
}

__sm.log.trace.filter()
{
  local _action="$1" old _name
  shift || __sm.log.fail "Filter action {start,stop} must be specified."

  case "${_action}" in
    start)
      trace_filter_stack=( "$1" "${trace_filter_stack[@]}" )
      ;;
    stop)
      old="${trace_filter_stack[${__sm_array_start}]}"
      old="${old%%=*}"

      if [[ -n "${BASH_VERSION}" ]]
      then
        _name="${FUNCNAME[2]}"
      elif [[ -n "${ZSH_VERSION}" ]]
      then
        _name="${funcstack[3]}"
      fi

      if [[ "${_name}" == "${old}" ]]
      then
        shift || true
        trace_filter_stack=( "$@" )
      fi
      ;;
    *)
      __sm.log.fail "Unknown trace action ${_action}, use {start,stop}."
      ;;
  esac

  filter="${trace_filter_stack[${__sm_array_start}]}"

  if [[ -n "$filter" ]]
  then
    if __sm.log.options.check "$trace_flags" "${filter##*=}"
    then
      trap 'set +o xtrace "\$?=$?" ; trace_filter' RETURN
      set -o xtrace
    fi
  else
    # No param, restore default state
    if (( trace_flag != 0 ))
    then
      trap 'set +o xtrace "\$?=$?" ; trace_filter' RETURN
      set -o xtrace
    fi
  fi
}

__sm.log.warn()
{
  printf "WARNING: $*\n"
}

__sm.log.debug()
{
  local type="$1"
  shift || __sm.log.fail "Debug type must be given as the first parameter."

  if (( debug_flag )) && __sm.log.options.check "$debug_flags" "$type"
  then
    if [[ "$1" == "-" ]]
    then
      printf "DEBUG $type: "
      cat -
      printf "\n"
    else
      printf "DEBUG $type: $*\n"
    fi
  else
    return 0
  fi
}

__sm.log.search()
{
  local name="${1:-}" value="${2:-}"
  shift || __sm.log.fail "name must be given as the first parameter."
  shift || __sm.log.fail "value must be given as the second parameter."

  if (( debug_flag )) && __sm.log.options.check "$debug_flags" "search"
  then
    printf "DEBUG search: %9s %-25s in $*.\n" "$name" "$value"
  else
    return 0
  fi
}

__sm.actions.call()
{
  trace_filter action
  "$@"
}

__sm.actions.source()
{
  local script="$1"
  shift || __sm.log.fail "No script was given as the first parameter."
  [[ -r "$script" ]] || __sm.log.fail "Could not find script to run: $script."
  trace_filter action
  source "$script"
}

__sm.debug.variables.callback()
{
  local _variable _function_stack
  if [[ -n "${BASH_VERSION}" ]]
  then
    _function_stack="${FUNCNAME[*]}"
  elif [[ -n "${ZSH_VERSION}" ]]
  then
    _function_stack="${funcstack[*]}"
  fi
  for _variable in ${var_debug_flags[@]}
  do
    eval "
      if [[ \"\${${_variable}[*]}\" != \"\${${_variable}_previous_value[*]}\" ]]
      then
        if [[ -o xtrace ]]
        then
          log \"var debug '${_variable}' change from '\${${_variable}_previous_value[*]}' to '\${${_variable}[*]}'.\"
        elif [[ \"${var_debug_type_flag}\" == \"short\" ]]
        then
          log \"var debug '${_variable}' change from '\${${_variable}_previous_value[*]}' to '\${${_variable}[*]}' function path: ${_function_stack[*]}\"
        else
          backtrace \"var debug '${_variable}' change from '\${${_variable}_previous_value[*]}' to '\${${_variable}[*]}'.\" no_exit
        fi
        if set | grep '^${_variable}=(' >/dev/null
        then
          ${_variable}_previous_value=( \"\${${_variable}[@]}\" )
        else
          ${_variable}_previous_value=\"\${${_variable}}\"
        fi
      fi
    "
  done
}

__sm.debug.variables.callback.initialize()
{
  local _variable
  for _variable in "${var_debug_flags[@]}"
  do
    eval "
      if [[ \"\${${_variable}[*]}\" != \"\${${_variable}_previous_value[*]}\" ]]
      then
        if set | grep '^${_variable}=(' >/dev/null
        then
          ${_variable}_previous_value=( \"\${${_variable}[@]}\" )
        else
          ${_variable}_previous_value=\"\${${_variable}}\"
        fi
      fi
    "
  done
}

__sm.seppuku()
{
  kill -s USR2 $__sm_pid # to exit application, not current subshell.
}

__sm.log.piece()
{
  local _message="${1:-}" _unicode=0
  : ${LINES:=$(tput cols)}

  if [[ -z "${LANG:-}" || "${LANG}" = *UTF* || "${LANG}" = *utf8* ]]
  then
    _unicode=1
  fi

  case "${_message}" in
    fail*)
      # if [[ -t 1 ]]
      # then
        printf "\r%${LINES}s" " "
        if (( _unicode == 1 ))
        then
          printf "\r  [\033[31m✘\033[0m] %s\n" "${log_step_message:-"done"}!  "
        else
          printf "\r  [\033[31mX\033[0m] %s\n" "${log_step_message:-"done"}!  "
        fi
      # else
      #   printf "  failed.\n"
      # fi
      ;;

    succ*)
      # if [[ -t 1 ]]
      # then
        printf "\r%${LINES}s" " "
        if (( _unicode == 1 ))
        then
          printf "\r  [\033[32m✔\033[0m] %s\n" "${log_step_message:-"done"}   "
        else
          printf "\r  [\033[32m@\033[0m] %s\n" "${log_step_message:-"done"}   "
        fi
      # else
      #   printf "  done.\n"
      # fi
      ;;

    *)
      log_step_message="${_message}"
      # if [[ -t 1 ]]
      # then
        printf "  [ ] %s " "${log_step_message}..."
      # else
      #   printf "  %s" "${log_step_message}..."
      # fi
      return 0
      ;;
  esac
  unset log_step_message
}

__sm.tmp.logs.clean()
{
  local _log _logs=( "${TMP_PATH:-/tmp}/$$/logs/err_*.log" )
  for _log in "${_logs[@]}"
  do
    [[ -e "${_log}" ]] || continue
    rm -f "${_log}"
  done
}

__sm.log.options.check()
{
  # Do not use brackets; they slow things down a lot.
  if __sm.string.contains "$2" "$1"
  then
    return 0
  fi

  __sm.string.contains "all" "$1" && ! __sm.string.contains "-$2" "$1"
}
