#!/bin/sh

#
# SM Framework Core Module ~ Modules (modules)
#

modules()
{
  case "$1" in
    (include|load)
      shift #compatibility mode
      ;;
  esac

  [[ -n "$*" ]] || fail "No modules given to include."

  __sm.modules.include "$@"
}

__sm.modules.core.initialize()
{
  (( ! ${__sm_modules_initialized:=0} )) || return 0

  true $((__sm_modules_initialized++))

  local _module _name _path

  __sm.extension.paths.initialize

  #core is loaded as BDSM starts
  __sm_modules_loaded=(
    "sm/core=core/sm/shell/core"
    "sm/string=core/internal/shell/string"
    "sm/logging=core/sm/shell/logging"
    "sm/modules=core/sm/shell/modules"
    "sm/extensions=core/sm/shell/extensions"
  )

  for _module in ${__sm_modules_loaded[@]}
  do
    _name="${_module//=*}"
    _path="${_module//*=}"
    log_search preload "$_name" "${_path}"
  done

  for _module in ${preload_modules[@]}
  do
    if ! __sm.module.include ${_module}
    then
      error "Cannot preload module: ${_module}."
    fi
  done
}

__sm.modules.include()
{
  local _module _sm _extension _path _file _modules=("$@")

  for _module in "${_modules[@]}"
  do
    if __sm.module.include "${_module}"
    then
      continue
    else
      fail "Could not find module path for ${_module}."
    fi
  done
}

__sm.module.include()
{
  local _module="$1" _file _module_dependency _module_path _hook _function

  if __sm.module.is.loaded "${_module}"
  then
    return 0
  fi

  # Search for module.
  if __sm.extension.in.paths __sm.module.detect "${_module}"
  then
    log_search module "$module_name" "${module_path##${sm_path}\/}"
    __sm_modules_loaded+=("${module_name}=${module_path##${sm_path}\/}")
  else
    log_search module "${_module}" "Not found !!!"
    return 1
  fi

  # store path, so dependencies do not overwrite it.
  _module_path="${module_path}"

  # Load env before dependencies, so they can use env settings.
  if [[ -s "${_module_path}/env" ]]
  then
    source "${_module_path}/env" # TODO: should we check for errors here ?!?!?!
  fi

  # Load module dependencies.
  if [[ -s "${module_path}/includes" ]]
  then
    while read -r _module_dependency
    do
      if ! __sm.module.include "${_module_dependency}"
      then
        error "Could not find module dependency '${_module_dependency}' "\
          "from '${_module_path##${sm_path}\/}/includes'."
      fi
    done < "${_module_path}/includes"
  fi

  # Load module
  for _file in functions cli initialize
  do
    if [[ -s "${_module_path}/${_file}" ]]
    then
      #TODO: should we check for errors here ?!?!?!
      source "${_module_path}/${_file}"
    fi
  done

  _function="${_module//\//_}"
  _function="${_function/_shell/_}"

  for _hook in initialize # options, etc... ?
  do
    # TODO: This may need to be adjusted for zsh.
    if __sm.command.is.function "${_function}_${_hook}"
    then
      "${_function}_${_hook}"
    fi
  done

  return 0
}

#TODO: remove - deprecated
__sm.modules.reinitialize()
{
  local _module _modules=("$@") _loaded_modules _module_path _initialize_path

  _loaded_modules=" ${__sm_modules_loaded[*]} "
  for _module in "${_modules[@]}"
  do
    _module_path="${_loaded_modules##* ${_module}=}"
    _module_path="${_module_path%% *}"
    [[ -n "${_module_path}" ]] ||
      fail "Can not reinitialize module as it was not yet loaded"

    _initialize_path="${sm_path}/${_module_path}/initialize"
    [[ ! -s "${_initialize_path}" ]] || source "${_initialize_path}"
  done
}

__sm.module.is.loaded()
{
  local _name="${1}"
  case " ${__sm_modules_loaded[*]} " in
    (*[[:space:]]${_name}=*)
      return 0
      ;;
    (*)
      return 1
      ;;
  esac
}

__sm.extension.in.paths()
{
  local callback="${1:-}" _path
  shift || fail "Callback name must be given ast the first parameter."

  if [[ -n "$1" ]] # do search if params given
  then
    for _path in "${extensions_search_paths[@]}"
    do
      "${callback}" "${_path}" "$@" || continue
      return 0
    done
  fi
  return 1
}

__sm.cli.in.path()
{
  local callback="${1:-}"
  shift || fail "Callback name must be given ast the first parameter."

  "${callback}" "${sm_path}/core" "cli" "$@"
}

__sm.extension.paths.initialize()
{
  local _paths=() _extension_set_path

  if [[ -z "${extensions_search_paths[*]}" ]]
  then
    extensions_search_paths=()

    # Single user extensions
    if [[ "${exts_system_path}" != "${exts_user_path}" ]]
    then
      extensions_search_paths+=( "${exts_user_path}/active" )
    fi

    # Single system extensions
    extensions_search_paths+=( "${exts_system_path}/active" )

    # User extension sets
    if [[ "${sets_system_path}" != "${sets_user_path}" ]]
    then
      shopt -s nullglob
      _paths=( "${sets_user_path}"/active/* )
      shopt -u nullglob
      for _extension_set_path in "${_paths[@]}"
      do
        if [[ -d "${_extension_set_path}" ]]
        then
          extensions_search_paths+=( "${_extension_set_path}" )
        fi
      done
    fi

    # System extension sets
    shopt -s nullglob
    _paths=( "${sets_system_path}"/active/* )
    shopt -u nullglob
    for _extension_set_path in "${_paths[@]}"
    do
      if [[ -d "${_extension_set_path}" ]]
      then
        extensions_search_paths+=( "${_extension_set_path}" )
      fi
    done
  fi

  case "${extensions_search_paths}" in
    (*"${sm_path}/core"*)
      true
      ;;
    (*) # Core is required to run, add it if not found
      extensions_search_paths+=( "${sm_path}/core" )
    ;;
  esac

  debug search "sets_user_path:${sets_user_path}:"
  debug search "exts_user_path:${exts_user_path}:"
  debug search "extensions_search_paths:${extensions_search_paths[*]}:"
  export extensions_search_paths
}

__sm.extension.path.reorder()
{
  local part="${1:-}" extensions_path="${2:-}" extension="${3:-}"
  shift || fail "Path part must be given as the first parameter."
  shift || fail "Extensions path must be given as the second parameter."
  shift || fail "Extension name must be given as the third parameter."

  local output="$extensions_path/$extension/$part/$*"
  rebuilded_path="${output// //}"
}

__sm.extension.path.rebuild()
{
  local part="$1" extensions_path="$2"
  shift || fail "Path part must be given as the first parameter."
  shift || fail "Extensions path must be given as the second parameter."

  local params="$*"
  __sm.extension.path.reorder "${part}" "${extensions_path}" ${params//\// }
}

__sm.module.detect()
{
  local extensions_path=$1 _module_path
  shift || fail "Extensions path must be given as the first parameter."

  __sm.extension.path.rebuild "shell" $extensions_path $@
  _module_path=${rebuilded_path}

  debug search_module_path ":${_module_path}:"

  if [[ -d "${_module_path}/functions" ]]
  then
    return 1
  fi

  if [[ -s "${_module_path}/functions" || -s "${_module_path}/includes" ]]
  then
    module_path=${_module_path}
    module_name="$*"
    module_name="${module_name// //}"
    return 0
  else
    return 1
  fi
}

