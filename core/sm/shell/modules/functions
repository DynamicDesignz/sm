#!/bin/sh

#
# SM Framework Core Module ~ Modules (modules)
#

modules()
{
  local _token _command _subcommand _modules=()

  while (( $# ))
  do
    case "${_token}" in
      (core)
        _command="${_token}"
        _subcommand="$1"
        shift || fail "Command must follow keyword 'core'; modules core <initialize>"
        case "${_subcommand}" in
          (initialize)
            continue
            ;;
          (*)
            "Unknown command following keyword 'core'; modules core <initialize>"
            ;;
        esac
        ;;
      (*)
        if [[ -z "${_command}"]]
        then
          _command="${_token}"
        else
          _modules+=("${_token}")
        fi
        fail "Unrecognized module command '${_token}'"
        ;;
    esac
  done

  case "${_command}" in
    (initialize)
      __sm.modules.core.initialize
      ;;
    (reinitialize)
      [[ -n "${_modules}" ]] || fail "No modules given to reinitialize."
      __sm.modules.reinitialize "${_modules[@]}"
      ;;
    (include|load)
      [[ -n "${_modules}" ]] || fail "No modules given to include."
      __sm.modules.include "${_modules[@]}"
      ;;
    (*)
      fail "Unknown modules command '${_command}'"
      ;;
  esac
}

__sm.modules.core.initialize()
{
  (( ! ${__sm_modules_initialized:=0} )) || return 0

  true $((__sm_modules_initialized++))

  local _module _name _path

  __sm.extensions.paths.initialize

  #core is loaded as BDSM starts
  __sm_modules_loaded=(
    "sm/core=core/sm/shell/core"
    "sm/string=core/sm/shell/string"
    "sm/logging=core/sm/shell/logging"
    "sm/modules=core/sm/shell/modules"
  )

  for _module in ${__sm_modules_loaded[@]}
  do
    _name="${_module//=*}"
    _path="${_module//*=}"
    log_search preload "$_name" "${_path}"
  done

  for _module in ${preload_modules[@]}
  do
    modules load ${_module} || error "Cannot preload module: ${_module}."
  done
}

__sm.modules.include()
{
  local _module _sm _extension _path _file _modules=("$@")

  for _module in "${_modules[@]}"
  do
    if __sm.module.include "${_module}"
    then
      continue
    else
      fail "Could not find module path for ${_module}."
    fi
  done
}

__sm.module.include()
{
  local _module="$1" _file _module_dependency _module_path _hook _function

  if __sm.module.is.loaded "${_module}"
  then
    return 0
  fi

  # Search for module.
  if __sm.extensions.in.paths __sm.module.detect "${_module}"
  then
    log_search module "$module_name" "${module_path##${sm_path}\/}"
    __sm_modules_loaded+=("${module_name}=${module_path##${sm_path}\/}")
  else
    log_search module "${_module}" "Not found !!!"
    return 1
  fi

  # store path, so dependencies do not overwrite it.
  _module_path="${module_path}"

  # Load env before dependencies, so they can use env settings.
  if [[ -s "${_module_path}/env" ]]
  then
    source "${_module_path}/env" # TODO: should we check for errors here ?!?!?!
  fi

  # Load module dependencies.
  if [[ -s "${module_path}/includes" ]]
  then
    while read -r _module_dependency
    do
      if ! __sm.module.load "${_module_dependency}"
      then
        error "Could not find module dependency '${_module_dependency}' "\
          "from '${_module_path##${sm_path}\/}/includes'."
      fi
    done < "${_module_path}/includes"
  fi

  # Load module
  for _file in functions cli initialize
  do
    if [[ -s "${_module_path}/${_file}" ]]
    then
      #TODO: should we check for errors here ?!?!?!
      source "${_module_path}/${_file}"
    fi
  done

  _function="${_module//\//_}"
  _function="${_function/_shell/_}"

  for _hook in initialize # options, etc... ?
  do
    if command -v "${_function}_${_hook}" > /dev/null 2>&1
    then
      "${_function}_${_hook}"
    fi
  done

  return 0
}

__sm.modules.reinitialize()
{
  local _module _modules=("$@") _loaded_modules _module_path _initialize_path

  _loaded_modules=" ${__sm_modules_loaded[*]} "
  for _module in "${_modules[@]}"
  do
    _module_path="${_loaded_modules##* ${_module}=}"
    _module_path="${_module_path%% *}"
    [[ -n "${_module_path}" ]] ||
      fail "Can not reinitialize module as it was not yet loaded"

    _initialize_path="${sm_path}/${_module_path}/initialize"
    [[ ! -s "${_initialize_path}" ]] || source "${_initialize_path}"
  done
}

__sm.module.is.loaded
{
  local _name="${1}"
  case " ${__sm_modules_loaded[*]} " in
    (*[[:space:]]${_name}=*)
      return 0
      ;;
    (*)
      return 1
      ;;
  esac
}

__sm.extensions.in.paths()
{
  trace_filter search
  local callback="${1:-}" _path
  shift || fail "Callback name must be given ast the first parameter."

  if [[ -n "$1" ]] # do search if params given
  then
    for _path in "${extensions_search_paths[@]}"
    do
      "${callback}" "${_path}" "$@" || continue
      return 0
    done
  fi
  return 1
}

__sm.cli.in.path()
{
  trace_filter search
  local callback="${1:-}"
  shift || fail "Callback name must be given ast the first parameter."

  "${callback}" "${sm_path}/core" "cli" "$@"
}

__sm.extensions.paths.initialize()
{
  local _paths=() _extension_set_path

  if [[ -z "${extensions_search_paths[*]}" ]]
  then
    extensions_search_paths=()

    # Single user extensions
    if [[ "${exts_system_path}" != "${exts_user_path}" ]]
    then
      extensions_search_paths+=( "${exts_user_path}/active" )
    fi

    # Single system extensions
    extensions_search_paths+=( "${exts_system_path}/active" )

    # User extension sets
    if [[ "${sets_system_path}" != "${sets_user_path}" ]]
    then
      shopt -s nullglob
      _paths=( "${sets_user_path}"/active/* )
      shopt -u nullglob
      for _extension_set_path in "${_paths[@]}"
      do
        if [[ -d "${_extension_set_path}" ]]
        then
          extensions_search_paths+=( "${_extension_set_path}" )
        fi
      done
    fi

    # System extension sets
    shopt -s nullglob
    _paths=( "${sets_system_path}"/active/* )
    shopt -u nullglob
    for _extension_set_path in "${_paths[@]}"
    do
      if [[ -d "${_extension_set_path}" ]]
      then
        extensions_search_paths+=( "${_extension_set_path}" )
      fi
    done
  fi

  # Core is required to run, add it if not found
  string contains "${extensions_search_paths[*]}" "${sm_path}/core" ||
    extensions_search_paths+=( "${sm_path}/core" )

  debug search "sets_user_path:${sets_user_path}:"
  debug search "exts_user_path:${exts_user_path}:"
  debug search "extensions_search_paths:${extensions_search_paths[*]}:"
  export extensions_search_paths
}

__sm.extensions.path.reorder()
{
  local part="${1:-}" extensions_path="${2:-}" extension="${3:-}"
  shift || fail "Path part must be given as the first parameter."
  shift || fail "Extensions path must be given as the second parameter."
  shift || fail "Extension name must be given as the third parameter."

  local output="$extensions_path/$extension/$part/$*"
  rebuilded_path="${output// //}"
}

__sm.extensions.path.rebuild()
{
  local part="$1" extensions_path="$2"
  shift || fail "Path part must be given as the first parameter."
  shift || fail "Extensions path must be given as the second parameter."

  local params="$*"
  __sm.extensions.path.reorder "${part}" "${extensions_path}" ${params//\// }
}

__sm.module.detect()
{
  local extensions_path=$1 _module_path
  shift || fail "Extensions path must be given as the first parameter."

  __sm.extensions.path.rebuild "shell" $extensions_path $@
  _module_path=${rebuilded_path}

  debug search_module_path ":${_module_path}:"

  [[ -d "${_modules_path}/functions" ]] || return 1

  if [[ -s "${_modules_path}/functions" || -s "${_modules_path}/includes" ]]
  then
    module_path=${_module_path}
    module_name="$*"
    module_name="${module_name// //}"
    return 0
  else
    return 1
  fi
}

