#!/bin/sh

#
# SM Framework Core Module ~ Versioned FileSystem (verfs)
#
# API Version: 1.0.0
#
# verfs \
#   path "{verfs root path}" \
#   strategy "{fhs,name}" \
#   method "{link,copy}" \
#   activate "{newest,first}"
#
# Example: (package module)
#
# verfs \
#   path /opt/sm/pkg \
#   strategy fhs \
#   method link \
#   activate first
#
# FileSystem structure:
#
# {verfs_path}/
#   verfs/
#     strategy # contains one of {fhs,name}
#     method   # contains one of {link,copy}
#     activate # contains one of {newest,first}
#
#   versions/
#     {name}/{version}/ # For each {name}:{version} pair added.
#
# If strategy is 'fhs' then,
#   active/
#     {bin,sbin,lib,libexec,usr,var,tmp}
#
# If strategy is 'name' then,
#   active/
#     {name} # For each active name.
#
# In both cases if method is 'link' then each entry will be a symlink
# otherwise each entry will be copied files/directories.
#
verfs()
{
  local _token _path _paths _source _name _version _strategy _method _activate
  local _action="${1:-}"
  shift || fail "Usage: verfs path \"{verfs root path}\" strategy \"{fhs,name}\" method \"{link,copy}\" activate \"{newest,first}\""

  while (( $# ))
  do
    _token="${1}" ; shift
    case "${_token}" in
      (path)
        _path="${1}"
        shift || fail "Verfs path must follow keyword 'path'"
        ;;
      (source)
        _source="${1}"
        shift || fail "Source path must follow keyword 'source'"
        ;;
      (name)
        _name="${1}"
        shift || fail "Name must follow keyword 'name'"
        ;;
      (version)
        _version="${1}"
        shift || fail "Version path must follow keyword 'version'"
        ;;
      (strategy)
        _strategy="${1}"
        shift || fail "Strategy path must follow keyword 'strategy'"
        case "${_strategy}" in
          (fhs|name) true ;;
          (*) fail "Strategy must be one of {fhs,name}" ;;
        esac
        ;;
      (method)
        _method="${1}"
        shift || fail "method path must follow keyword 'method'"
        case "${_method}" in
          (link|copy) true ;;
          (*) fail "Method must be one of {link,copy}" ;;
        esac
        ;;
      (activate)
        _activate="${1}"
        shift || fail "activate path must follow keyword 'activate'"
        case "${_activate}" in
          (first|newest) true ;;
          (*) fail "Activate must be one of {first,newest}" ;;
        esac
        ;;
      (*)
        fail "Unknown parameter '${_token}'"
    esac
  done

  [[ -n "${_path}" ]] || fail "A verfs root path must be given."

  [[ "${_action}" == create || -d "${_path}/verfs" ]] ||
    fail "${_path} is not a verfs root path; "\
    "Use 'verfs create path {path}' to initialize."

  case "${_action}" in
    (create)
      _verfs_create "${_path}"
      ;;
    (add)
      [[ -n "${_name}" && -n "${_source}" ]] ||
        fail "Name and Source must be given."
      _verfs_add "${_path}" "${_name}" "${_version}" "${_source}"
      ;;
    (remove)
      [[ -n "${_name}" ]]    || fail "Name must be given."
      _verfs_remove "${_path}" "${_name}" "${_version}"
      ;;
    (activate)
      [[ -n "${_name}" && -n "${_version}" ]] ||
        fail "Name and Version must be given."

      _verfs_activate "${_path}" "${_name}" "${_version}"
      ;;
    (deactivate)
      [[ -n "${_name}" ]]    || fail "Name must be given."
      _verfs_deactivate "${_path}" "${_name}" "${_version}"
      ;;
    (versions)
      _verfs_remove "${_path}" "${_name}" "${_version}"
      ;;
    (active)
      _verfs_active "${_path}" "${_name}" "${_version}"
      ;;
    (*)
      fail "Unknown verfs action '${_action}'"
      ;;
  esac
}

_verfs_create()
{
  local _path="$1"
  mkdir -p "${_path}/"{verfs,versions,active} ||
    fail "Could not create paths ${_path}/{verfs,versions,active}"

  echo "${_strategy}" > "${_path}/verfs/strategy"
  echo "${_method}"   > "${_path}/verfs/method"
  echo "${_activate}" > "${_path}/verfs/activate"

}

_verfs_add()
{
  local _path="$1" _source="$2" _name="$3" _version="${3:-}"
  local _version_path="${_path}/versions/${_name}/${_version}"

  [[ -n "${_version}" ]] || _version="$(date +"%H%M%S")"

  [[ -d "${_version_path}" ]] || mkdir -p "${_version_path}"

  [[ "${_version_path}" == "${_source}" ]] ||
    cp -Rf "${_source}"/ "${_version_path}"
}

_verfs_remove()
{
  local _path="$1" _name="${2}" _version="${3}"
  local _version_path="${_path}/versions/${_name}/${_version}"

  _verfs_deactivate "${_path}" "${_name}" "${_version}"

  [[ ! -d "${_version_path}" ]] || rm -rf "${_version_path}/"
}

_verfs_activate()
{
  local _path="$1" _name="${2}" _version="${3}" _target
  local _version_path="${_path}/versions/${_name}/${_version}"
  local _active_path="${_path}/active"

  if [[ -L "${_path}/versions/${_name}/active" ]]
  then # Deactivate if active version.
    if [[ "$(readlink "${_path}/versions/${_name}/active")" != "${_version_path}" ]]
    then
      _verfs_deactivate "${_path}" "${_name}"
    else
      return 0 # Success if the given name/version is already active.
    fi
  fi

  local _activate _active_version_path _index=0 _count _active_path

  read -r _activate < "${_path}/verfs/activate"

  if [[ -L "${_path}/versions/${_name}/active" ]]
  then
    _active_version_path="$(readlink "${_path}/versions/${_name}/active")"
    case "${_activate}" in
      (first)
        [[ -z "${_active_version_path}" ]] || return 0 # a version is already active
        ;;
      (newest)
        true # continue with activation
        ;;
    esac
  fi

  read -r _strategy < "${_path}/verfs/strategy"
  read -r _method < "${_path}/verfs/method"

  case "${_strategy}" in
    (fhs)
      case "${_method}" in
        (link)
          _files=($( find "${_version_path}" -type f ))
          _count="${#_files[@]}"
          for _file in "${_files[@]}"
          do
            (( _index++ )) || true
            printf "\r  [ ] ${_name} ${_version} ~ linking (${_index}/${_count})...    "
            _target="${_active_path}/${_file##${_version_path}/}"
            [[ -d "${_target%/*}" ]] || mkdir -p "${_target%/*}"
            ln -sf "${_file}" "${_target}"
          done
          printf "\r  [o] %-40s" "${_name} ${_version} ~ linking"
          ;;
        (copy)
          cp -Rf "${_version_path}/" "${_active_path}/"
          ;;
      esac
      ;;
    (name)
      [[ ! -d "${_active_path}/${_name}" ]] || rm -rf "${_active_path}/${_name}"

      cp -Rf "${_version_path}/" "${_active_path}/${_name}"
      ;;
  esac

  ln -sf "${_version_path}" "${_path}/versions/${_name}/active"
  # TODO: Add to active 'db'
}

_verfs_deactivate()
{
  local _path="$1" _name="${2}" _version="${3:-}"
  local _name_path="${_path}/versions/${_name}"
  local _active_path="${_path}/active"

  [[ -L "${_path}/versions/${_name}/active" ]] || return 0 # No active version

  local _index=0 _count
  local _version_path="$(readlink "${_path}/versions/${_name}/active")"

  if [[ -n "${_version}" && "${_version_path}" == "${_name_path}/${_version}" ]]
  then
    debug package "A different version than the one given is active; Skipping deactivation."
    return 0 #
  fi

  read -r _strategy < "${_path}/verfs/strategy"

  case "${_strategy}" in
    (fhs)
      _files=($( find "${_version_path}" -type f ))
      _count="${#_files[@]}"
      echo
      for _file in "${_files[@]}"
      do
        (( _index++ ))
        printf "\r  Removing (${_index}/${_count})"
        rm -f "${_active_path}/${_file##${_version_path}}"
      done
      ;;
    (name)
      rm -rf "${_active_path}/${_name}/"
      ;;
  esac

  rm -f "${_path}/versions/${_name}/active"
  # Remove from active metadata
}

_verfs_versions()
{
  local _path="$1" _name="${2:-}"

  if [[ -n "${_name}" ]]
  then
    find "${_path}/versions/${_name}" -mindepth 1 -maxdepth 1 -type d |
      awk -F'/' '! /\/active\//{print $(NF - 1)":"$(NF)}' | sort
  else
    find "${_path}" -mindepth 2 -maxdepth 2 -type d |
      awk -F'/' '! /\/active\//{print $(NF - 1)":"$(NF)}' | sort
  fi
}

_verfs_active()
{
  local _path="$1" _name="${2:-}" _version _found

  if [[ -n "${_name}" ]]
  then
    _name="${1//,/ }"
    _found=($( find "${_path}" -mindepth 1 -maxdepth 1 -name active -type l |
    awk -F'/' '! /\/active\//{print $(NF - 1)}' | awk "/${_name// /|}/"
    ))
  else
    _found=($( find "${_path}" -mindepth 2 -maxdepth 2 -name active -type l |
    awk -F'/' '! /\/active\//{print $(NF - 1)}'
    ))
  fi

  for _version in "${_found[@]}"
  do
    if [[ -L "${_path}/versions/${_name}/active" ]]
    then
      readlink "${_path}/versions/${_name}/active" |
        awk -F'/' '{print $(NF-1) ":" $NF}'
    fi
  done
}

