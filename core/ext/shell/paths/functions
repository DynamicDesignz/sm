#!/bin/sh

# ### Usage Examples
#
#     user$ ls -a
#     . ..
#     user$ ensure_paths_exist a b c
#     user$ ls -a
#     . .. a b c
#
ensure_paths_exist()
{
  trace_filter filesystem

  local _path _paths=("$@")

  shift || fail "Cannot ensure paths exist; No paths were given."

  for _path in "${_paths[@]}"
  do
    if [[ -d "${_path}" ]] || [[ -L "${_path}" && -d "$(readlink "${_path}")" ]]
    then
      continue
    fi

    if [[ -f "${_path}" || -L "${_path}" ]]
    then
      warn "Could not ensure path '${_path}' exists as the path is a file."
    else
      mkdir -p "${_path}" || fail "Could not create the path '${_path}',"\
        "as the 'mkdir' command failed with error code '$?'."
    fi
  done
}

# ### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
remove_paths()
{
  trace_filter filesystem
  local _path _paths=("$@")
  shift || fail "No paths were given."

  removed_paths=()
  nonexistant_paths=()

  for _path in "${_paths[@]}"
  do
    if [[ -L "${_path}" ]]
    then
      rm -f "${_path}" || fail "Could not remove the entity '${_entity}';"\
          "'rm' command failed with error code '$?'."
      removed_paths+=("${_path}")
    elif [[ -d "${_path}" ]]
    then
      rm -rf "${_path}" || fail "Could not remove the entity '${_entity}';"\
          "'rm' command failed with error code '$?'."
      removed_paths+=("${_path}")

    elif [[ -e "${_path}" ]]
    then
      fail "Cannot remove the path '${_path}', as it is a file."

    else
      nonexistant_paths+=("${_path}")
    fi
  done
}

# ### Usage Examples
#
#     user$ move_path "freetds-0.91rc"* to "freetds-0.91"
#
move_path()
{
  trace_filter filesystem
  local _source _target _mode _owner

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift || fail "Target path must be provided after keyword 'to'"
        ;;

      from)
        _source="${1}"
        shift || fail "Source path must be provided after keyword 'from'"
        ;;

      mode)
        _mode="${1}"
        shift || fail "Mode must be provided after keyword 'mode'"
        ;;

      owner)
        _owner="${1}"
        shift || fail "Owner must be provided after keyword 'owner'"
        ;;

      *) # If the token is unknown
        if [[ -z "${_source}" ]]
        then
          _source="$token"

        elif [[ -z "${_target}" ]]
        then
          _target="$token"
        fi
        ;;
    esac
  done

  [[ -n "${_source}" ]] || fail "Source must be given. "
  [[ -n "${_target}" ]] || fail "Target must be given. "

  mv "${_source}" "${_target}" ||
    fail "Could not move '${_source}' to '${_target}',"\
    "as the 'chmod -R' command failed with error code '$?'."

  [[ -z "${_mode}" ]] ||
    chmod -R "${_mode}" "${_target}" ||
    fail "Could not recursively change mode of '${_target}' to"\
    "${_mode}, as the 'chmod -R' command failed with error code '$?'."

  [[ -z "${_owner}" ]] ||
    chown -R "${_owner}" "${_target}" ||
    fail "Could not recursively change ownership of '${_target}' to"\
    "${_owner}, as the 'chown -R' command failed with error code '$?'."
}

# ### Usage Examples
#
#     user$ copy_paths to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
#
copy_paths()
{
  trace_filter filesystem
  local _target _path _force_flag=0 _directories=()

  while (( $# > 0 ))
  do
    token="$1"
    shift
    case "${token}" in
      to)
        _target="${1}"
        shift || fail "Target path must be given after keyword 'from'"
        ;;

      from)
        _directories+=( "${1}" )
        shift || fail "Source path must be given after keyword 'from'"
        ;;

      *)
        _directories+=( "${token}" )
        ;;
    esac
  done

  [[ -n "${_target}" ]] || fail "Target must be given."
  array_is_nonempty _directories || fail "Directories must be given."

  ensure_paths_exist "${_target}"

  for _path in "${_directories[@]}"
  do
    [[ -d "${_path}" ]] ||
      error "Cannot copy path ${_path} to ${_target},"\
      "as path (directory) '${_path}' does not exist (in '$PWD')."

    cp -Rf "${_path}" "${_target}/" ||
      fail "Could not copy the entity '${_entity}',"\
      "as the 'cp -Rf' command failed with error code '$?'."
  done
}

# ### Usage Examples
#
#     user$ copy_path "freetds-0.91rc"* to "freetds-0.91"
#
copy_path()
{
  trace_filter filesystem
  local _source _target

  while (( $# > 0 ))
  do
    token="$1"
    shift
    case "${token}" in
      to)
      _target="${1}"
      shift || fail "Target path must be given after keyword 'from'"
      ;;
      from)
      _source="${1}"
      shift || fail "Source path must be given after keyword 'from'"
      ;;
      *)
        if [[ -z "${_source}" ]]
        then
          _source="$token"

        elif [[ -z "${_target}" ]]
        then
          _target="$token"
        fi
        ;;
    esac
  done

  [[ -n "${_source}" ]] || fail "Cannot move file; Source must be given."
  [[ -n "${_target}" ]] || fail "Cannot move file, Target must be given."

  cp -Rf "${_source}" "${_target}" ||
    fail "Could not copy '${_source}' to '${_target}',"\
      "as the 'cp' command failed with error code '$?'."
}

# ### Usage Examples
#
#     user$ chown_paths $USER "$HOME" "/usr/local"
#
chown_paths()
{
  trace_filter filesystem
  local _identity _path _recursive_flag=0 _command _flags=() _paths=()

  case "${1:-}" in
    (recursive|--recursive*)
      _flags+=(-R)
      shift # Remove the recursive flag parameter.
      ;;
    (*)
      _identity="${1:-}"
      ;;
  esac

  _identity="${1:-}"
  shift || fail "user[:group] was not given as the first parameter"

  _paths=("$@")
  shift || fail "No paths given after user and group first parameter"

  for _path in "${_paths[@]}"
  do
    [[ -n "${_path}" ]] || continue

    [[ -e "${_path}" ]] ||
      fail "Cannot chown path ${_path} to ${_identity},"\
      "as the path (directory) does not exist."

    chown ${_flags[*]} ${_identity} "${_path}" ||
      fail "Could not chown the path '${_path}' to '${_identity},"\
      "as the 'chown' command failed with error code '$?'."
  done
}

# ### Usage Examples
#
#     user$ chmod_paths $USER "$HOME" "/usr/local"
#
chmod_paths()
{
  trace_filter filesystem
  local _permissions="${1:-}" _path _recursive_flag=0 _command _flags=()

  if [[ "${1:-}" == "--recursive" ]]
  then
    _recursive_flag=1
    shift
    _permissions="${1}"
  fi

  (( _recursive_flag == 0 )) || _flags+=(-R)

  shift || fail "Cannot chmod paths; user[:group] was not given as the first parameter."

  local _paths=("$@") # Set the paths array to the remaining parameters.

  array_is_nonempty _paths || fail "No files were given."

  for _path in "${_paths[@]}"
  do
    [[ -d "${_path}" ]] ||
      fail "Cannot chmod path ${_path} to ${_permissions},"\
      "as the path (directory) does not exist."

    chmod ${_flags[*]} ${_permissions} "${_path}" ||
      fail "Could not chmod the file '${_file}' to "\
      "'${_target}/${_file//*\/},"\
      "as the 'chmod' command failed with error code '$?'."

  done
}

# Examples
#
#     user$ enter "/usr/local/src"
#
enter()
{
  trace_filter filesystem
  local _path="${1:-}"

  shift || fail "No path was given."

  [[ -d "${_path}" ]] || fail "Cannot enter path '${_path}'; Path does not exist."

  builtin cd "${_path}" ||
    fail "Could not cd into the given path '${_path}'; "\
      "'cd' command failed with error code '$?'."
}

# Examples
#
#     user$ path_exists /bin/sm
#     user$ echo $?
#     0
#
#     user$ path_exists /bin/asdfasdf
#     user$ echo $?
#     1
#
path_exists()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "No name/path was given."
  [[ -d "$_path" ]]
}

# Examples
#
#     user$ path_does_not_exist /bin/sm
#     user$ echo $?
#     1
#
#     user$ path_does_not_exist /bin/asdfasdf
#     user$ echo $?
#     1
#
path_does_not_exist()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "No name/path was given."
  [[ ! -d "$_path" ]]
}

# Examples
#
path_join()
{
  trace_filter filesystem
  local IFS='/'
  printf "$*"
}

# Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
directories_in()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "path name was not given!"

  [[ -d "${_path}" ]] || fail "'${_path}' is not a path!"

  find "${_path}" -mindepth 1 -maxdepth 1 -type d
}

#
# Examples
#
#
directories_in_matching()
{
  trace_filter filesystem
  local _pattern _path="${1:-}"
  shift     || fail "Path was not given!"
  [[ -d "${_path}" ]]    || fail "'${_path}' is not a path!"

  local _pattern="${2:-}"
  shift  || fail "'${_path}' is not a path!"

  find "${_path}" -mindepth 1 -maxdepth 1 -type d
}

#
# Examples
#
#
directories_under()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift  || fail "Path was not given!"

  [[ -d "${_path}" ]] || fail "'${_path}' is not a path!"

  find "${_path}" -mindepth 1 -type d
}

#
# Examples
#
#
directories_under_matching()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "Path was not given as the first parameter."

  local _pattern="${1:-}"
  shift || fail "Pattern was not given as the second parameter."

  [[ -n "${_pattern}" ]] || fail "'${_path}' is not a path!"
  [[ -d "${_path}" ]]    || fail "'${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -iname "${_pattern}" -type d
}

#
# Examples
#
#
directory_empty()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "Path was not given as the first parameter."

  [[ -d "${_path}" ]] || fail "'${_path}' is not a directory!"

  for f in "${_path}"/*
  do
    case "$f" in
      (*/\*) return 0 ;;
      (*) return 1 ;;
    esac
  done
  return 1
}

#
# Examples
#
#
directory_nonempty()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "Path was not given as the first parameter."

  [[ -d "${_path}" ]] || fail "'${_path}' is not a directory!"

  for f in "${_path}"/*
  do
    case "$f" in
      (*/\*) return 1 ;;
      (*) return 0 ;;
    esac
  done
  return 1
}

# Examples
#
# user$ cd ; sm call full_path test
# /home/user/test
#
full_path()
{
  trace_filter filesystem
  local _path="$1"
  shift || fail "Cannot go to path; No path was given."
  [[ -d "${_path}" ]] || fail "Path '${_path}' does not exist."
  (
  builtin cd "${_path}"
  pwd
  )
}

