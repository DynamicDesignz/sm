#!/bin/sh

#
# ## ensure\_paths\_exist
#
# Iterates over the list of given paths, creating the path if it does not exist.
#
# ### Input Parameters
#
# A list of paths to create if missing.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Paths that were given but do not exist will be created.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no paths were given.
#
# ### Usage Examples
#
#     user$ ls -a
#     . ..
#     user$ ensure_paths_exist a b c
#     user$ ls -a
#     . .. a b c
#
ensure_paths_exist()
{
  trace_filter filesystem

  local _path _paths=("$@")

  shift || fail "Cannot ensure paths exist; No paths were given."

  for _path in "${_paths[@]}"
  do
    [[ ! -d "${_path}" ]] || continue

    if [[ -f "${_path}" ]]
    then
      if [[ -L "${_path}" ]] && [[ -d "$(readlink "${_path}")" ]]
      then
        continue
      else
        warn "Could not ensure path '${_path}' exists as the path is a file."
      fi
    else
      mkdir -p "${_path}" ||
        fail "Could not create the path '${_path}',"\
          "as the 'mkdir' command failed with error code '$?'."
    fi
  done
}


#
# ## remove\_paths
#
# Function Description
#
# ### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
# If any paths are requested for removal that are already nonexistent, they
# are listed in the nonexistant_paths array when this function returns.
# Additionally, each path successfully removed is available in the
# remove_paths array.
#
# ### Return Codes
#
# 0 if ...
# 1 if ...
#
# ### Failure Scenarios
#
# Fails if ...
#
# ### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
remove_paths()
{
  trace_filter filesystem
  local _path _paths=("$@")
  shift || fail "No paths were given."

  removed_paths=()
  nonexistant_paths=()

  for _path in "${_paths[@]}"
  do
    if [[ -L "${_path}" ]]
    then
      rm -f "${_path}" || fail "Could not remove the entity '${_entity}';"\
          "'rm' command failed with error code '$?'."
      removed_paths+=("${_path}")
    elif [[ -d "${_path}" ]]
    then
      rm -rf "${_path}" || fail "Could not remove the entity '${_entity}';"\
          "'rm' command failed with error code '$?'."
      removed_paths+=("${_path}")

    elif [[ -e "${_path}" ]]
    then
      fail "Cannot remove the path '${_path}', as it is a file."

    else
      nonexistant_paths+=("${_path}")
    fi
  done
}

#
# ## move\_path
#
# Moves a path from one location to another.
# (This is also used to rename a path.)
#
# ### Input Parameters
#
# The first parameter is the source path name.
# The second parameter is the target path name.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, a path is renamed (moved).
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if the source path is not specified.
# Fails if the target path is not specified.
#
# ### Usage Examples
#
#     user$ move_path "freetds-0.91rc"* to "freetds-0.91"
#
move_path()
{
  trace_filter filesystem
  local _source _target _mode _owner

  while (( $# > 0 ))
  do
    token="$1"
    shift

    case "${token}" in
      to)
        _target="${1}"
        shift || fail "Target path must be provided after keyword 'to'"
        ;;

      from)
        _source="${1}"
        shift || fail "Source path must be provided after keyword 'from'"
        ;;

      mode)
        _mode="${1}"
        shift || fail "Mode must be provided after keyword 'mode'"
        ;;

      owner)
        _owner="${1}"
        shift || fail "Owner must be provided after keyword 'owner'"
        ;;

      *) # If the token is unknown
        if [[ -z "${_source}" ]]
        then
          _source="$token"

        elif [[ -z "${_target}" ]]
        then
          _target="$token"
        fi
        ;;
    esac
  done

  [[ -n "${_source}" ]] || fail "Source must be given. "
  [[ -n "${_target}" ]] || fail "Target must be given. "

  mv "${_source}" "${_target}" ||
    fail "Could not move '${_source}' to '${_target}',"\
    "as the 'chmod -R' command failed with error code '$?'."

  [[ -z "${_mode}" ]] ||
    chmod -R "${_mode}" "${_target}" ||
    fail "Could not recursively change mode of '${_target}' to"\
    "${_mode}, as the 'chmod -R' command failed with error code '$?'."

  [[ -z "${_owner}" ]] ||
    chown -R "${_owner}" "${_target}" ||
    fail "Could not recursively change ownership of '${_target}' to"\
    "${_owner}, as the 'chown -R' command failed with error code '$?'."
}

#
# ## copy\_paths to
#
# Copies a given list of directories into the named path.
#
# ### Input Parameters
#
# The first parameter is the path to copy the directories into.
# Remaining parameters are the paths list.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, all named directories are copied into the target path.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no target path is given.
# Fails if no directories are given.
#
# ### Usage Examples
#
#     user$ copy_paths to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
#
copy_paths()
{
  trace_filter filesystem
  local _target _path _force_flag=0 _directories=()

  while (( $# > 0 ))
  do
    token="$1"
    shift
    case "${token}" in
      to)
        _target="${1}"
        shift || fail "Target path must be given after keyword 'from'"
        ;;

      from)
        _directories+=( "${1}" )
        shift || fail "Source path must be given after keyword 'from'"
        ;;

      *)
        _directories+=( "${token}" )
        ;;
    esac
  done

  [[ -n "${_target}" ]] || fail "Target must be given."
  array_is_nonempty _directories || fail "Directories must be given."

  ensure_paths_exist "${_target}"

  for _path in "${_directories[@]}"
  do
    [[ -d "${_path}" ]] ||
      error "Cannot copy path ${_path} to ${_target},"\
      "as path (directory) '${_path}' does not exist (in '$PWD')."

    cp -Rf "${_path}" "${_target}/" ||
      fail "Could not copy the entity '${_entity}',"\
      "as the 'cp -Rf' command failed with error code '$?'."
  done
}

#
# ## copy\_path
#
# Copies a path (directory) from one location to another.
#
# ### Input Parameters
#
# The first parameter is the source path name.
# The second parameter is the target path name.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# If successful, a path is renamed (copyd).
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if the source path is not specified.
# Fails if the target path is not specified.
#
# ### Usage Examples
#
#     user$ copy_path "freetds-0.91rc"* to "freetds-0.91"
#
copy_path()
{
  trace_filter filesystem
  local _source _target

  while (( $# > 0 ))
  do
    token="$1"
    shift
    case "${token}" in
      to)
      _target="${1}"
      shift || fail "Target path must be given after keyword 'from'"
      ;;
      from)
      _source="${1}"
      shift || fail "Source path must be given after keyword 'from'"
      ;;
      *)
        if [[ -z "${_source}" ]]
        then
          _source="$token"

        elif [[ -z "${_target}" ]]
        then
          _target="$token"
        fi
        ;;
    esac
  done

  [[ -n "${_source}" ]] || fail "Cannot move file; Source must be given."
  [[ -n "${_target}" ]] || fail "Cannot move file, Target must be given."

  cp -Rf "${_source}" "${_target}" ||
    fail "Could not copy '${_source}' to '${_target}',"\
      "as the 'cp' command failed with error code '$?'."
}

#
# ## chown\_paths
#
# Change ownership of a list of paths.
#
# ### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ### Usage Examples
#
#     user$ chown_paths $USER "$HOME" "/usr/local"
#
chown_paths()
{
  trace_filter filesystem
  local _identity _path _recursive_flag=0 _command _flags=() _paths=()

  case "${1:-}" in
    (recursive|--recursive*)
      _flags+=(-R)
      shift # Remove the recursive flag parameter.
      ;;
    (*)
      _identity="${1:-}"
      ;;
  esac

  _identity="${1:-}"
  shift || fail "user[:group] was not given as the first parameter"

  _paths=("$@")
  shift || fail "No paths given after user and group first parameter"

  for _path in "${_paths[@]}"
  do
    [[ -n "${_path}" ]] || continue

    [[ -e "${_path}" ]] ||
      fail "Cannot chown path ${_path} to ${_identity},"\
      "as the path (directory) does not exist."

    chown ${_flags[*]} ${_identity} "${_path}" ||
      fail "Could not chown the path '${_path}' to '${_identity},"\
      "as the 'chown' command failed with error code '$?'."
  done
}

#
# ## chmod\_paths
#
# Change ownership of a list of paths.
#
# ### Input Parameters
#
# First parameter is the new owner[:group] of the paths.
# Remaining parameters are the path names/paths.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no new owner[:group] was specified.
# Fails if no list of paths was given.
#
# ### Usage Examples
#
#     user$ chmod_paths $USER "$HOME" "/usr/local"
#
chmod_paths()
{
  trace_filter filesystem
  local _permissions="${1:-}" _path _recursive_flag=0 _command _flags=()

  if [[ "${1:-}" == "--recursive" ]]
  then
    _recursive_flag=1
    shift
    _permissions="${1}"
  fi

  (( _recursive_flag == 0 )) || _flags+=(-R)

  shift || fail "Cannot chmod paths; user[:group] was not given as the first parameter."

  local _paths=("$@") # Set the paths array to the remaining parameters.

  array_is_nonempty _paths || fail "No files were given."

  for _path in "${_paths[@]}"
  do
    [[ -d "${_path}" ]] ||
      fail "Cannot chmod path ${_path} to ${_permissions},"\
      "as the path (directory) does not exist."

    chmod ${_flags[*]} ${_permissions} "${_path}" ||
      fail "Could not chmod the file '${_file}' to "\
      "'${_target}/${_file//*\/},"\
      "as the 'chmod' command failed with error code '$?'."

  done
}

#
# ## enter
#
# Changes the current working path ($PWD) to the given path with
# sanity checks.
#
# ### Input Parameters
#
# First parameter is the path to change into.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current working path (PWD) will become the given path if
# successful.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no path was given.
# Fails if the given path does not exist.
#
# ### Usage Examples
#
#     user$ enter "/usr/local/src"
#
enter()
{
  trace_filter filesystem
  local _path="${1:-}"

  shift || fail "No path was given."

  [[ -d "${_path}" ]] || fail "Cannot enter path '${_path}'; Path does not exist."

  builtin cd "${_path}" ||
    fail "Could not cd into the given path '${_path}'; "\
      "'cd' command failed with error code '$?'."
}

#
# ## path\_exists()
#
# Check if given path exists.
#
# ### Input Parameters
#
# First parameter is a path.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the named path exists.
# 1 if the named path does not exist or does not exist.
#
# ### Failure Scenarios
#
# Fails if no path name/path was given.
#
# ### Usage Examples
#
#     user$ path_exists /bin/sm
#     user$ echo $?
#     0
#
#     user$ path_exists /bin/asdfasdf
#     user$ echo $?
#     1
#
path_exists()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "No name/path was given."
  [[ -d "$_path" ]]
}

#
# ## path\_join()
#
# Joins path elements together passed as arguments into one path string.
#
path_join()
{
  trace_filter filesystem
  local IFS='/'
  printf "$*"
}

#
# ## directories\_in()
#
# Function Description
#
# ### Input Parameters
#
# Positional Parameter listing and descriptions.
#
# ### Stream Outputs
#
# What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
#
# ### Environmental effects
#
# What, if any, environmental side effects this function causes. 'None.' for none.
#
# ### Return Codes
#
# 0 if ...
# 1 if ...
#
# ### Failure Scenarios
#
# Fails if ...
#
# ### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
directories_in()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "path name was not given!"

  [[ -d "${_path}" ]] || fail "'${_path}' is not a path!"

  find "${_path}" -mindepth 1 -maxdepth 1 -type d
}

#
# ## directories\_in\_matching()
#
#
directories_in_matching()
{
  trace_filter filesystem
  local _pattern _path="${1:-}"
  shift     || fail "Path was not given!"
  [[ -d "${_path}" ]]    || fail "'${_path}' is not a path!"

  local _pattern="${2:-}"
  shift  || fail "'${_path}' is not a path!"

  find "${_path}" -mindepth 1 -maxdepth 1 -type d
}

#
# ## directories\_under()
#
#
directories_under()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift  || fail "Path was not given!"

  [[ -d "${_path}" ]] || fail "'${_path}' is not a path!"

  find "${_path}" -mindepth 1 -type d
}

#
# ## directories\_under\_matching()
#
#
directories_under_matching()
{
  trace_filter filesystem
  local _path="${1:-}"
  shift || fail "Path was not given as the first parameter."

  local _pattern="${1:-}"
  shift || fail "Pattern was not given as the second parameter."

  [[ -n "${_pattern}" ]] || fail "'${_path}' is not a path!"
  [[ -d "${_path}" ]]    || fail "'${_path}' is not a directory!"

  find "${_path}" -mindepth 1 -iname "${_pattern}" -type d
}

#
# ## full_path()
#
# return full path to given path.
#
# ### Input Parameters
#
# path.
#
# ### Stream Outputs
#
# full path
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no arguments are given.
# Fails if given path does not exists
#
# ### Usage Examples
#
# user$ cd ; sm call full_path test
# /home/user/test
#
full_path()
{
  trace_filter filesystem
  local _path="$1"
  shift || fail "Cannot go to path; No path was given."
  [[ -d "${_path}" ]] || fail "Path '${_path}' does not exist."
  (
  builtin cd "${_path}"
  pwd
  )
}
