#!/bin/sh

#
# # General Services functions.
#

# ## services\_list()
#
# Initialize service module.
#
ext_service_initialize()
{
  variable_is_nonempty init_scripts_path || init_scripts_path="$(init_scripts_path)"
  variable_is_nonempty confd_path        || confd_path="$(confd_path)"

  # TODO: Account for user service installs...
  # TODO: Merge service_paths and service_root_paths...

  # TODO: determine root_install vs user_install...
  if user_is_root
  then
    etc_path="/etc"
    var_path="/var"
  else
    etc_path="${packages_path}/active/etc"
    var_path="${packages_path}/active/var"
  fi

  : \
    "${service:="${extension:-${package_name}}"}" \
    "${service_version:="${package_version}"}" \
    "${prefix_path:="${sm_path}/active"}" \
    "${service_bin_path:="${active_path}/bin"}" \
    "${service_sbin_path:="${active_path}/sbin"}" \
    "${service_pid_path:="${var_path}/run/${service}"}" \
    "${service_spool_path:="${var_path}/spool/${service}"}" \
    "${service_config_path:="${etc_path}/${service}"}" \
    "${service_db_path:="${var_path}/db/${service}"}" \
    "${service_data_path:="${var_path}/db/${service}/${package_version}"}" \
    "${service_log_path:="${var_path}/log/${service}"}" \
    "${service_lock_path:="${var_path}/lock/${service}"}" \
    "${service_src_path:="${source_path}/${service}-${package_version}"}" \
    "${service_config_file:="${service_config_path}/${service}.conf"}" \
    "${service_log_file:="${service_log_path}/${service}.log"}" \
    "${service_pid_file:="${service_pid_path}/${service}.pid"}" \
    "${service_lock_file:="${service_lock_path}/${service}.lock"}" \
    "${service_run_as_root_flag:=0}"

  service_paths=(
  "${service_bin_path}"
  "${service_config_path}"
  "${service_pid_path}"
  "${service_spool_path}"
  "${service_data_path}"
  "${service_lock_path}"
  "${service_log_path}"
  )

  service_root_paths=(
  "${var_path}/spool/${service}"
  "${var_path}/log/${service}"
  "${var_path}/run/${service}"
  "${var_path}/lock/${service}"
  "${var_path}/db/${service}"
  )

  if user_is_root
  then
    if os_is_darwin
    then
      true "${service_user:="_${service}"}"
    else
      true "${service_user:="${service}"}"
    fi
  else
    true "${service_user:="$USER"}"
  fi

  local _path
  for _path in  "${install_path}/bin" "${install_path}/sbin"
  do
    if path_exists "$_path"
    then
      export PATH="${_path}:$PATH"
    fi
  done

  if variable_is_empty service_binary
  then
    if command_exists ${service}
    then
      service_binary="$(command -v ${service})"
    fi
  fi

  service_actions=( start stop restart )
  service_flags=()
  service_start_flags=()
  service_stop_flags=()
  service_restart_flags=()
  service_status_flags=()
  service_reload_flags=()

  export service_paths service_actions service_flags

  if file_is_nonempty "${service_pid_file}"
  then
    read -r service_pid < "${service_pid_file}"
  else
    service_pid=0
  fi

  export PATH="/bin:/usr/bin:${prefix_path}/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin:${PATH}"

  service_initialized=1
}

#
# ## services\_list()
#
# List installed services. These are extensions that have
# loaded the service module.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# A list of available services to install are printed to STDOUT of
# the calling environment.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# NIY
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ services_avilable
#     Available service listing has not yet been implemented.
#     This feature has not yet been implemented.
#
#
# # General Services functions.
#
#
# ## services\_list()
#
# List installed services. These are extensions that have
# loaded the service module.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# A list of available services to install are printed to STDOUT of
# the calling environment.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# NIY
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ services_avilable
#     Available service listing has not yet been implemented.
#     This feature has not yet been implemented.
#
services_avilable()
{
  extensions_installed module "ext/service" "$@"
}

services_list()
{
  local _action="${1:-}" _args

  shift || true

  case "${_action}" in
    (active)
      services_active "$@"
      ;;

    (available)
      services_available "$@"
      ;;

    (installed|*)
      services_installed "$@"
      ;;
  esac
}

#
# ## services\_installed()
#
# List installed services. These are extensions that have
# loaded the service module.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# A list of installed extensions that load the service module are printed
# to the STDOUT of the calling environment.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# NIY
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ services_installed
#     nginx unicorn redis postgresql
#
services_installed()
{
  # Notify that the services_installed() function has not yet been implemented.
  NIY "Installed services has not yet been implemented."
}

#
# ## services\_available()
#
# List available services. These are extensions that
# load the service module.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# A list of available extensions that load the service module are printed to
# STDOUT of the calling environment.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# NIY
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ services_available
#     nginx redis postgresql mongodb ...
#
services_available()
{
  # Notify that the services_available() function has not yet been implemented.
  NIY "Installed services has not yet been implemented."
}

#
# # Single Service functions.
#
#
# ## service\_setup()
#
# Service setup and configuration.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Creates a system service user with the same name as the service.
# Sets up the service init_d file from template, if it exists.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_setup
#     ...
#
service_setup()
{
  (( $# == 0 )) || service_cli $@

  local _path _file

  for _file in functions initialize cli
  do
    source_files "${extension_path}/modules/shell/${_file}"
  done

  if user_is_root
  then
    # TODO: create an 'user_exists' function and use it here.
    user_create_if_missing "${service_user}" with group "${service_user}" >/dev/null 2>&1

    ensure_paths_exist "${service_root_paths[@]}"

    chown_paths --recursively "${service_user}:${service_user}" "${service_root_paths[@]}"
  fi

  ensure_paths_exist "${service_paths[@]}" "${install_path}"

  for _path in "${service_paths[@]}"
  do
    if variable_is_nonempty _path
    then
      if path_exists "${_path}"
      then
        chown_paths --recursively "${service_user}:${service_user}" "${_path}"
      else
        warn "While chowning paths it was discovered that '${_path}' is in"\
          "fact nonexistent on the filesystem; this might indicate an error."
      fi
    fi
  done

  ! command_exists "${service}_service_setup" || "${service}_service_setup"

  service_install_init_d "${service}"
}

#
# # Single Service functions.
#
#
# ## service\_uninstall()
#
# Service uninstall and configuration.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Creates a system service user with the same name as the service.
# Sets up the service init_d file from template, if it exists.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_uninstall
#     ...
#
service_uninstall()
{
  NIY "service_uninstall() has not yet been implemented."
  # 1. Remove init scripts.
  # 2. Unload OS service hooks.
  # 3. Deactivate database path.
}

#
# ## service\_start()
#
# Starts the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if extension was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ extension=redis
#     user$ service_start
#     ...
#
service_start()
{
  (( $# == 0 )) || service_cli $@

  [[ -n "${service}" ]] || fail "To start a service, you must set the 'service' variable."

  if command_exists "${service}_start"
  then
    "${service}_start"
  else
    service_init_start
  fi
}

#
# ## service\_stop()
#
# stops the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_stop
#     ...
#
service_stop()
{
  variable_is_nonempty service ||
    fail "To start a service, you must set the 'service' variable."

  if command_exists "${service}_stop"
  then
    "${service}_stop"
  else
    service_init_stop
  fi
}

#
# ## service\_reload()
#
# Reloads the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_reload
#     ...
#
service_reload()
{
  (( $# == 0 )) || service_cli $@

  variable_is_nonempty service ||
    fail "To start a service, you must set the 'service' variable."

  if command_exists "${service}_reload"
  then
    "${service}_reload"
  else
    service_init_reload
  fi
}

#
# ## service\_restart()
#
# Restarts the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_restart
#     ...
#
service_restart()
{
  (( $# == 0 )) || service_cli $@

  variable_is_nonempty service ||
    fail "To start a service, you must set the 'service' variable."

  if command_exists "${service}_restart"
  then
    "${service}_restart"
  else
    service_init_restart
  fi
}

#
# ## service\_status()
#
# Status of the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_status
#     ...
#
service_status()
{
  (( $# == 0 )) || service_cli $@

  variable_is_nonempty service ||
    fail "To start a service, you must set the 'service' variable."

  if command_exists "${service}_status"
  then
    "${service}_status"
  else
    service_init_status
  fi
}

#
# ## service\_logtail()
#
# logtails the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_logtail
#     ...
#
service_logtail()
{
  (( $# == 0 )) || service_cli $@

  variable_is_nonempty service ||
    fail "To start a service, you must set the 'service' variable."

  if command_exists "${service}_logtail"
  then
    "${service}_logtail"
  else
    service_init_logtail
  fi
}

#
# ## service\_info()
#
# infos the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_info
#     ...
#
service_info()
{
  (( $# == 0 )) || service_cli $@

  [[ -n "${service}" ]] ||
    fail "In order to get info on a service, the 'service' variable must be set."

  if command_exists "${service}_info"
  then
    "${service}_info"
  else
    service_init_info
  fi
}

#
# ## service\_configcheck()
#
# configchecks the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_configcheck
#     ...
#
service_configcheck()
{
  (( $# == 0 )) || service_cli $@

  variable_is_nonempty service ||
    fail "To configcheck a service, the 'service' variable must be set."

  if command_exists "${service}_configcheck"
  then
    "${service}_configcheck"
  else
    service_init_configcheck
  fi
}

#
# ## service\_usage()
#
# usages the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_usage
#     ...
#
service_usage() {
  # TODO: Update this for service specific items.
  printf "
Usage:

  $0 [options]

Options:

  --prefix   - specify prefix path
  --src)     - specify source directory
  --user)    - specify user to install as
  --version) - specify version to install
  --licence) - view licence
  --help)    - view this usage information

  "
  return 0
}

#
# ## service\_cli()
#
# clis the given service using init scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Whatever stream output comes from the called init script.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if service was not set.
# Fails if the init script is missing or not executable.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_cli
#     ...
#
service_cli()
{
  local _ignored_args=() _service_args=( $@ ) _token

  number_of_args=${#extension_args[@]}

  for (( index=0 ; index < $number_of_args ; index++ ))
  do
    token="${extension_args[$index]}"

    case "$token" in
      user)
        service_user="${extension_args[$((++index))]}"
        [[ -n "${service_user}" ]] ||
          error "a user name must follow keyword 'user'"
        ;;
      version)
        service_version="${extension_args[$((++index))]}"
        [[ -n "${service_version}" ]] ||
          error "a version number string must follow keyword 'version'"
        ;;
      data)
        service_data_path="${_package_args[$((++index))]}"
        [[ -n "${service_data_path}" ]] ||
          error "a path must follow keyword 'data'"
        ;;
      pid)
        service_pid_path="${_package_args[$((++index))]}"
        [[ -n "${service_pid_path}" ]] ||
          error "a path must follow keyword 'pid'"
        ;;
      log)
        service_log_path="${_package_args[$((++index))]}"
        [[ -n "${service_log_path}" ]] ||
          error "a path must follow keyword 'log'"
        ;;
      config)
        service_config_path="${_package_args[$((++index))]}"
        [[ -n "${service_config_path}" ]] ||
          error "a path must follow keyword 'config'"
        ;;
      lock)
        service_lock_path="${_package_args[$((++index))]}"
        [[ -n "${service_lock_path}" ]] ||
          error "a path must follow keyword 'lock'"
        ;;
      db)
        service_db_path="${_package_args[$((++index))]}"
        [[ -n "${service_db_path}" ]] ||
          error "a path must follow keyword 'db'"
        ;;
      help)
        service_usage
        exit 0
        ;;
      --trace)
        set -o xtrace
        ;;
      *)
        _ignored_args+=("${token}")
        ;;
    esac
  done

  extension_args=( "${_ignored_args[@]}" )

  ext_service_initialize "${extension_args[@]}"
}

#
# ## service\_pid()
#
# List installed services. These are extensions that have
# loaded the service module.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# A list of extensions that load the service module are printed to STDOUT of
# the calling environment.
#
# ### Environmental effects
#
# Sets the variable 'service_pid' to contain the pid of the process or 0.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# None currently.
#
# ### Usage Examples
#
#     root# service=redis
#     root# service_pid
#     root# echo $service_pid
#     0
#
service_pid()
{
  local _path="${run_path:="/var/run"}/${service}"
  local _pid=0

  ensure_paths_exist "${_path}"

  if file_is_nonempty "${_path}/${service}.pid"
  then
    read -r _pid < "${_path}/${service}.pid"
    if os_is_linux
    then # Sanity check.
      if ! path_exists "/proc/${pid}"
      then
        _pid=0
        rm -f "${_path}/${service}.pid"
      fi
    fi
  fi

  service_pid=${_pid}

  return 0
}

#
# ## service\_load\_conf\_d()
#
# Load the /etc/conf.d/{service}.conf configuration file into the calling
# environment.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None, unless the configuration file contains any print statements.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_load_conf_d
#
service_load_conf_d()
{
  source_files "${confd_path}/${service}.conf"
}

#
# # Service init functions.
#
#
# ## service\_install\_init\_d()
#
# Installs the BDSM service module init.d script for the current extension.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging messages informing the end user of what is occurring.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_install_init_d
#
service_install_init_d()
{
  local _service="${1:-}" _version="${2:-${package_version}}"

  variables_must_be_nonempty _service

  path_exists "${init_scripts_path}" ||
    return 0 # No bin/ dir, no need for it to be in the path.

  if user_is_root
  then
    ensure_paths_exist "/etc/conf.d" "${init_scripts_path}"

    # TODO: Install the service init script...
    if template_exists "${_service}"
    then
      install_template "${_service}" to "${init_scripts_path}/${_service}" \
        mode 0755
    else
      # Use core svc init.d template
      install_template "cli/init.d" \
        to "${init_scripts_path}/${_service}" mode 0755

      seed_template "${init_scripts_path}/${_service}" \
        modules_path "${modules_path}" \
        service "${service}" \
        service_user "${service_user}" \
        service_config_path "${service_config_path}"
    fi

    service_activate "${service}" "${package_version}"

    # TODO: Replace this with install_template + seed_template
    write "%s\n" "[ -d \"${prefix_path}/${_service}/active/bin\" ] && " \
      to "/etc/profile.d/${_service}.sh"

    write "%s\n" "PATH=\"\$PATH:${prefix_path}/${_service}/active/bin\" ; export PATH; " \
      append to "/etc/profile.d/${_service}.sh"

    chmod_files 0755 "/etc/profile.d/${_service}.sh"
  fi
}

#
# ## service\_init\_start()
#
# This is the generalized service init start function.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging telling the end user what is happening.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_init_start
#
service_init_start()
{
  log "Starting ${service}..."

  local _result=0 _command=( "${service_binary}" )

  if array_is_nonempty service_start_flags
  then
    _command+=("${service_start_flags[@]}")
  fi

  if array_is_nonempty service_flags
  then
    _command+=("${service_flags[@]}")
  fi

  if (( service_run_as_root_flag == 1 ))
  then
    if user_is_not_root
    then
      prefix="sudo"
    else
      prefix=""
    fi

    if $prefix ${_command[*]}
    then
      true
    else
      error "${service} failed to start."
    fi
  else
    if user_run_as "${service_user}" "${_command[*]}"
    then
      succeed "${service} successfully started."
    else
      log "${service} failed to start; check ${service_log_file} for details:"
      exec tail -n 50 "${service_log_file}"
      error
    fi
  fi
}

#
# ## service\_init\_stop()
#
# This is the generalized service init stop function.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging telling the end user what is happening.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_init_stop
#
service_init_stop()
{

  (( service_pid > 0 )) || error "Service pid has not been set, or is zero."

  log "Stopping ${service}..."

  if command_exists "${service}_stop"
  then
    "${service}_stop"
  else
    if kill -QUIT "${service_pid}"
    then
      rm -f "$service_pid_file"
    else
      return $?
    fi
  fi
}

#
# ## service\_init\_status()
#
# This is the generalized service init status function.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging telling the end user what is happening.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_init_status
#
service_init_status()
{
  log "statusing ${service}..."

  local _command=( "${service_binary}" )

  if array_is_nonempty service_status_flags
  then
    _command+=("${service_status_flags[@]}")
  fi

  if array_is_nonempty service_flags
  then
    _command+=("${service_flags[@]}")
  fi

  if (( service_run_as_root_flag == 1 ))
  then
    if user_is_not_root
    then
      prefix="sudo"
    else
      prefix=""
    fi

    if $prefix ${_command[*]}
    then
      true
    else
      error "failed check status of ${service}."
    fi
  else
    if user_run_as "${service_user}" "${_command[*]}"
    then
      touch "$service_pid_file"
      succeed
    else
      error "failed check status of ${service}."
    fi
  fi
}

#
# ## service\_init\_reload()
#
# This is the generalized service init reload function.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging telling the end user what is happening.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_init_reload
#
service_init_reload()
{
  log "reloading ${service}..."

  local _command=( "${service_binary}" )

  if array_is_nonempty service_reload_flags
  then
    _command+=("${service_reload_flags[@]}")
  fi

  if array_is_nonempty service_flags
  then
    _command+=("${service_flags[@]}")
  fi

  if user_run_as "${service_user}" "${_command[*]}"
  then
    touch "$service_pid_file"
  else
    return $?
  fi
}

#
# ## service\_init\_usage()
#
# This is the generalized service init usage function.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging telling the end user what is happening.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_init_usage
#
service_init_usage()
{
  log "Usage:"
  log "  $0 {start|stop|restart|status|info|logtail}"
}

#
# ## service\_init\_logtail()
#
# This is the generalized service init logtail function.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging telling the end user what is happening.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_init_logtail
#
service_init_logtail()
{
  # TODO: Adjust this to allow for parameter passing.

  tail -n 10 "${service_log_file}"
}

#
# ## service\_init\_info()
#
# This is the generalized service init info function.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Outputs information about the service (version, etc...).
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_init_info
#
service_init_info()
{
  NIY "service_init_info has not yet been implemented for the service module."
}

#
# ## service\_conf\_d()
#
# Installs the conf.d template for the service, if it exists.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging updates to inform the user what is happening.
#
# ### Environmental effects
#
# Once completed a conf.d file should be in place.
# For example /etc/conf.d/redis.conf for the redis service.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_conf_d
#
service_conf_d()
{
  # TODO: Install a default conf.d template if extension does not define one.
  template_exists "conf.d" || return 0

  install_template "conf.d.template" to "/etc/conf.d/${service}.conf" \
    mode 0644 owner "${service_user}:${service_user}"

  if template_exists "/etc/conf.d/${service}.conf"
  then
    seed_template "/etc/conf.d/${service}.conf" \
      prefix_path "${prefix_path}" \
      init_scripts_path "${init_scripts_path}" \
      modules_path "${modules_path}" \
      confd_path "${confd_path}" \
      extension "${service}" \
      service "${service}"
  fi
}

#
# ## service\_init\_start()
#
# This is the generalized service init start function.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging telling the end user what is happening.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service_init_action start
#
service_init_action()
{
  local _action="${1:-}"

  service_load_conf_d

  if command_exists "${service}_${action}"
  then
    "${service}_${action}"
  else
    if [[ "${service_actions[*]}" = *[[:space:]]${action}[[:space:]]* ]]
    then
      service_init_${action}
    else
      service_init_usage
    fi
  fi

  return $?
}

#
# ## service\_init\_d()
#
# The main logic for generalized service init.d scripts.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging updates to inform the user what is happening.
#
# ### Environmental effects
#
# May alter the runstate of the service extension.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_init_d
#
service_init_d()
{
  service_load_conf_d # Load the configuration file.

  # Sanity checks go here.
  file_is_executable "${service_binary}" ||
    fail "Could not find ${service_binary}, or ${service_binary} is not executable."

  service_pid

  service_cli # Parse the script arguments and take action accordingly.

  service_init_action "${service_action}"
}

#
# ## service\_deactivate()
#
# Deactivates the named service.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging updates to inform the user what is happening.
#
# ### Environmental effects
#
# Changes the current or named service's init script to be nonexecutable.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_deactivate
#
service_deactivate()
{
  local _service="${1:-"${service}"}"

  [[ -n "${_service}" ]] ||
    fail "A service name must be set or passed in to deactivate a service."

  if file_exists "${init_scripts_path}/${_service}"
  then
    chmod_files 0644 "${init_scripts_path}/${_service}"

    if user_is_root
    then # Add service to system startup
      if os_is_darwin
      then
        true # TODO: launchctl

      elif command_exists rc-update
      then
        rc-update add ${service} default

      elif command_exists chkconfig
      then
        chkconfig ${service} on

      #elif command_exists svc
      #then
      #  svc ${service} on # TODO: daemontools start on boot

      else # Fall back on rc.local to start redis at system startup.
        if file_exists "/etc/rc.local" &&
          ! file_contains "/etc/rc.local" "${service} start"
        then
          write "${init_scripts_path}/${service} start" \
            append to /etc/rc.local
        fi
      fi
    fi
  fi
  # TDOO: hook into system's paths.
}

#
# ## service\_activate()
#
# Activates the named service.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Logging updates to inform the user what is happening.
#
# ### Environmental effects
#
# Changes the current or named service's init script to be nonexecutable.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure conditions currently.
#
# ### Usage Examples
#
#     user$ service=redis
#     user$ service_deactivate
#
service_activate()
{
  local _service="${1:-"${service}"}"

  [[ -n "${_service}" ]] ||
    fail "The service name must be set or passed in to activate a service."

  local _version="${2:-${package_version}}"

  variables_must_be_nonempty _service _version

  ! symlink_exists "${service_db_path}/active" ||
    service_deactivate "${_service}"

  if path_exists "${service_db_path}/${_version}"
  then
    log "Activating service ${_service} version ${_version}."

    link --force "${service_db_path}/${_version}" to "${service_db_path}/active"

    if file_exists "${init_scripts_path}/${service}"
    then
      chmod_files 0755 "${init_scripts_path}/${service}"

      if os_is_linux
      then
        if user_is_root
        then # Add service to system startup
          if command_exists rc-update
          then
            rc-update remove ${service} default

          elif command_exists chkconfig
          then
            chkconfig ${service} off

            #elif command_exists svc
            #then
            #  svc ${service} off
            #  TODO: daemontools remove start on boot

          else # Fall back on rc.local to start redis at system startup.
            file_contains "/etc/rc.local" "${service} start" ||
              sed -i -e "d#${init_scripts_path}/${service} start#" /etc/rc.local
          fi
        fi
      elif os_is_darwin
      then
        true # TODO: launchctl
      else # ::shrug::
        if file_exists "/etc/rc.local" &&
          ! file_contains "/etc/rc.local" "${service} start"
        then
          # TODO: change this to use replace_content
          sed -i -e "d#${init_scripts_path}/${service} start#" /etc/rc.local
        fi
      fi
    fi
  fi
}

#
# ## service\_status()
#
#
service_status()
{
  log "${service}:"

  if [[ -s "${service_pid_file}" ]] && (( $(head -1 ${service_pid_file}) > 0 ))
  then
    local pid=$(head -1 ${service_pid_file})
    local ps=$(ps -p ${pid} -ostate,sgi_rss,vsize | tail -1)

    log "  status: running"
    log "  version: ${service_version}"
    log "  process: "
    log "    pid: ${pid}"
    if os_is_linux
    then
      log "    parent_pid: $(awk  '/^PPid:/{print $2}' /proc/${pid}/status)"
      log "    state: $(printf "$ps" | awk '{print $1}')"
      log "    rss: $(printf "$ps" | awk '{print $2}')"
      log "    vsz: $(printf "$ps" | awk '{print $3}')"
    fi

    if command_exists lsof
    then
      local cwd= binary= libraries=() tcp_ports=() udp_ports=() sockets=() \
        logs=() string
      while read -r line
      do
        case "$line" in
          (*[[:space:]]cwd[[:space:]]*)
            cwd="${line##* }"
            ;;
          (*[[:space:]]txt[[:space:]]*)
            binary="${line##* }"
            ;;
          (*/lib/*)
            string="${line%% (*}"
            libraries+=("${string##* }")
            ;;
          (*.log*)
            logs+=("${line##* }")
            ;;
          (*.sock*)
            sockets+=("${line##* }")
            ;;
          (*TCP*)
            string="${line%% (*}"
            tcp_ports+=("${string##* }")
            ;;
          (*)
            true # ignore
          ;;
        esac
      done < <(lsof -U -p ${pid})

      log "    cwd: ${cwd}"
      log "    binary: ${binary}"

      if (( ${#logs[@]} > 0 ))
      then
        log "    logs:"
        array_sort_asc logs
        array_unique logs
        for log in "${logs[@]}"
        do
          printf "      - %s\n" "${log}"
        done
      fi

      if (( ${#libraries[@]} > 0 ))
      then
        log "    libraries:"
        array_sort_asc libraries
        array_unique libraries
        for library in "${libraries[@]}"
        do
          printf "      - %s\n" "${library}"
        done
      fi

      if (( ${#tcp_ports[@]} > 0 ))
      then
        log "    tcp_ports:"
        array_sort_asc tcp_ports
        array_unique tcp_ports
        for tcp_port in "${tcp_ports[@]}"
        do
          printf "      - %s\n" "${tcp_port}"
        done
      fi

      if (( ${#sockets[@]} > 0 ))
      then
        log "    sockets:"
        array_sort_asc sockets
        array_unique sockets
        for socket in "${sockets[@]}"
        do
          printf "      - %s\n" "${socket}"
        done
      fi
    fi
  else
    log "  status: not running."
  fi

  if command_exists "${service}_status"
  then # Run the service specific status function, if it exists
    "${service}_status"
  fi
}

service_signal()
{
  local _signal="${1}" _pid="${2:-0}"
  shift || fail "Cannot signal service;"\
    " Signal must be given as the first parameter and be one of:"\
    " {KILL,QUIT,TERM,USR1,USR2,TTIN,TTOU,a digit})."
  shift || fail "Cannot signal service;"\
    " Module name not given as second parameter."

  [[ -n "${_pid}" ]] ||
    fail "pid to signal must be passed in as the second parameter;"\
    " please check your code (see trace below.)"

  case "${_signal}" in
    KILL|QUIT|TERM|USR1|USR2|TTIN|TTOU|WINCH|[[:digit]]*)
      if (( _pid > 0 ))
      then
        kill -${_signal} ${_pid}
      else
        log "Not sending signal ${_signal} to process, as pid is 0 (process not found/running)."
      fi
      ;;
    *)
      fail "Signal must be one of:"\
        " {KILL,QUIT,TERM,USR1,USR2,TTIN,TTOU,a digit})."
      ;;
  esac
}
