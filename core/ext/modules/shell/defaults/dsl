#!/bin/sh

#
# ## read\_default()
#
# Reads default values from an extension's config/defaults file.
#
# ### Input Parameters
#
# First parameter is the defaults file key to read (key=value).
# Second parameter is the variable name to store the retrieved value in.
# Remaining parameters are parsed out as token, value and prefix
#   into|as <variable name>
#   prefix <name>
#   <variable> # If no specifier.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# A variable will be set to the value, if the value is nonempty. If no variable
# name is specified, the variable will be assigned the same name as the key.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no arguments are passed in; you must at least specify a key.
#
# ### Usage Examples
#
#     user$ read_default "version" prefix "package" # extension is nginx, for example.
#     user$ echo $package_version
#     1.0.0
#
# ### Notes
#
# read_default respects a tiered default file scheme,
#
#   "/etc/sm/${extension}/defaults"
#   "$HOME/.sm/${extension}/defaults"
#   "${extension_config_path}/defaults"
#
#
#
read_default()
{
  trace_filter read_config

  local key token _args=() _extension=${extension}

  key="${1:-}"

  shift || fail "$FUNCNAME: key to read must be given as first parameter."

  while (( $# > 0 ))
  do
    token="$1"
    shift
    case "$token" in
      for)
        _extension="$1"
        shift
        ;;
      *)
        _args+=( "$token" )
      ;;
    esac
  done

  read_config "${_extension}" defaults "${key}" "${_args[@]}"
}

read_config()
{
  trace_filter read_config

  local key variable token value prefix _file _temp \
    _extension="${1:-}" _config_file="${2:-}" key="${3:-}"

  shift || fail "$FUNCNAME: extension name must be given as the first parameter."
  shift || fail "$FUNCNAME: config file name must be given as the second parameter."
  shift || fail "$FUNCNAME: key name must be given as the third parameter."

  while (( $# > 0 ))
  do
    token="$1"
    shift
    case "$token" in
      into|as)
        variable="$1"
        shift || fail "$FUNCNAME: variable name must be given after keywords 'into|as'"
        ;;
      prefix)
        prefix="$1"
        shift || fail "$FUNCNAME: prefix must be given after keyword 'prefix'"
        ;;
      *)
        variable="$token"
        break
      ;;
    esac
  done

  if variable_is_empty variable
  then
    if variable_is_nonempty prefix
    then
      true "${variable:="${prefix:-}_$key"}"
    else
      true "${variable:="$key"}"
    fi
  fi

  # Run search in the same process to initialize cache variables.
  settings_search ${_extension} "${_config_file}" > /dev/null

  for _file in  $( settings_search ${_extension} "${_config_file}" )
  do
    if file_is_nonempty "${_file}"
    then
      _temp="$(hash_file "${_file}" "${key}")"

      if [[ -n "${_temp}" ]]
      then
        value="${_temp}"
      fi
    fi
  done

  eval "${variable}=\"${value}\""
}

settings_search()
{
  trace_filter settings_search

  local extension=$1 setting=$2 path paths

  paths=( "/etc/sm/${extension}" "$HOME/.sm/${extension}" ) # Standard paths

  ! extension_path "${extension}" ||
    paths+=( "${extension_path}/config" )

  for path in "${settings_search_path_append[@]}"
  do # Additional paths
    settings_search_path_update "${path}"
    paths+=( "${path}/${extension}" )
  done

  for path in "${paths[@]}"
  do # Print existing paths.
    if path_exists "${path}" && file_is_nonempty "${path}/${setting}"
    then
      printf "${path}/${setting}\n"
    fi
  done
}

settings_search_path_update()
{
  local path=$1

  ! string_contains "${settings_search_path_cache[*]}" "${path}" || return 0

  ! file_exists "${path}/.uri" ||
    fetch_uri "$(cat "${path}/.uri")" "${path}" >&2

  settings_search_path_cache+=( "${path}" )
}

