#!/usr/bin/env bash

# ## package\_error
#
# Presents the user with a package-related error message, including the tail
# of an optional log file.
#
# ### Input Parameters
#
# String to be logged; an optional log file containing more details, and
# an optional number of lines of the file to show (defaults to 25).
#
# ### Stream Outputs
#
# Prints arguments passed in to the calling environment's STDOUT,
# with a newline character appended, and 'ERROR ' prepended.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 1 for failure.
#
# ### Failure Scenarios
#
# Fails if no arguments are given.
#
# ### Usage Examples
#
#     user$ package_error "Hello there! " configure.log 5
#     ERROR Hello there!
#
#
#     Tail of configure.log:
#			checking for inflate in -lz... no
#			configure: error: zlib library not found
#			If you have zlib already installed, see config.log for details on the
#			failure.  It is possible the compiler isn't looking in the proper directory.
#			Use --without-zlib to disable zlib support.
#
#     *poof* shell closed...
#
package_error()
{
  local _message=$1 _log
  shift || fail "Cannot print a package error, as no message was provided."
  _log=$1

  if [[ -n ${_log} ]] && file_exists ${_log}
  then # Append tail of error log to the error message.
    local _num_lines=${3:-25} # Default the number of lines to 25
    _message="${_message}\n\nTail of ${_log}:\n$( tail -n ${_num_lines} ${_log} )"
  fi
  error "${_message}"
}

#
# ## package\_definition
#
# Enables module developers to easily set package variables in name, value pairs.
#
# ### Input Parameters
#
# Parameters must come in pairs, variable name first (without the 'package'
# prefix), value second.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# For each name/value pair, a variable package_${name} is created with the given
# value.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if extension developer accidentailly separates key/value with an = :)
# Fails if a key is given without a matching value.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_definition \
#         name "bash" \
#         version "4.2" \
#         url "ftp.gnu.org/gnu/bash/"
#
# ### Notes
#
# For readability, it is recommended to split the line into "key value" lines by
# ending the line with a single backslash '\' character, with no space afterwards.
#
package_definition()
{
  while (( $# > 0 ))
  do
    key="$1"
    shift
    value="$1"
    if ! shift
    then
      if echo "$key" | grep '='
      then
        fail "Invalid key '${key}'; Most likely the '=' is supposed to be a space?"
      else
        fail "Value not specified for key '${key}'; They should be specified in key/value pairs :)"
      fi
    fi

    case "$key" in
      name)
        package_name="${value}"
        ;;
      version)
        package_version="${value}"
        ;;
      file)
        package_file="${value}"
        ;;
      dir)
        package_dir="${value}"
        ;;
      url)
        package_url="${value}"
        ;;
      base_url)
        package_base_url="${value}"
        ;;
      docs_url)
        package_docs_url="${value}"
        ;;
      patches_url)
        package_patches_url="${value}"
        ;;
      md5_url)
        package_md5_url="${value}"
        ;;
      active_path)
        active_path="${value}"
        ;;
      bin_path)
        bin_path="${value}"
        ;;
      packages_path)
        packages_path="${value}"
        ;;
      source_path)
        source_path="${value}"
        ;;
      target_path)
        target_path="${value}"
        ;;
      archive_format)
        archive_format="${value}"
        ;;
      # TODO: Simplify into
      #(+([[[:alnum:]]|])_path|name|version|url|md5_url)
      #  eval "${key}=${value}"
      #  ;;
      *)
        fail "Unknown key '${key}' (value: ${value})."
      ;;
    esac
  done
}

#
# ## package\_install
#
# Performs all package installation steps:
# * download
# * extract
# * patch
# * confiure
# * build
# * install
# * postinstall
# * activation
# * service setup, if service module is loaded
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Steps performed are logged to STDOUT of the calling environment.
#
# ### Environmental effects
#
# Package installation artifacts are created in the system and source directories.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if any of the constituant components fail.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_definition \
#         name "bash" \
#         version "4.2" \
#         url "ftp.gnu.org/gnu/bash/"
#
# user$ package_install
#
# ### Notes
#
package_install()
{
  (( $# == 0 )) || package_init $@

  if symlink_exists "${packages_path}/${package_name}/active" \
  && [[ "${force_flag}" != "1" ]]
  then
    log "The ${package_name} ${package_version} package is already installed.
To force, call:\n\tbdsm ${package_name} package install --force\n"
    exit 0
  fi

  true "${package_dir:="${package_name}-${package_version}"}"

  ensure_paths_exist "${source_path}"

  enter "${source_path}"

  if command_exists "${package_name}_dependencies"
  then
    log_step "${package_name} ${package_version} ~ dependencies" \
      "${package_name}_dependencies"
  else
    log_step "${package_name} ${package_version} ~ dependencies" \
      package_dependencies
  fi

  if command_exists "${package_name}_prefetch"
  then
    log_step "${package_name} ${package_version} ~ prefetch" \
      "${package_name}_prefetch"
  fi

  if command_exists "${package_name}_fetch"
  then
    log_step "${package_name} ${package_version} ~ download" \
      "${package_name}_fetch"
  else
    log_step "${package_name} ${package_version} ~ download" \
      package_fetch
  fi

  enter "${source_path}/${package_dir}"

  if command_exists "${package_name}_postfetch"
  then
    log_step "${package_name} ${package_version} ~ postfetch" \
      "${package_name}_postfetch"
  fi

  if command_exists "${package_name}_patch"
  then
    log_step "${package_name} ${package_version} ~ patch" \
      "${package_name}_patch"
  else
    log_step "${package_name} ${package_version} ~ patch" \
      package_patch
  fi

  if command_exists "${package_name}_preconfigure"
  then
    log_step "${package_name} ${package_version} ~ preconfigure" \
      "${package_name}_preconfigure"
  fi

  if command_exists "${package_name}_configure"
  then
    "${package_name}_configure"
  else
    log_step "${package_name} ${package_version} ~ configure" \
      package_configure
  fi

  if command_exists "${package_name}_postconfigure"
  then
    log_step "${package_name} ${package_version} ~ postconfigure" \
      "${package_name}_postconfigure"
  fi

  if command_exists "${package_name}_build"
  then
    log_step "${package_name} ${package_version} ~ build" \
      "${package_name}_build"
  else
    log_step "${package_name} ${package_version} ~ build" \
      package_build
  fi

  if command_exists "${package_name}_preinstall"
  then
    log_step "${package_name} ${package_version} ~ preinstall" \
      "${package_name}_preinstall"
  else
    log_step "${package_name} ${package_version} ~ preinstall" \
      package_preinstall
  fi

  if command_exists "${package_name}_install"
  then
    log_step "${package_name} ${package_version} ~ install" \
      "${package_name}_install"
  else
    log_step "${package_name} ${package_version} ~ install" \
      package_make_install
  fi

  if command_exists "${package_name}_postinstall"
  then
    log_step "${package_name} ${package_version} ~ postinstall" \
      "${package_name}_postinstall"
  fi

  package_activate_if_first "${package_name}" "${package_version}"

  if command_exists "${package_name}_postactivate"
  then
    log_step "${package_name} ${package_version} ~ postactivate" \
      "${package_name}_postactivate"
  fi

  package_setup
}

#
# ## package\_update
#
package_update()
{
  (( $# == 0 )) || package_init $@

  # TODO: check if newer version exists, if so then...
  if package_installed | grep -q "${package_version}" && [[ "$1" != "--force" ]]
  then
    log "The latest version (${package_version}) of the ${package_name} package is already installed."
  else
    package_install ${package_name} ${package_version:-} ${archive_format:-} --force
    package_activate ${package_name} ${package_version}
  fi
}

#
# ## package\_fetch\_md5
#
# Fetches the package's md5 sum from the md5_url, if given.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# The 'package_md5' variable is set with the downloaded md5 sum.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if any of the constituant components fail.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_fetch_md5
#
# ### Notes
#
package_fetch_md5()
{
  (( $# == 0 )) || package_init $@

  local download_url

  : \
    "${package_file:="${package_name}-${package_version}.${archive_format}"}" \
    "${packge_md5_url:="${package_base_url}/${package_file}.md5"}" \
    "${package_md5:=$( hash_file "${extension_config_path}/md5" "${package_file}" )}"

  if [[ -z "${package_md5}" && -n "${package_md5_url}" ]]
  then
    curl -L "${packge_md5_url}" -o "${archives_path}/${package_file}.md5" 2>/dev/null ||
      error "Fetching MD5 checksum from '${package_md5_url}' failed."

    package_md5=$(cat "${archives_path}/${package_file}.md5")

    rm "${archives_path}/${package_file}.md5"
  else
    package_md5="" # not known.
  fi
}

#
# ## package\_fetch
#
# Fetches the package and extract it to source.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# scm output goes to STDERR of the calling environment.
#
# ### Environmental effects
#
# The archive file will be fetched to filesystem.
# The archive file will be extracted to filesystem.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_fetch
#
# ### Notes
#
package_fetch()
{
  (( $# == 0 )) || package_init $@

  : \
    "${package_file:="${package_name}-${package_version}.${archive_format}"}" \
    "${package_url:="${package_base_url}/${package_file}"}"

  package_fetch_md5

  fetch_uri "${package_url}" "${source_path}/${package_dir}" "${package_md5:-#}" ||
    return 1

  [[ -d "${source_path}/${package_dir}/${package_dir}" ]] || return 0

  mv "${source_path}/${package_dir}/${package_dir}"/* \
    "${source_path}/${package_dir}/"

  rm -rf "${source_path}/${package_dir}/${package_dir}/"
}

#
# ## package\_configure
#
# Configures the package source (eg. ./configure ...).
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Makefile will be generated for a standard package extension.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if configuration fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_configure
#
# ### Notes
#
package_configure()
{
  local _command

  if variable_is_nonempty configure_command
  then
    _command="${configure_command}"
  else
    export PREFIX="${install_base_path}/${package_version}"

    _command="./configure ${configure_flags[@]:-"--prefix=${install_path}"}"

    file_is_executable "configure" || return 0
  fi

  debug package "package_configure: ${_command}"

  ${_command} > configure.log 2>&1 ||
    package_error "Configuration of ${package_name} ${package_version} failed." "configure.log"
}

#
# ## package\_build
#
# builds the package source (eg. make)
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Makefile will be generated for a standard package extension.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if building fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_build
#
# ### Notes
#
package_build()
{
  local _command

  if [[ -n ${build_command:-} ]]
  then
    _command="${build_command}"
  else
    _command="make ${make_flags[@]:-"-j$(os_cpu_count)"}"
  fi

  debug package "package_build: ${_command}"

  ${_command} > build.log 2>&1 ||
    package_error "Compilation of ${package_name} ${package_version} failed! " "build.log"
}

#
# ## package\_preinstall
#
# Link compilation dir to installation dir/src
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Compilation dir will be available as src in installation directory
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# None
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_preinstall
#
# ### Notes
#
package_preinstall()
{
  link --force "${source_path}/${package_dir}" to "${install_path}/src"
}

#
# ## package\_make\_install
#
# make install  the package source (eg. make)
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Installation files will be installed to the install_path.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if make install fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_make_install
#
# ### Notes
#
package_make_install()
{
  local _command

  if [[ -n ${install_command:-} ]]
  then
    _command="${install_command}"
  else
    _command="make ${make_install_flags[@]:-install}"
  fi

  ${_command} > make.install.log 2>&1 ||
    package_error "Installation of ${package_name} ${package_version} failed! " "make.install.log"
}

#
# ## package\_activate
#
# activates the package
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Symlink will be created to the active version in the package install path.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if activating fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_activate
#
# ### Notes
#
package_activate()
{
  (( $# == 0 )) || package_init $@

  local _file _files=() _path _paths

  true "${install_path:="${packages_path}/${package_name}/${package_version}"}"

  if path_exists "${install_path}"
  then
    if symlink_exists "${packages_path}/${package_name}/active"
    then
      package_deactivate "${_package}"
    fi

    log_step "${package_name} ${package_version} ~ activate" \

    _paths=($( find "${install_path}" -type d ))
    for _path in "${_paths[@]}"
    do
      ensure_paths_exist "${active_path}${_path##${install_path}}"
    done

    _files=($( find "${install_path}" -type f ))
    for _file in "${_files[@]}"
    do
      link --force "${_file}" \
        to "${active_path}${_file##${install_path}}"
    done

    link --force "${install_path}" \
      to "${packages_path}/${package_name}/active"

    log_step success
  else
    warn "Skipping activation of ${package_name} ${package_version}, "\
      "as '${install_path}' does not exist."
  fi

  package_setup "${package_name}"
}

#
# ## package\_setup
#
# Sets up the package
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# ldconfig, profile.d and service (init.d / conf.d) files will be put in place
# on the system.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if setup fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_setup
#
# ### Notes
#
package_setup()
{
  local _package="${1:-${package_name}}"

  package_ldconfig "${_package}"

  package_profile_d "${_package}"

  if module_is_loaded "service"
  then
    service_setup "${_package}"
  fi

  if module_is_loaded "database"
  then
    database_setup "${_package}"
  fi
}

#
# ## package\_deactivate
#
# deactivates the package
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Active symlinks will be removed from the filesystem.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if deactivating fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_deactivate
#
# ### Notes
#
package_deactivate()
{
  local _package="${1:-"${package_name}"}" _file _files _version

  variables_must_be_nonempty _package

  if symlink_exists "${packages_path}/${_package}/active"
  then
    _version=$(readlink "${packages_path}/${_package}/active")
    _version=${_version##*/}
  else
    return 0
  fi

  log_step "${package_name} ${_version} ~ deactivate"

  true "${install_path:="${packages_path}/${_package}/${_version}"}"

  _files=($( find "${install_path}" -type f ))
  for _file in "${_files[@]}"
  do
    remove_files --force "${_file}"
  done

  _files=(
  "/etc/ld.so.profile.d/${_package}.conf"
  "/etc/profile.d/${_package}.sh"
  "${packages_path}/${_package}/active"
  )

  for _file in "${_files[@]}"
  do
    if file_exists "${_file}"
    then
      remove_files "${_file}"
    fi
  done

  log_step success
}

#
# ## package\_activate\_if\_first
#
# Activates the package version , if another package version has not yet been
# activated.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Active symlinks will be added to the filesystem if it is the first version
# installed.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if deactivating fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_activate_if_first
#
# ### Notes
#
package_activate_if_first()
{
  local _package="${1:-}" _version="${2:-}"

  variables_must_be_nonempty _package _version

  if path_exists "${install_path}"
  then
    symlink_exists "${packages_path}/${_package}/active" ||
      package_activate "${_package}" "${_version}"
  else
    log "'${install_path}' not found; skipping activation."
  fi
}

#
# ## package\_ldconfig
#
# Sets up system level ldconfigs for the package libraries.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Adjusts ldconfig configuration and runs ldconfig (on linux).
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if deactivating fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_ldconfig
#
# ### Notes
#
package_ldconfig()
{
  local _package="${1:-${package_name}}" _path _files _ldconfig="/sbin/ldconfig"
  variables_must_be_nonempty _package

  path_exists "${packages_path}/${_package}/active/lib" ||
    return 0 # no lib/ directory for activated package, no need to update ldconfig

  # TODO: Figure out if solaris and freebsd have an analog to this?
  if user_is_root
  then
    if os_is_linux
    then
      ensure_paths_exist "/etc/ld.so.conf.d"

      if ! file_exists "/etc/ld.so.conf.d/bdsm.conf"
      then
        write "${active_path}/lib\n" to "/etc/ld.so.conf.d/bdsm.conf"
        chmod_files 0444 "/etc/ld.so.conf.d/bdsm.conf"
      fi

      command_exists "${_ldconfig}" || ldconfig="ldconfig"

      log_step "${package_name} ${package_version} ~ ldconfig" \
        "${_ldconfig}" "${active_path}/lib"

    elif os_is_darwin
    then # Cluster Fuck!
      true
      # This should be handled by the profile.d?
      # _files=($(find "${packages_path}/${_package}/active" -mindepth 1 -maxdepth 1 -type d))
      # (( ${#_files[@]} > 0 )) && copy_files to "${packages_path}" "${_files[@]}"
    fi
  fi
}

#
# ## package\_profile\_d
#
# Sets up system level profile_d configuration for the package.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Updates profile_d configuration for the given package.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if profile_d setup fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_profile_d
#
# ### Notes
#
package_profile_d()
{
  local _package="${1:-${package_name}}"

  variables_must_be_nonempty _package

  if template_exists "profile.d.template"
  then
    log_step "Updating shell profile for ${_package}"

    ensure_paths_exist "${profile_d_path}"
    ensure_files_exist "${profile_path}"

    install_template "profile.d" to "${profile_d_path}/${_package}.sh" mode 0755

    log_step success
  fi
}

#
# ## package\_uninstall
#
# Uninstalls the package.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Uninstalls the package install effects from the system.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if uninstall fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_uninstall
#
# ### Notes
#
package_uninstall()
{
  (( $# == 0 )) || package_init $@

  log_step "${package_name} ${package_version} ~ uninstall" \

  if package_is_active "${package_name}" "${package_version}"
  then # Deactivate the package if active.
     package_deactivate "${package_name}"
  fi

  remove_paths "${install_path}"

  if module_is_loaded service
  then # Remove any service reminants.
     service_uninstall
  fi

  log_step success
}

#
# ## package\_patch
#
# Applies any patches found for the current package.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# Updates the source code directory for the package with any patches found.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if patching fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_patch
#
# ### Notes
#
package_patch()
{
  local _patches _patch _path _paths

  _paths=(
  "${extension_patches_path}"
  "${extension_patches_path}/$(os_type)"
  "${extension_patches_path}/$(os_type)/${package_version}"
  )

  for _path in "${_paths[@]}"
  do
    path_exists "${_path}" || continue # No patch path
    _patches=($(find "${_path}" -mindepth 1 -maxdepth 1 -iname '*.patch' -type f))
    (( ${#_patches[@]} > 0 )) || continue # No patches
    package_apply_patches "${_patches[@]}"
  done
}

#
# ## package\_apply\_patches
#
# Applies patches found
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Applies any patches found for the current package.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if apply_patches fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_apply_patches
#
# ### Notes
#
package_apply_patches()
{
  local _patch _patches=("$@")

  array_is_nonempty _patches ||
    fail "Cannot apply patches, as no patches were given."

  for _patch in "${_patches[@]}"
  do
    log "TODO: patch application is NIY (see package_patch())"
  done
}

#
# ## package\_usage
#
# Sets up system level usage configuration for the package
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Updates usage configuration for the given package.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if usage setup fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_usage
#
# ### Notes
#
package_usage() {
  log "
  Usage:

  $0 [options]

  options:

  --prefix   - specify prefix path
  --src)     - specify source directory
  --data)    - specify data directory
  --user)    - specify user to install as
  --version) - specify version to install
  --licence) - view licence
  --help)    - view this usage information

  "
}

#
# ## package\_cli
#
# Parses package CLI arguments.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Updates cli configuration for the given package.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if cli setup fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_cli
#
# ### Notes
#
package_cli()
{
  local _ignored_args=() _token

  number_of_args=${#extension_args[@]}

  for (( index=0 ; index < $number_of_args ; index++ ))
  do
    _token="${extension_args[$index]}"

    case "${_token}" in
      --prefix)
        packages_path="${extension_args[$((++index))]}"
        ;;
      --src)
        src_path="${extension_args[$((++index))]}"
        ;;
      --data)
        data_path="${extension_args[$((++index))]}"
        ;;
      --user)
        package_user="${extension_args[$((++index))]}"
        ;;
      --version)
        package_version="${extension_args[$((++index))]}"
        ;;
      --base_url)
        package_base_url="${extension_args[$((++index))]}"
        ;;
      --file)
        package_file="${extension_args[$((++index))]}"
        ;;
      --force)
        force_flag=1
        ;;
      --static)
        configure_flags+=( --static )
        static_flag=1
        ;;
      --shared)
        shared_flag=1
        configure_flags+=( --enable-shared )
        ;;
      --directory)
        package_directory="${extension_args[$((++index))]}"
        ;;
      --archive_format)
        archive_format="${extension_args[$((++index))]}"
        ;;
      --activate|activate)
        # TODO: Throw error if parameter is not specified.
        (( ${#extension_args[@]} > 0 )) ||
          error "Cannot activate ${extension}, no version was given."

        if [[ "${extension}" == "pkg" ]]
        then
          array_shift extension_args
          package_activate "${extension_args[@]}"
        else
          package_activate "${extension}" "${extension_args[@]}"
        fi
        exit $?
        ;;
      --deactivate|deactivate)
        package_deactivate "${extension}"
        ;;
      --md5)
        package_md5="${extension_args[$((++index))]}"
        ;;
      --licence)
        extension_license
        succeed
        ;;
      --help)
        package_usage
        succeed
        ;;
      --with*|--enable*|--disable*)
        configure_flags+=("${_token}" "${extension_args[$((++index))]}")
        ;;
      --trace)
        set -o xtrace
        ;;
      *)
        _ignored_args+=("${_token}")
        ;;
    esac

  done

  extension_args=( "${_ignored_args[@]}" )

  package_init "${extension_args[@]}"
}

#
# ## package\_active
#
# Parses package active arguments.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Updates active configuration for the given package.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if active setup fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_active
#
# ### Notes
#
package_is_active()
{
  local _name="${1:-}" _version="${2:-}"

  shift || fail "Cannot query if a package is active;"\
    " No package name was given, or name is empty."

  local _path="${packages_path}/${_name}"

  if shift
  then # version was passed
    [[ -d "${_path}/${_version}" ]]
  else # version was not passed
    [[ -L "${_path}/active" && -d $(readlink "${_path}/active") ]]
  fi
}

#
# ## package\_must\_be\_active
#
# Parses package must be arguments.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Updates must be configuration for the given package.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if must be setup fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_must be
#
# ### Notes
#
package_must_be_active()
{
  local _name="${1:-}"

  shift || fail "Cannot ensure that package is active;"\
    "No package name was given (or name is empty.)"

  package_is_active "${_name}" ||
    error "Install/activate the node package extension, before installing ${_name}."
}

#
# ## packages\_must\_be\_active
#
# Parses package must_be_active arguments.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# none.
#
# ### Environmental effects
#
# Updates must_be_active configuration for the given package.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Errors halting program if must_be_active setup fails for any reason.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ packages_must_be_active
#
# ### Notes
#
packages_must_be_active()
{
  local _package _packages="$@"

  array_is_nonempty _packages || fail "Cannot ensure that packages are active;"\
    "No packages were given."

  for _package in "${_packages[@]}"
  do
    package_must_be_active "${_package}"
  done
}

#
# ## package\_docs
#
# Opens package documentation website, either in the web browser (if able),
# or via curl through PAGER (defaulting to less).
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None, if can open web browser or website docs in PAGER otherwise.
#
# ### Environmental effects
#
# Documentation opens in web browser or PAGER.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Error if package_docs_url has not been set.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_docs
#
# ### Notes
#
package_docs()
{
  os_open "${package_docs_url}"
}

#
# ## package\_website
#
# Opens package documentation website, either in the web browser (if able) or via
# curl through PAGER (defaulting to less).
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None if can open web browser or website website in PAGER otherwise.
#
# ### Environmental effects
#
# Web browser will open with documentation url if able.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Error if package_website_url has not been set.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_website
#
# ### Notes
#
package_website()
{
  os_open "${package_website_url}"
}

package_dependencies()
{
  local dependency _dependencies=(${package_dependencies[@]}) _missing_dependencies=()

  unset package_dependencies

  # TODO: improve dependency management.
  for dependency in "${_dependencies[@]}"
  do
    package_is_active ${dependency/-/ } || _missing_dependencies+=( ${dependency} )
  done
  if array_is_nonempty _missing_dependencies
  then
    local IFS=','
    error "${extension} requires ${_missing_dependencies[*]}.\n
Please install via bdsm package module, and retry. Typically, this can be done as follows:\n
\tbdsm ${_missing_dependencies[*]} package install\n"
  fi
}


#
# ## package\_info
#
# Displays package information.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# Steps performed are logged to STDOUT of the calling environment.
#
# ### Environmental effects
#
# Package installation artifacts are created in the system and source directories.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if any of the constituant components fail.
#
# ### Usage Examples
#
# Example Usage:
#
# user$ package_info "bash"
#
# default_version: "4.2"
# base_url "ftp.gnu.org/gnu/bash/"
# ...
#
# user$ package_info
#
# ### Notes
#
package_info()
{
  (( $# == 0 )) || package_init $@

  local _path="${packages_path}/${package_name}"
  : \
    "${package_dir:="${package_name}-${package_version}"}" \
    "${package_url:="${package_base_url}/${package_file}"}"

  log "versions:"
  if path_exists "${_path}"
  then
    local _installed=($( package_installed ${package_name} ${package_version} ))
    log "  installed: ${_installed[*]}"
  else
    log "  installed: none"
  fi
  log "  default: ${package_default_version}"

  if [[ -d "${_path}" ]] && [[ -L "${_path}/active" ]]
  then
    log "  active: $(readlink "${_path}/active")"
  else
    log "  active: none"
  fi

  log "urls:"
  log "  base: ${package_base_url}"
  log "  download: ${package_url}"
  log "archive: ${package_file}"
  log "source_path: ${source_path}/${package_dir}"

  if array_is_nonempty package_dependencies
  then
    log "dependencies: ${package_dependencies[*]}"
  fi
}

package_installed()
{
  local _path="${packages_path}/${package_name}"

  find "${_path}" -mindepth 1 -maxdepth 1 -type d |
  sed -e 's#\./##g' -e 's# #,#g' -e "s#${_path}/##"
}

package_man()
{
  (( $# == 0 )) || package_init $@

  true "${package_path:="${packages_path}/${package_name}/${package_version}"}"

  MANPATH="${package_path}/man"

  if path_exists $MANPATH
  then
    man ${extension_actions[@]:-${package_name}} || true
  else
    error "No man page available for package ${package_name} ${package_version}"
  fi
}

# pkg functions
packages_installed()
{
  find "${bdsm_path}/pkg" -mindepth 2 -maxdepth 2 -type d |
    awk -F'/' '! /\/active\//{print $(NF - 1)}'
}

packages_active()
{
  local _found _package _packages=()

  if [[ -z ${1:-} ]]
  then
    _found=($(
    find "${bdsm_path}/pkg" -name active -mindepth 2 -maxdepth 2 -type l |
    awk -F'/' '! /\/active\//{print $(NF - 1)}'
    ))
  else
    _packages="${1//,/ }"

    _found=($(
    find "${bdsm_path}/pkg" -name active -mindepth 2 -maxdepth 2 -type l |
    awk -F'/' '! /\/active\//{print $(NF - 1)}' | awk "/${_packages// /|}/"
    ))
  fi

  for _package in "${_found[@]}"
  do
    if [[ -L "${bdsm_path}/pkg/${_package}/active" ]]
    then
      readlink "${bdsm_path}/pkg/${_package}/active" |
        awk -F'/' '{print $(NF-1) ":" $NF}'
    fi
  done
}

packages_available()
{
  extensions_installed module "ext/package" "$@"
}

packages_list()
{
  local _action="${1:-}" _args

  [[ -z "${_action}" ]] || shift

  case "${_action}" in
    (active)
      packages_active "$@"
      ;;

    (available)
      packages_available "$@"
      ;;

    (installed|*)
      packages_installed "$@"
      ;;
  esac
}

package_init()
{
  package_name="${1:-${package_name:-${extension}}}"
  [[ -n "${package_name}" ]] ||
    fail "$FUNCNAME(): Package name must be given as first parameter.\n"

  case "${package_name}" in
    *=*) # exact version specifier
      package_version="${package_name#*=}"
      package_name="${package_name%%=*}"
      ;;
    *:*) # minimum version specifier
      # TODO: concept of 'minimum' ;)
      package_version="${package_name#*:}"
      package_name="${package_name%%:*}"
      ;;
    *)
      package_version="${2:-${package_version:-}}"
      ;;
  esac

  archive_format="${3:-${archive_format:-"tar.gz"}}"

  # Ensure that package_version is set at this point
  variable_is_nonempty package_default_version || read_default version prefix package_default for ${package_name}
  variable_is_nonempty package_version         || package_version="${package_default_version}"

  [[ -n "${package_version}" ]] ||
    fail "$FUNCNAME(): Package version must be specified.\n"\
    "(For example version=x.y.z set in extension's config/defaults file.)\n"

  variable_is_nonempty archive_format    || read_default archive_format             for ${package_name}
  variable_is_nonempty package_base_url  || read_default base_url prefix package    for ${package_name}
  variable_is_nonempty package_md5_url   || read_default md5_url  prefix package    for ${package_name}
  variable_is_nonempty website_url       || read_default website_url prefix package for ${package_name}
  variable_is_nonempty init_scripts_path || init_scripts_path="$(init_scripts_path)"

  true "${archive_format:=tar.gz}"
  true \
    "${package_file:="${package_name}-${package_version}.${archive_format}"}" \
    "${install_base_path:="${packages_path}/${package_name}"}"

  variable_is_empty    package_version   || install_path="${install_base_path}/${package_version}"

  if user_is_root
  then
    true \
      "${log_path:="/var/log/${package_name}"}" \
      "${package_user:="${package_name}"}"
  else
    true \
      "${log_path:="${packages_path}/log"}" \
      "${package_user:="$USER"}"
  fi

  extension_patches_path="${extension_path}/patches"

}
