#!/bin/sh

#TODO: rename module to execution and move extension_action to actions (reneme actions->detection)

detect_action_type()
{
  local _path="${action_path:-}"

  case "${action}" in
    (*\(\))
      action_type="function"
      return 0
      ;;
    (*)
      _path_type="$(file "${_path}/${action}")"
      ;;
  esac

  case "${_path_type}" in

    (*sh[[:space:]]script*|*POSIX[[:space:]]shell*|*Bourne-Again*)
      action_type="shell"
      ;;

    (*ASCII*)
      # Launch with helper DSL, if possible.
      extension="${_path//.}"

      case "${extension}" in
        (shell|zsh|bash|sh)
          action_type="shell"
          #rb) action_type="ruby"   ;;
          ;;
        (*)
          read -r shebang < "${_path}"

          case "${shebang}" in
            *ruby|*rbx|*jruby|*macruby)
              binary="${shebang##*(#|!)}"
              binary="${binary##* }"
              action_type="ruby"
              ;;
            (*)
              if [[ -x "${_path}" ]] ; then
                action_type="binary"
              else
                action_type="not executable"
              fi
              ;;
          esac
          ;;
      esac
      result=$?
      ;;

    (cannot[[:space:]]open)
      action_type="dne"
      ;;

    (*)
      if file_is_executable "${_path}"
      then
        action_type="binary"
      else
        action_type="noexec"
      fi
      ;;
  esac

  return $?
}

extension_modules_load()
{
  local _token _namespace=""

  module_name="${extension}"
  module "$module_name"

  while (( $# > 0 ))
  do
    _namespace+="/$1"
    shift

    module_name="${extension}${_namespace}"
    module "$module_name" || true
  done
}

extension_action_prerequisites()
{
  trace_filter action_pre
  local _pre _name

  _pre=(
   ${action}_cli
   ${action}_initialize
  )

  string_contains "${_pre[*]}" "${action%%_*}_cli" || _pre+=(
   ${action%%_*}_cli
   ${action%%_*}_initialize
  )

  string_contains "${_pre[*]}" "${extension}_cli" || _pre+=(
   ${extension}_cli
   ${extension}_initialize
  )

  for _name in ${_pre[@]}
  do
    if command_exists "${_name}"
    then
      "${_name}" "${extension_args[@]}"
    fi
  done
}

extension_run()
{
  trace_filter extension_run

  local _type="${action_type:-}" _path="${action_path:-}" _namespaces

  builtin cd "${initial_pwd}"

  # Now launch the extension, based on the determined _type.
  case "${_type}" in
    (function)
      _namespaces=${_path##${extension_actions_path}}
      extension_modules_load ${_namespaces//\// }

      action=${action%%(*}
      extension_action_prerequisites
      action_call "${action}" "${extension_args[@]}"
      ;;

    (shell)
      [[ "${action##*/}" != help ]] || modules ext/help

      _namespaces=${_path##${extension_actions_path}}
      extension_modules_load ${_namespaces//\// }

      extension_action_prerequisites
      action_source "${_path}/${action}" "${extension_args[@]}"
      ;;

    (ruby)
      requires=()
      for script in functions initialize
      do
        requires+=( "-r${modules_path}/ruby/core/${script}.rb" )
      done

      "${binary:-ruby}" -I"${modules_path}/ruby" -I"${extension_modules_path}/ruby" \
        ${requires[@]} "${_path}/${action}"
      ;;
    # python|lua|javascript)
      #   ADD "${modules_path}/${_type}/" to the lib path so the script can require "sm"
      #  "${_path}"
      #  ;;

    (dne|noexec)
      fail "Processing ${action} failed; file type is unknown, file does not exist, or file is not executable."
      ;;

    (binary|*)
      "${_path}/${action}" ${extension_action} "${extension_args[@]}"
      ;;
  esac
}

#
# ## extension\_action()
#
# Load the environment for a given extension action, then call it.
# This is the main function for BDSM.
#
# ### Input Parameters
#
# One or more extension names.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's initialize file will be resourced into the current
# environment.
#
# ### Return Codes
#
# 0 for success.
# 1 for failure
#
# ### Failure Scenarios
#
# Fails if no extension was given.
# Fails if no action was given.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/bin/sm
#     modules ext/extensions
#     extension_action ext list
#
#     $  $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis svc tig tmux zeromq zlib
#
#
extension_action()
{
  (( extension_action_calls == 0 )) ||
    fail "Cannot call a 2nd time, args: ${extension_args[*]}"

  extension_action_calls+=1

  unset extension action

  #TODO: Should be moved to core/cli?
  case "${extension_args[0]}" in
    (*=*) # exact version specifier
      package_name="${extension_args[0]}"
      export package_version="${package_name##*=}"
      export package_name="${package_name%%=*}"
      export extension="${package_name}"
      extension_args[0]="${extension}"
      ;;
    (*:*)
      package_name="${extension_args[0]}"
      export package_version="${package_name##*:}"
      export package_name="${package_name%%:*}"
      export extension="${package_name}"
      extension_args[0]="${extension}"
      ;;
  esac

  if in_search_paths detect_cached_action "${extension_args[@]}"
  then
    log_search action "$action" "${action_path##${sm_path}\/} params:${extension_args[@]}"
  else
    if in_search_paths detect_extension_existence "${extension_args[@]}" \
    && [[ "${extension}" == "${extension_args}" ]]
    then
      log_search extension "$extension" "$extensions_path"
      error "Unknown action path: "${extension_args[@]}"\n\nUsage: \n  sm extension [namespace] [action].\n"
    else
      error "Could not find extension: "${extension_args}"\n"
    fi
  fi

  extension_path="$extensions_path/$extension"
  extension_config_path="$extension_path/config"
  extension_templates_path="$extension_path/templates"
  extension_modules_path="$extension_path/modules"
  extension_actions_path="$extension_path/actions"
  extension_log_path="$log_path/$extension"

  paths=$(env | awk -F= -v ORS=' ' '/_path/{print $1}')
  flags=$(env | awk -F= -v ORS=' ' '/_flag/{print $1}')

  debug search "environment:
  action=${action}
  action_path=${action_path}
  extension_args=${extension_args}
  extension_path=${extension_path}
  extension_config_path=${extension_config_path}
  extension_templates_path=${extension_templates_path}
  extension_modules_path=${extension_modules_path}
  extension_actions_path=${extension_actions_path}
  extension_log_path=${extension_log_path}"

  enter "${extension_path}"
  sm_exports
}

extensions_installed()
{
  local _token _type _modules _paths=() _excludes=() _exclude

  args="$*"

  while (( $# > 0 ))
  do
    _token="$1"
    shift
    case "${_token}" in
      (sets|exts)
        _paths+=("${sm_path}/${_token}")
        ;;
      (module|type)
        _type="$1"
        shift || fail "An module type must follow the '${_token}' keyword"
        ;;
      (in)
        _paths="${1}"
        shift || fail "A path must follow keyword 'in'"
        ;;
      (exclude)
        _exclude="${1}"
        shift || fail "A string must follow keyword 'exclude'"
        _excludes+=("${_exclude//,/ }")
        ;;
      (*)
        fail "Unkown token ${_token} given"
        ;;
    esac
  done

  [[ -n ${_paths:-} ]] || {
    _paths=( "${sm_path}/sets" "${sm_path}/exts" )
    ensure_paths_exist "${_paths[@]}"
  }

  _modules=($( find "${_paths[@]}" -mindepth 2 -name "modules" -type f ))

  _excludes="${_excludes[*]:-'#'}"

  if [[ -n "${_type:-}" ]]
  then # Filter by type given
    "${sm_path}/bin/sm-ll" \
      if grep -q "'${_type}'" {} \; then echo {} \; fi ::: ${_modules[@]} |
        sed -e "s#${sm_path}/sets/##" -e "s#${sm_path}/exts/##" \
          -e "s#/modules/shell/modules##" | sort | awk '!'"/${_excludes// /|}/"
  else
    echo ${_modules[@]} | awk '!'"/${_excludes// /|}/"
  fi
}
