#!/bin/sh

# find modules on path and return the longest module path on top
detect_modules_paths()
{
  local root="$1" path="" IFS='/'
  shift || fail "Cannot detect modules path;"\
    "modules root was not given as the first parameter."
  _module_definitions=( )
  while (( $# > 0 ))
  do
    if is_module "${root}${path}"
    then
      _module_definitions=( "${path##\/}=$*" ${_module_definitions[@]} )
    else
      break
    fi
    path+="/$1"
    shift
  done
}

detect_module_modules_action()
{
  debug detect_module_modules_action "start:$*:"

  local _modules_path="${1:-}" _module_path="${2:-}" _module_params="${3:-}" \
    _module_name module_path

  shift || fail "modules path was not given as the first parameter"
  shift || fail "another modules path was not given as the second parameter"
  shift || fail "module parameters were not given as the third parameter"

  if [[ -s "${_modules_path}/${_module_path}/modules" ]]
  then
    for _module_name in $( cat "${_modules_path}/${_module_path}/modules" )
    do
      if in_search_paths detect_module "${_module_name}"
      then
        if [[ -s "${module_path}/actions" ]]
        then
          local _params="" _action="${_module_params}" _read_action
          while [[ -n "${_action}" ]]
          do
            if [[ -f "${module_path}/actions" ]] &&
              file_contains "${module_path}/actions" "${_action}="
            then
              _read_action=$( hash_file "${module_path}/actions" "${_action//\//\/}" )
              if [[ -n "$_read_action" ]]
              then
                action="$_read_action"
                action_path="$extensions_path/$extension/actions/${_module_path// /\/}"
                extension_args=( $_params )
                return 0
              fi
            fi
            if [[ "$_action" =~ "/" ]]
            then
              _params="${_action##*/} $_params"
              _action="${_action%/*}"
            else
              break
            fi
          done
        fi
      fi
    done
  fi
  return 1
}

# Search for extension that modules dependency providing matching [namespace...] action.
detect_modules_action()
{
  trace_filter modules_action

  extensions_path="${1:-}" extension="${2:-}"
  shift || fail "cannot detect modules action;"\
    " Extensions path was not given as first parameter."
  shift || fail "cannot detect modules action;"\
    " Extension name was not given as second parameter."

  local token _word _modules_path="$extensions_path/$extension/modules/shell"
  local __params=("$@") _module_path _module_params _module_name

  # first level modules dependency
  local _module_definition _module_definitions=()
  detect_modules_paths "${_modules_path}" "${__params[@]}"

  for _module_definition in "${_module_definitions[@]}"
  do
    _module_path="${_module_definition//=*}"
    _module_params="${_module_definition//*=}"
    if detect_module_modules_action \
      "${_modules_path}" "${_module_path}" "${_module_params}"
    then
      return 0
    fi
  done

  # second level modules dependency
  local _found_modules_paths
  _found_modules_paths=( $(find "${_modules_path}" -mindepth 2 -maxdepth 3 -name modules 2>/dev/null || true) )
  for _module_path in ${_found_modules_paths[@]}
  do
    _module_path="${_module_path##${_modules_path}\/}"
    _module_path="${_module_path%\/modules}"
    _module_params="${__params[*]}"
    _module_params="${_module_params// //}"
    if detect_module_modules_action \
      "${_modules_path}" "${_module_path}" "${_module_params}"
    then
      return 0
    fi
  done

  return 1
}

detect_action_type()
{
  local _path="${action_path:-}"

  case "${action}" in
    (*\(\))
      action_type="function"
      return 0
      ;;
    (*)
      _path_type="$(file "${_path}/${action}")"
      ;;
  esac

  case "${_path_type}" in

    *sh[[:space:]]script*|*POSIX[[:space:]]shell*|*Bourne-Again*)
      action_type="shell"
      ;;

    *ASCII*)
      # Launch with helper DSL, if possible.
      extension="${_path//.}"

      case "${extension}" in
        shell|zsh|bash|sh)
          action_type="shell"
          #rb) action_type="ruby"   ;;
          ;;
        *)
          read -r shebang < "${_path}"

          case "${shebang}" in
            *ruby|*rbx|*jruby|*macruby)
              binary="${shebang##*(#|!)}"
              binary="${binary##* }"
              action_type="ruby"
              ;;
            *)
              if [[ -x "${_path}" ]] ; then
                action_type="binary"
              else
                action_type="not executable"
              fi
              ;;
          esac
          ;;
      esac
      result=$?
      ;;

    cannot[[:space:]]open)
      action_type="dne"
      ;;

    *)
      if file_is_executable "${_path}"
      then
        action_type="binary"
      else
        action_type="noexec"
      fi
      ;;
  esac

  return $?
}

extension_modules_load()
{
  local _token _namespace=""

  module_name="${extension}"
  module "$module_name"

  while (( $# > 0 ))
  do
    _namespace+="/$1"
    shift

    module_name="${extension}${_namespace}"
    module "$module_name" || true
  done
}

extension_action_prerequisites()
{
  trace_filter action_pre
  local _pre _name

  _pre=(
   ${action}_cli
   ${action}_initialize
  )

  string_contains "${_pre[*]}" "${action%%_*}_cli" || _pre+=(
   ${action%%_*}_cli
   ${action%%_*}_initialize
  )

  string_contains "${_pre[*]}" "${extension}_cli" || _pre+=(
   ${extension}_cli
   ${extension}_initialize
  )

  for _name in ${_pre[@]}
  do
    ! command_exists "${_name}" || "${_name}" "${extension_args[@]}"
  done
}

extension_run()
{
  trace_filter extension_run
  local _type="${action_type:-}" _path="${action_path:-}" _namespaces

  builtin cd "${initial_pwd}"

  # Now launch the extension, based on the determined _type.
  case "${_type}" in
    function)
      _namespaces=${_path##${extension_actions_path}}
      extension_modules_load ${_namespaces//\// }

      action=${action%%(*}
      extension_action_prerequisites
      action_call "${action}" "${extension_args[@]}"
      ;;

    shell)
      [[ "${action##*/}" != help ]] || modules ext/help

      _namespaces=${_path##${extension_actions_path}}
      extension_modules_load ${_namespaces//\// }

      extension_action_prerequisites
      action_source "${_path}/${action}" "${extension_args[@]}"
      ;;

    ruby)
      requires=()
      for script in functions initialize
      do
        requires+=( "-r${modules_path}/ruby/core/${script}.rb" )
      done

      "${binary:-ruby}" -I"${modules_path}/ruby" -I"${extension_modules_path}/ruby" \
        ${requires[@]} "${_path}/${action}"
      ;;
    # python|lua|javascript)
      #   ADD "${modules_path}/${_type}/" to the lib path so the script can require "sm"
      #  "${_path}"
      #  ;;
    dne|noexec)
      fail "Processing ${action} failed; file type is unknown, file does not exist, or file is not executable."
      ;;
    binary|*)
      "${_path}/${action}" ${extension_action} "${extension_args[@]}"
      ;;
  esac
}

#
# ## extension\_action()
#
# Load the environment for a given extension action, then call it.
# This is the main function for BDSM.
#
# ### Input Parameters
#
# One or more extension names.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's initialize file will be resourced into the current
# environment.
#
# ### Return Codes
#
# 0 for success.
# 1 for failure
#
# ### Failure Scenarios
#
# Fails if no extension was given.
# Fails if no action was given.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/bin/sm
#     modules ext/extensions
#     extension_action ext list
#
#     $  $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis svc tig tmux zeromq zlib
#
#
extension_action()
{
  (( extension_action_calls == 0 )) ||
    fail "Cannot call a 2nd time:\n"\
    "  extension_action ${extension_args[@]}"

  extension_action_calls+=1

  unset extension action

  #TODO: Should be moved to core/cli?
  case "${extension_args[0]}" in
    *=*) # exact version specifier
      package_name="${extension_args[0]}"
      export package_version="${package_name##*=}"
      export package_name="${package_name%%=*}"
      export extension="${package_name}"
      extension_args[0]="${extension}"
      ;;
    *:*)
      package_name="${extension_args[0]}"
      export package_version="${package_name##*:}"
      export package_name="${package_name%%:*}"
      export extension="${package_name}"
      extension_args[0]="${extension}"
      ;;
  esac

  if in_search_paths detect_cached_action "${extension_args[@]}" \
  || in_search_paths detect_modules_action "${extension_args[@]}"
  then
    log_search action "$action" "${action_path##${sm_path}\/} params:${extension_args[@]}"
  else
    if in_search_paths detect_extension_existence "${extension_args[@]}" \
    && [[ "${extension}" == "${extension_args}" ]]
    then
      log_search extension "$extension" "$extensions_path"
      error "Unknown action path: "${extension_args[@]}"\n\nUsage: \n  sm extension [namespace] [action].\n"
    else
      error "Could not find extension: "${extension_args}"\n"
    fi
  fi

  extension_path="$extensions_path/$extension"
  extension_config_path="$extension_path/config"
  extension_templates_path="$extension_path/templates"
  extension_modules_path="$extension_path/modules"
  extension_actions_path="$extension_path/actions"
  extension_log_path="$log_path/$extension"

  paths=$(env | awk -F= -v ORS=' ' '/_path/{print $1}')
  flags=$(env | awk -F= -v ORS=' ' '/_flag/{print $1}')

  debug search "environment:
  action=${action}
  action_path=${action_path}
  extension_args=${extension_args}
  extension_path=${extension_path}
  extension_config_path=${extension_config_path}
  extension_templates_path=${extension_templates_path}
  extension_modules_path=${extension_modules_path}
  extension_actions_path=${extension_actions_path}
  extension_log_path=${extension_log_path}"

  enter "${extension_path}"
  sm_exports
}

extensions_installed()
{
  local _token _type _modules _paths=() _excludes=() _exclude

  args="$*"

  while (( $# > 0 ))
  do
    _token="$1"
    shift
    case "${_token}" in
      (sets|exts)
        _paths+=("${sm_path}/${_token}")
        ;;
      (module|type)
        _type="$1"
        shift || fail "An module type must follow the '${_token}' keyword"
        ;;
      (in)
        _paths="${1}"
        shift || fail "A path must follow keyword 'in'"
        ;;
      (exclude)
        _exclude="${1}"
        shift || fail "A string must follow keyword 'exclude'"
        _excludes+=("${_exclude//,/ }")
        ;;
      (*)
        fail "Unkown token ${_token} given"
        ;;
    esac
  done

  [[ -n ${_paths:-} ]] || {
    _paths=( "${sm_path}/sets" "${sm_path}/exts" )
    ensure_paths_exist "${_paths[@]}"
  }

  _modules=($( find "${_paths[@]}" -mindepth 2 -name "modules" -type f ))

  _excludes="${_excludes[*]:-'#'}"

  if [[ -n "${_type:-}" ]]
  then # Filter by type given
    "${sm_path}/bin/sm-ll" \
      if grep -q "'${_type}'" {} \; then echo {} \; fi ::: ${_modules[@]} |
        sed -e "s#${sm_path}/sets/##" -e "s#${sm_path}/exts/##" \
          -e "s#/modules/shell/modules##" | sort | awk '!'"/${_excludes// /|}/"
  else
    echo ${_modules[@]} | awk '!'"/${_excludes// /|}/"
  fi
}
