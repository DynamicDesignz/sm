#!/bin/sh

#TODO: rename module to detection (after it is renamed to execution)

modules_actions_cache_initialize()
{
  trace_filter action_cache

  (( ! "${#_module_cache[@]}" )) || return 0
  local _module_path _module_name _action_pair

  for _module_path in $( find "${_modules_root}${_modules_path}" -name modules -type f || return 1 )
  do
    _module_name="${_module_path#${_modules_root}\/}"
    _module_name="${_module_name%modules}"
    _module_name="${_module_name%\/}"
    while read _module_dep
    do
      if in_search_paths detect_module "${_module_dep}" &&
        [[ -f "${module_path}/actions" ]] &&
        [[ -s "${module_path}/actions" ]]
      then
        log_search "actiondep" "${extension}${_module_name:+/}${_module_name}" "${module_path#${sm_path}\/}/actions"
        while read _action_pair
        do
          if [[ "${_action_pair}" == [[:alpha:]]* ]]
          then
            _modules_actions_cache+=( "${_module_name:+${_module_name}/}${_action_pair/=*}=${_module_name:+${_module_name}/}${_action_pair/*=}" )
          fi
        done < "${module_path}/actions"
      fi
    done < ${_module_path}
  done
  #for _action_pair in ${_modules_actions_cache[@]}
  #do log_search "m-a-cache" "${_action_pair%%=*}" "${_action_pair#*=}"
  #done
}

action_cache_check_short()
{
  trace_filter action_cache

  local _found _found_actions=() _name="${1}" _item
  shift || fail "No action name was given for search"

  if [[ -f "${_actions_map}" ]]
  then
    _found_actions+=( $( grep "/${_name}[=/]" < "${_actions_map}" ) )
  fi

  if (( ${#_modules_actions_cache[@]} ))
  then
    for _item in "${_modules_actions_cache[@]}"
    do
      if [[ "${_item}" == "${_name}="* ]]
      then
        _found_actions+=("${_item}")
      fi
    done
  fi

  if (( ${#_found_actions[@]} == 1 ))
  then
    _found_actions="${_found_actions#*=}"
    action="${_found_actions##*/}"
    action_path="${extensions_path}/${extension}/actions/${_found_actions}"
    action_path="${action_path%/*}"
    extension_args=( "${_rest_params[@]}" )
    return 0

  elif (( ${#_found_actions[@]} ))
  then
    local _candidate _candidates=()
    for _candidate in "${_found_actions[@]}"
    do
      _candidate="${_candidate%%=*}"
      _candidates+=( "sm ${extension} ${_candidate//\// } ${_rest_params[@]}\n" )
    done

    error "More than one action found matching, please be more specific.\n\nDid you mean:\n${_candidates[*]}\n"

  else
    debug search "no actions found in '${extension}' for '${1}'"
  fi
  return 1
}

action_cache_check()
{
  trace_filter action_cache

  local _found _name="${1:-}" _item _found_actions=()
  shift || fail "No action name given."

  _found="$( grep "^${_name}=" "${_actions_map}" 2>/dev/null || true )"
  if [[ -n "${_found}" ]]
  then
    _found="${_found/*=}"
    action="${_found##*/}"
    action_path="${_found%/*}"
    [[ "${action_path}" != "${_found}" ]] || action_path=""
    action_path="$extensions_path/$extension/actions/${action_path}"
    extension_args=( "${_rest_params[@]}" )
    debug search ":cached(${_actions_map}):${_action_path}=${_found}:params=${_rest_params[*]}:"
    return 0
  else
    if (( ${#_modules_actions_cache[@]} ))
    then
      for _item in "${_modules_actions_cache[@]}"
      do
        if [[ "${_item}" == "^${_name}="* ]]
        then
          _found_actions+=("${_item}")
        fi
      done

      if (( ${#_found_actions[@]} == 1 ))
      then
        _found_actions="${_found_actions#*=}"
        action="${_found_actions##*/}"
        action_path="${extensions_path}/${extension}/actions/${_found_actions}"
        action_path="${action_path%/*}"
        extension_args=( "${_rest_params[@]}" )
        return 0
      fi
    fi
  fi
  return 1
}

action_from_actions_map()
{
  trace_filter action_cache

  local _actions_map="${extensions_path}/${extension}/actions.map"
  local _modules_root="${extensions_path}/${extension}/modules/shell"
  local _action_params=("$@") _action_path _new_action_path
  local _rest_params=() _param_temp _action_params_length _modules_actions_cache=()

  modules_actions_cache_initialize

  if [[ ! -f "${_actions_map}" ]]
  then
    log_search "missing" "actions map" "${_actions_map}"
  fi

  if [[ -f "${_actions_map}" ]] || (( ${#_modules_actions_cache[@]} ))
  then
    while :
    do
      _action_path="${_action_params[*]}"
      _action_path="${_action_path// //}"

      if action_cache_check "${_action_path}" ||
        action_cache_check_short "${_action_path}"
      then
        return 0
      fi

      # Not found, go down one level
      _action_params_length=${#_action_params[@]}
      (( _action_params_length )) || break # finish if no more params

      #TODO: account for zsh indexes ( -1 -> -0 )
      _param_temp="${_action_params[$(( _action_params_length - 1 ))]}"
      _rest_params=( "${_param_temp}" "${_rest_params[@]}" )
      unset _action_params[$(( _action_params_length - 1 ))]
    done
  else
    error "${extensions_path}/${extension} does not have actions.map or module dependencies with actions"
  fi
  return 1
}

cached_action()
{
  trace_filter action_cache
  extensions_path="${1:-}" extension="${2:-}"
  shift || fail "Cannot detect extension existence;"\
    " No extension path was given."
  shift || fail "Cannot detect extension existence;"\
    " No extension name was given."

  extension_is_valid $extensions_path/$extension &&
    action_from_actions_map "$@"
}

#
# ## extension\_action()
#
# Load the environment for a given extension action, then call it.
# This is the main function for BDSM.
#
# ### Input Parameters
#
# One or more extension names.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's initialize file will be resourced into the current
# environment.
#
# ### Return Codes
#
# 0 for success.
# 1 for failure
#
# ### Failure Scenarios
#
# Fails if no extension was given.
# Fails if no action was given.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/bin/sm
#     modules ext/extensions
#     extension_action ext list
#
#     $  $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis svc tig tmux zeromq zlib
#
#
extension_action()
{
  (( extension_action_calls == 0 )) ||
    fail "Cannot call a 2nd time, args: ${extension_args[*]}"

  extension_action_calls+=1

  unset extension action

  #TODO: Should be moved to core/cli?
  case "${extension_args[0]}" in
    (*=*) # exact version specifier
      package_name="${extension_args[0]}"
      export package_version="${package_name##*=}"
      export package_name="${package_name%%=*}"
      export extension="${package_name}"
      extension_args[0]="${extension}"
      ;;
    (*:*)
      package_name="${extension_args[0]}"
      export package_version="${package_name##*:}"
      export package_name="${package_name%%:*}"
      export extension="${package_name}"
      extension_args[0]="${extension}"
      ;;
  esac

  if in_search_paths cached_action "${extension_args[@]}"
  then
    log_search action "$action" "${action_path##${sm_path}\/} params:${extension_args[@]}"
  else
    if in_search_paths detect_extension_existence "${extension_args[@]}" \
    && [[ "${extension}" == "${extension_args}" ]]
    then
      log_search extension "$extension" "$extensions_path"
      error "Unknown action path: "${extension_args[@]}"\n\nUsage: \n  sm extension [namespace] [action].\n"
    else
      error "Could not find extension: "${extension_args}"\n"
    fi
  fi

  extension_path="$extensions_path/$extension"
  extension_config_path="$extension_path/config"
  extension_templates_path="$extension_path/templates"
  extension_modules_path="$extension_path/modules"
  extension_actions_path="$extension_path/actions"
  extension_log_path="$log_path/$extension"

  paths=$(env | awk -F= -v ORS=' ' '/_path/{print $1}')
  flags=$(env | awk -F= -v ORS=' ' '/_flag/{print $1}')

  debug search "environment:
  action=${action}
  action_path=${action_path}
  extension_args=${extension_args}
  extension_path=${extension_path}
  extension_config_path=${extension_config_path}
  extension_templates_path=${extension_templates_path}
  extension_modules_path=${extension_modules_path}
  extension_actions_path=${extension_actions_path}
  extension_log_path=${extension_log_path}"

  enter "${extension_path}"
  sm_exports
}
