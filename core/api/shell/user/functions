#!/bin/sh

user()
{
  trace_filter users

  local _command _subcommand _user _group _source _flags=() _value
  local __user_commands=(
    "is root"
    "is privileged"
    "is unprivileged"
    "set home"
    "set shell"
    "create unless exists"
    "create=add"
    "delete=remove"
  )

  if __sm.command.detect "$*" "${__user_commands[@]}"
  then
    _command="${__sm_command_dotted}"
    shift "${__sm_command_words}"
  else
    fail "No command given.\nUsage:  \nextension <command> ..."
  fi

  case "${_command}" in
    (set.home)
      _value="$1"
      shift || fail "A home path must follow keyword 'home';"\
        "user set home /home/{username} for {username}"
      ;;
    (set.shell)
      _value="$1"
      shift || fail "A shell must follow keyword 'shell'"\
        "user set shell /bin/zsh for {username}"
      ;;
    (exists)
      _user="$1"
      shift || fail "A user name must follow keyword 'exists'"\
        "user exists {username}"
      ;;
  esac

  while (( $# > 0 ))
  do
    _token="$1" && shift
    case "${_token}" in
      (login)
        _flags+=( - )
        ;;
      (name|user|for)
        _user="$1"
        shift || fail "User name must follow keyword 'user'"
        ;;
      (group)
        _group="${1:-}"
        shift || fail "Group name must follow keyword 'group'"
        ;;
      (from)
        _source="${1:-}"
        shift || fail "from source name must follow keyword 'from'"
        ;;
      (force)
        _flags+=(-f)
        ;;
      (*)
        fail "Unhandled token '${_token}'"
        ;;
    esac
  done

  case "${_command}" in
    (is.*)
      if __sm.user.${_command} ; then return 0 ; else return 1 ; fi
      ;;
    (home|shell)
      __sm.user.${_command} ${_user}
      ;;
    (set.*)
      __sm.user.${_command} ${_user} ${_value}
      ;;
    (add|create.if.not.exists)
      __sm.user.${_command} "${_user}" "${_group}" "${_flags[*]}"
      ;;
    (remove)
      __sm.user.${_command} "${_user}" "${_flags[*]}"
      ;;
    (*)
      fail "Unknown command '${_command}'"
      ;;
  esac
}

