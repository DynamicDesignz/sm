#!/bin/sh

variables()
{
  trace_filter variables

  local _command _variables=() _type

  if __sm.string.starts.with.one.off  "$* " \
    "are empty " \
    "are nonempty " \
    "must be empty " \
    "must be nonempty "
  then
    _command=$( __sm.string.to.function.name "${__sm_string_starts_with}" )
    shift $( __sm.string.number.of.words "${__sm_string_starts_with}" )
  else
    _command="$1"
    shift || fail "Usage: extension <command> ..."
  fi

  while (( $# ))
  do
    case "$1" in
      (type)
        case "$2" in
          (log|error|fail)
            _type=$2
            shift 2
            ;;
          ("")
            fail "Variable output type was not given after 'type'. " \
              "Valid types are: log, error, fail"
            ;;
          (*)
            fail "Variable output type '$2' in not valid. " \
              "Valid types are: log, error, fail"
            ;;
        esac
        ;;
      (*)
        _variables+=( "$1" )
        shift
        ;;
    esac
  done

  # TODO: Think through variables more...
  case "${_command}" in
    (are.empty|are.nonempty)
      [[ -n "${_variables[*]}" ]] || error "No variable names given for validation"
      __sm.variables.${_command} "${_variables[@]}"
      ;;
    (must.be.empty|must.be.nonempty)
      [[ -n "${_variables[*]}" ]] || error "No variable names given for validation"
      [[ -n "${_type}" ]] || error "No message type given for validation"
      __sm.variables.${_command} "${_type}" "${_variables[@]}"
      ;;
    (*)
      fail "Unknown variables command '${_command}'"
      ;;
  esac
}

